<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[flutter eventChannel crash on ios]]></title>
    <url>%2F2019%2F10%2F21%2Fflutter-eventChannel-crash-on-ios%2F</url>
    <content type="text"><![CDATA[flutter issuecrash 记录一次困扰了很久的 flutter event channel crash EventChannel dart1234567891011121314151617181920212223242526272829303132333435363738394041Stream&lt;dynamic&gt; receiveBroadcastStream([ dynamic arguments ]) &#123; final MethodChannel methodChannel = MethodChannel(name, codec); StreamController&lt;dynamic&gt; controller; controller = StreamController&lt;dynamic&gt;.broadcast(onListen: () async &#123; defaultBinaryMessenger.setMessageHandler(name, (ByteData reply) async &#123; if (reply == null) &#123; controller.close(); &#125; else &#123; try &#123; controller.add(codec.decodeEnvelope(reply)); &#125; on PlatformException catch (e) &#123; controller.addError(e); &#125; &#125; return null; &#125;); try &#123; await methodChannel.invokeMethod&lt;void&gt;('listen', arguments); &#125; catch (exception, stack) &#123; FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: stack, library: 'services library', context: ErrorDescription('while activating platform stream on channel $name'), )); &#125; &#125;, onCancel: () async &#123; defaultBinaryMessenger.setMessageHandler(name, null); try &#123; await methodChannel.invokeMethod&lt;void&gt;('cancel', arguments); &#125; catch (exception, stack) &#123; FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: stack, library: 'services library', context: ErrorDescription('while de-activating platform stream on channel $name'), )); &#125; &#125;); return controller.stream; &#125; FlutterChannel.mm1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static void SetStreamHandlerMessageHandlerOnChannel(NSObject&lt;FlutterStreamHandler&gt;* handler, NSString* name, NSObject&lt;FlutterBinaryMessenger&gt;* messenger, NSObject&lt;FlutterMethodCodec&gt;* codec) &#123; __block FlutterEventSink currentSink = nil; FlutterBinaryMessageHandler messageHandler = ^(NSData* message, FlutterBinaryReply callback) &#123; FlutterMethodCall* call = [codec decodeMethodCall:message]; if ([call.method isEqual:@"listen"]) &#123; if (currentSink) &#123; FlutterError* error = [handler onCancelWithArguments:nil]; if (error) NSLog(@"Failed to cancel existing stream: %@. %@ (%@)", error.code, error.message, error.details); &#125; currentSink = ^(id event) &#123; if (event == FlutterEndOfEventStream) [messenger sendOnChannel:name message:nil]; else if ([event isKindOfClass:[FlutterError class]]) [messenger sendOnChannel:name message:[codec encodeErrorEnvelope:(FlutterError*)event]]; else [messenger sendOnChannel:name message:[codec encodeSuccessEnvelope:event]]; &#125;; FlutterError* error = [handler onListenWithArguments:call.arguments eventSink:currentSink]; if (error) callback([codec encodeErrorEnvelope:error]); else callback([codec encodeSuccessEnvelope:nil]); &#125; else if ([call.method isEqual:@"cancel"]) &#123; if (!currentSink) &#123; callback( [codec encodeErrorEnvelope:[FlutterError errorWithCode:@"error" message:@"No active stream to cancel" details:nil]]); return; &#125; currentSink = nil; FlutterError* error = [handler onCancelWithArguments:call.arguments]; if (error) callback([codec encodeErrorEnvelope:error]); else callback([codec encodeSuccessEnvelope:nil]); &#125; else &#123; callback(nil); &#125; &#125;; [messenger setMessageHandlerOnChannel:name binaryMessageHandler:messageHandler];&#125; EventSink正常结束stream流 eventSink(FlutterEndOfEventStream) ，异常结束stream流 eventSink(FlutterError) 都会回调执行 onCancel 参考Flutter 与 Native(iOS) 通信原理]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter ios 13 dark mode]]></title>
    <url>%2F2019%2F10%2F14%2Fflutter-ios-13-dark-mode%2F</url>
    <content type="text"><![CDATA[前言ios 13 开启 dark model,flutter页面status bar文字一直是白色 flutter issues 1SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle.dark); 设置dark style 并没有用 SystemChrome12345678910111213141516171819202122232425static void setSystemUIOverlayStyle(SystemUiOverlayStyle style) &#123; assert(style != null); if (_pendingStyle != null) &#123; // The microtask has already been queued; just update the pending value. _pendingStyle = style; return; &#125; if (style == _latestStyle) &#123; // Trivial success: no microtask has been queued and the given style is // already in effect, so no need to queue a microtask. return; &#125; _pendingStyle = style; scheduleMicrotask(() &#123; assert(_pendingStyle != null); if (_pendingStyle != _latestStyle) &#123; SystemChannels.platform.invokeMethod&lt;void&gt;( 'SystemChrome.setSystemUIOverlayStyle', _pendingStyle._toMap(), ); _latestStyle = _pendingStyle; &#125; _pendingStyle = null; &#125;); &#125; FlutterPlatformPlugin1234567891011121314151617181920212223242526272829- (void)setSystemChromeSystemUIOverlayStyle:(NSDictionary*)message &#123; NSString* style = message[@"statusBarBrightness"]; if (style == (id)[NSNull null]) return; UIStatusBarStyle statusBarStyle; if ([style isEqualToString:@"Brightness.dark"]) statusBarStyle = UIStatusBarStyleLightContent; else if ([style isEqualToString:@"Brightness.light"]) statusBarStyle = UIStatusBarStyleDefault; else return; NSNumber* infoValue = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"UIViewControllerBasedStatusBarAppearance"]; Boolean delegateToViewController = (infoValue == nil || [infoValue boolValue]); if (delegateToViewController) &#123; // This notification is respected by the iOS embedder [[NSNotificationCenter defaultCenter] postNotificationName:@(kOverlayStyleUpdateNotificationName) object:nil userInfo:@&#123;@(kOverlayStyleUpdateNotificationKey) : @(statusBarStyle)&#125;]; &#125; else &#123; // Note: -[UIApplication setStatusBarStyle] is deprecated in iOS9 // in favor of delegating to the view controller [[UIApplication sharedApplication] setStatusBarStyle:statusBarStyle]; &#125;&#125; engine 源码中 可以看到 没有 UIStatusBarStyleDarkContent 尝试 去掉 info.plist 中的 UIViewControllerBasedStatusBarAppearance 然后 监听 通知 1234567[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appStatusBar:) name:@"io.flutter.plugin.platform.SystemChromeOverlayNotificationName" object:nil];- (void)appStatusBar:(id)notification &#123; if (@available(iOS 13.0, *)) &#123; [UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleDarkContent; &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustache之dart]]></title>
    <url>%2F2019%2F05%2F31%2Fmustache%E4%B9%8Bdart%2F</url>
    <content type="text"><![CDATA[前言Mustache 是一个 logic-less （轻逻辑）模板解析引擎，可以应用在 js、PHP、Python、Perl 等多种编程语言中。这里主要是看dart中的应用。 模板语法很简单 看这里1234567&#123;&#123;keyName&#125;&#125; &#123;&#123;#keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;&#123;&#123;^keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;&#123;&#123;.&#125;&#125;&#123;&#123;&gt;partials&#125;&#125;&#123;&#123;&#123;keyName&#125;&#125;&#125;&#123;&#123;!comments&#125;&#125; 使用在flutter项目中，使用annation router注解的方式生成路由表管理类 RouterManager ，以及业务相关的类文件（ios android）在使用mustache之前，是通过stringbuff 的方式拼接字符串，也可以完成，但是阅读性比较差。 之前123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// 生成路由表类 StringBuffer sb = new StringBuffer(); sb..write(_createImport())..write(_createClazz(element.name)); return sb.toString();/// 生成路由表类的 import 信息 String _createImport() &#123; StringBuffer sb = new StringBuffer(); sb ..writeln("import 'package:flutter/material.dart';") ..writeln("import 'package:hybrid_router/hybrid_router.dart';"); /// import page collector.importClazzList.forEach((clazz) &#123; sb.writeln("import '$clazz';"); &#125;); return sb.toString(); &#125; /// 生成路由表类的 clazz 信息 String _createClazz(String className) &#123; StringBuffer sb = new StringBuffer(); /// start class sb.writeln("class \$$className &#123;"); /// generateRoute function sb ..writeln(" Map&lt;String, HybridWidgetBuilder&gt; generateRoutes()&#123;") ..writeln(" return &#123;"); collector.routeMap.forEach((key, value) &#123; String flutterPath = value.flutterPath; sb ..writeln(" '$flutterPath': (BuildContext context, Object args) &#123;") ..writeln(" $&#123;_createInstance(value)&#125;") ..writeln(" &#125;,"); &#125;); sb..writeln(" &#125;;")..writeln(" &#125;"); /// generateSpm function sb ..writeln(" Map&lt;String, String&gt; generateSpm() &#123;") ..writeln(" return &#123;"); collector.routeMap.forEach((key, value) &#123; String flutterSpm = value.flutterSpm; String flutterPath = value.flutterPath; if (flutterSpm?.isNotEmpty == true) &#123; sb.writeln(" '$flutterPath': '$flutterSpm',"); &#125; &#125;); sb..writeln(" &#125;;")..writeln(" &#125;"); /// end class sb.writeln("&#125;"); return sb.toString(); &#125; 之后1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/// 生成路由表类 _createRouteManager(element.name); String _createRouteManager(String className) &#123; return VDTemplate.routerManagerTemplate().renderString(&#123; 'classname':className, 'classes':collector.importClazzList, 'routes':collector.routeMap.values, 'createInstance':(LambdaContext ctx) &#123; CollectorItem item = ctx.lookup('.'); return _createInstance(item); &#125; &#125;); &#125; static Template routerManagerTemplate() &#123; var source = '''&#123;&#123;&gt; import&#125;&#125;&#123;&#123;&gt; clazz&#125;&#125; '''; Map&lt;String,Template&gt; map = &#123; "import":VDTemplate.importTemplate(), "clazz":VDTemplate.claszzTemplate() &#125;; return new Template(source,partialResolver: (String name) =&gt; map[name]); &#125; static Template importTemplate() &#123; var source = '''import 'package:flutter/material.dart';import 'package:hybrid_router/hybrid_router.dart';&#123;&#123;# classes &#125;&#125;import '&#123;&#123;&#123;.&#125;&#125;&#125;';&#123;&#123;/ classes &#125;&#125; '''; return new Template(source); &#125; static Template claszzTemplate() &#123; var source = '''class \$&#123;&#123;classname&#125;&#125; &#123; Map&lt;String, HybridWidgetBuilder&gt; generateRoutes()&#123; return &#123; &#123;&#123;#routes&#125;&#125; '&#123;&#123;flutterPath&#125;&#125;': (BuildContext context, Object args) &#123; &#123;&#123;createInstance&#125;&#125; &#125;, &#123;&#123;/routes&#125;&#125; &#125;; &#125; Map&lt;String, String&gt; generateSpm() &#123; return &#123; &#123;&#123;#routes&#125;&#125; &#123;&#123;# flutterSpm&#125;&#125; '&#123;&#123;flutterPath&#125;&#125;': '&#123;&#123;flutterSpm&#125;&#125;', &#123;&#123;/ flutterSpm&#125;&#125; &#123;&#123;/routes&#125;&#125; &#125;; &#125; &#125; '''; return new Template(source); &#125; 对比看下，使用mustache之后，可读性好很多，基本保持了代码结构 总结 字符串数组，可以使用{{.}} 对象数据，可以跟普通的hash一样，直接用{{对象的属性}}，mustache内部通过dart反射拿到属性值 使用partials 拆分template 增加可读性 通过lambda函数执行dart方法，也可以做到拆分的作用 lambdaContext.loopup(&quot;.&quot;) 可以获取对象实例，进而可以参数传递 mustache内部renderstring也是通过stringbuff的方式实现 参考链接mustache 1.1.1Flutter路由管理]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>mustache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vmstatu]]></title>
    <url>%2F2019%2F05%2F22%2Fvmstatus%2F</url>
    <content type="text"><![CDATA[vmstatuvmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。相比top，可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。 1234$vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 215220 0 771404 0 0 2 15 0 1 0 0 100 0 0 一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数 12345$vmstat 2 2procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 202924 0 785780 0 0 2 15 0 1 0 0 100 0 0 0 0 0 203032 0 785812 0 0 0 155 748 1382 0 0 100 0 0 第二个参数如果没有，就会一直采集（ctrl+c 结束） 12345678$vmstat 2procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 194712 0 794728 0 0 2 15 0 1 0 0 100 0 0 0 0 0 194696 0 794768 0 0 0 50 782 1368 0 0 100 0 0 0 0 0 193828 0 794776 0 0 0 108 752 1156 0 0 100 0 0 0 0 0 193952 0 794804 0 0 0 4 601 997 0 0 100 0 0^C 字段procs r 等待运行的进程数 b 处在非中断睡眠状态的进程数 memory （KB） swpd 虚拟内存使用大小 注意：如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。 free 空闲的内存 buff 用作缓冲的内存大小 cache 用作缓存的内存大小 注意：如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。 swap si 从交换区写到内存的大小 so 每秒写入交换区的内存大小 内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。 io bi 每秒读取的块数 bo 每秒写入的块数 注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。 system in 每秒中断数，包括时钟中断。 cs 每秒上下文切换数。 注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。 cpu us 用户进程执行时间(user time) 注意： us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。 sy 系统进程执行时间(system time) 注意：sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。 id 空闲时间(包括IO等待时间),中央处理器的空闲时间 。以百分比表示。 wa 等待IO时间百分比 注意：wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。 1234567891011121314151617181920212223242526Procsr: The number of processes waiting for run time.b: The number of processes in uninterruptible sleep.Memoryswpd: the amount of virtual memory used.free: the amount of idle memory.buff: the amount of memory used as buffers.cache: the amount of memory used as cache.inact: the amount of inactive memory. (-a option)active: the amount of active memory. (-a option)Swapsi: Amount of memory swapped in from disk (/s).so: Amount of memory swapped to disk (/s).IObi: Blocks received from a block device (blocks/s).bo: Blocks sent to a block device (blocks/s).Systemin: The number of interrupts per second, including the clock.cs: The number of context switches per second.CPUThese are percentages of total CPU time.us: Time spent running non-kernel code. (user time, including nice time)sy: Time spent running kernel code. (system time)id: Time spent idle. Prior to Linux 2.5.41, this includes IO-wait time.wa: Time spent waiting for IO. Prior to Linux 2.5.41, included in idle.st: Time stolen from a virtual machine. Prior to Linux 2.6.11, unknown.]]></content>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sublime text 3]]></title>
    <url>%2F2019%2F05%2F14%2Fsublime-text-3%2F</url>
    <content type="text"><![CDATA[sublime text3 install package controlTools -&gt; Install package control 报错信息工具栏View 点击show console 或者快捷键 ctrl+` 打开控制台看下如下报错信息 1234Visit https://packagecontrol.io/installation for manual instructionsError installing Package Control: HTTPS error encountered, falling back to HTTP - &lt;urlopen error [Errno 60] Operation timed out&gt;Error installing Package Control: HTTP error encountered, giving up - &lt;urlopen error [Errno 60] Operation timed out&gt;error: An error occurred installing Package Control 处理办法绑定域名 1250.116.34.243 sublime.wbond.net50.116.34.243 packagecontrol.io install package报错信息There are no packages available for installation 处理办法下载 channel_v3.json 文件 （google一下） 修改package control.sublime-settings 123&quot;channels&quot;: [ &quot;/path/to/channel_v3.json&quot;]]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim shortcuts]]></title>
    <url>%2F2019%2F05%2F14%2Fvim-shortcuts%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter之Dart编译]]></title>
    <url>%2F2019%2F05%2F10%2FFlutter%E4%B9%8BDart%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[前言App中使用flutter已经有段时间了，最近遇到一个bug记录一下。更新flutter module工程pubspec plugin依赖，App工程中pod update之后，从功能表现上看依然是老代码。第一感觉是缓存导致的，xcode clean 以及删除DerivedData目录重新build依然不行，flutter module工程中执行flutter clean然后xcode build是正常的，所以应该是dart编译产物有缓存导致的。接下来看下dart编译过程。 编译12cd path/to/flutter moduleflutter build ios --debug --simulator 进入到flutter module工程目录 执行flutter build ios命令 12345Running Xcode build... ├─Assembling Flutter resources... 3.6s └─Compiling, linking and signing... 25.4sXcode build done. 43.9s 可以看到会进行xcode build，进到.ios目录通过xcode打开Runner工程 可以看到build phases中这样一段脚本，这里就是执行dart代码编译的入口。 xcode_backend.sh进入到脚本所在目录，看下build对应的方法 BuildApp 12345678910111213if [[ $# == 0 ]]; then # Backwards-compatibility: if no args are provided, build. BuildAppelse case $1 in "build") BuildApp ;; "thin") ThinAppFrameworks ;; "embed") EmbedFlutterFrameworks ;; esacfi 123456789101112131415161718192021222324252627282930BuildApp() &#123; ... StreamOutput " ├─Assembling Flutter resources..." RunCommand "$&#123;FLUTTER_ROOT&#125;/bin/flutter" --suppress-analytics \ $&#123;verbose_flag&#125; \ build bundle \ --target-platform=ios \ --target="$&#123;target_path&#125;" \ --$&#123;build_mode&#125; \ --depfile="$&#123;build_dir&#125;/snapshot_blob.bin.d" \ --asset-dir="$&#123;derived_dir&#125;/App.framework/$&#123;assets_path&#125;" \ $&#123;precompilation_flag&#125; \ $&#123;flutter_engine_flag&#125; \ $&#123;local_engine_flag&#125; \ $&#123;track_widget_creation_flag&#125; if [[ $? -ne 0 ]]; then EchoError "Failed to package $&#123;project_path&#125;." exit -1 fi StreamOutput "done" StreamOutput " └─Compiling, linking and signing..." RunCommand popd &gt; /dev/null echo "Project $&#123;project_path&#125; built and packaged successfully." return 0&#125; 可以看到 ├─Assembling Flutter resources… 在build ios 执行过程中出现过，flutter build bundle 就会开始真正的dart编译–depfile 指定参与编译的dart文件路径集合–asset-dir 指定资源产物的目录 flutter命令路径 $FLUTTER_ROOT/bin/flutter 123456789101112...FLUTTER_TOOLS_DIR="$FLUTTER_ROOT/packages/flutter_tools"SNAPSHOT_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.snapshot"STAMP_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.stamp"SCRIPT_PATH="$FLUTTER_TOOLS_DIR/bin/flutter_tools.dart"DART_SDK_PATH="$FLUTTER_ROOT/bin/cache/dart-sdk"DART="$DART_SDK_PATH/bin/dart"PUB="$DART_SDK_PATH/bin/pub""$DART" $FLUTTER_TOOL_ARGS "$SNAPSHOT_PATH" "$@" flutter_toools.snapshot实际上就是$FLUTTER_ROOT/packages/flutter_tools这个项目编译生成的snapshot文件 所以flutter build bundle 就是使用dart来执行flutter_tools项目的main方法 flutter_tools路径 $FLUTTER_ROOT/packages/flutter_tools main方法定义 $FLUTTER_ROOT/packages/flutter_tools/bin/flutter_tools.dart 123void main(List&lt;String&gt; args) &#123; executable.main(args);&#125; 再看看 lib/executable.dart ,在这里会预先创建好每一种命令对应的对象command，通过解析args参数找到对应的command。在BuildCommand类中 123456789BuildCommand(&#123;bool verboseHelp = false&#125;) &#123; addSubcommand(BuildApkCommand(verboseHelp: verboseHelp)); addSubcommand(BuildAppBundleCommand(verboseHelp: verboseHelp)); addSubcommand(BuildAotCommand()); addSubcommand(BuildIOSCommand()); addSubcommand(BuildFlxCommand()); addSubcommand(BuildBundleCommand(verboseHelp: verboseHelp)); addSubcommand(BuildWebCommand()); &#125; 看到BuildIOSCommand 以及 BuildBundleCommand的创建。BuildIOSCommand 就是前面提到的flutter build ios 会执行到的，这里我们重点看下BuildBundleCommand是如何编译dart代码的？编译后生成了哪些资源？这些资源都是些什么？ BuildBundleCommand app.dill : 这就是dart代码编译后的二级制文件 Frontend_server.d : 这里面放的是frontend_server.dart.snapshot的绝对路径，使用该snapshot来编译dart代码生成上面的app.dill snapshot_blob.bin.d : 这里面放的是所有参与编译的dart文件的绝对路径的集合，包括项目的代码和flutterSdk的代码以及pub库中的三方代码。 snapshot_blob.bin.d.fingerprint : 这里面放的是snapshot_blob.bin.d中的所有文件的绝对路径以及每个文件所对应的md5值。使用这个md5来判断该文件是否有修改。在每次编译的时候会判断，如果没有文件修改，则直接跳过编译。 编译Dart资源123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127Future&lt;void&gt; build(&#123; TargetPlatform platform, BuildMode buildMode, String mainPath = defaultMainPath, String manifestPath = defaultManifestPath, String applicationKernelFilePath, String depfilePath, String privateKeyPath = defaultPrivateKeyPath, String assetDirPath, String packagesPath, bool precompiledSnapshot = false, bool reportLicensedPackages = false, bool trackWidgetCreation = false, String compilationTraceFilePath, bool createPatch = false, String buildNumber, String baselineDir, List&lt;String&gt; extraFrontEndOptions = const &lt;String&gt;[], List&lt;String&gt; extraGenSnapshotOptions = const &lt;String&gt;[], List&lt;String&gt; fileSystemRoots, String fileSystemScheme,&#125;) async &#123; // xcode_backend.sh中通过--depfile传入进来的 // 默认是build/snapshot_blob.bin.d文件 depfilePath ??= defaultDepfilePath; // 通过--asset-dir传入 // 该目录中文件就是flutter的产物，最终合并到app.framework中的flutter_assets目录 assetDirPath ??= getAssetBuildDirectory(); packagesPath ??= fs.path.absolute(PackageMap.globalPackagesPath); // app.dill dart代码编译后的二级制文件 applicationKernelFilePath ??= getDefaultApplicationKernelPath(trackWidgetCreation: trackWidgetCreation); final FlutterProject flutterProject = await FlutterProject.current(); if (compilationTraceFilePath != null) &#123; if (buildMode != BuildMode.dynamicProfile &amp;&amp; buildMode != BuildMode.dynamicRelease) &#123; compilationTraceFilePath = null; &#125; else if (compilationTraceFilePath.isEmpty) &#123; // Disable JIT snapshotting if flag is empty. printStatus('Code snapshot will be disabled for this build.'); compilationTraceFilePath = null; &#125; else if (!fs.file(compilationTraceFilePath).existsSync()) &#123; // Be forgiving if compilation trace file is missing. printStatus('No compilation trace available. To optimize performance, consider using --train.'); final File tmp = fs.systemTempDirectory.childFile('flutterEmptyCompilationTrace.txt'); compilationTraceFilePath = (tmp..createSync(recursive: true)).path; &#125; else &#123; printStatus('Code snapshot will use compilation training file $compilationTraceFilePath.'); &#125; &#125; DevFSContent kernelContent; if (!precompiledSnapshot) &#123; if ((extraFrontEndOptions != null) &amp;&amp; extraFrontEndOptions.isNotEmpty) printTrace('Extra front-end options: $extraFrontEndOptions'); ensureDirectoryExists(applicationKernelFilePath); final KernelCompiler kernelCompiler = await kernelCompilerFactory.create(flutterProject); // 编译dart代码，生成app.dill 和 snapshot_blob.bin.d 以及 snapshot_blob.bin.d.fingerprint final CompilerOutput compilerOutput = await kernelCompiler.compile( sdkRoot: artifacts.getArtifactPath(Artifact.flutterPatchedSdkPath), incrementalCompilerByteStorePath: compilationTraceFilePath != null ? null : fs.path.absolute(getIncrementalCompilerByteStoreDirectory()), mainPath: fs.file(mainPath).absolute.path, outputFilePath: applicationKernelFilePath, depFilePath: depfilePath, trackWidgetCreation: trackWidgetCreation, extraFrontEndOptions: extraFrontEndOptions, fileSystemRoots: fileSystemRoots, fileSystemScheme: fileSystemScheme, packagesPath: packagesPath, linkPlatformKernelIn: compilationTraceFilePath != null, ); if (compilerOutput?.outputFilename == null) &#123; throwToolExit('Compiler failed on $mainPath'); &#125; kernelContent = DevFSFileContent(fs.file(compilerOutput.outputFilename)); // 生成 frontend_server.d文件，向文件中写入frontendServerSnapshotForEngineDartSdk的路径 await fs.directory(getBuildDirectory()).childFile('frontend_server.d') .writeAsString('frontend_server.d: $&#123;artifacts.getArtifactPath(Artifact.frontendServerSnapshotForEngineDartSdk)&#125;\n'); if (compilationTraceFilePath != null) &#123; final JITSnapshotter snapshotter = JITSnapshotter(); final int snapshotExitCode = await snapshotter.build( platform: platform, buildMode: buildMode, mainPath: applicationKernelFilePath, outputPath: getBuildDirectory(), packagesPath: packagesPath, compilationTraceFilePath: compilationTraceFilePath, extraGenSnapshotOptions: extraGenSnapshotOptions, createPatch: createPatch, buildNumber: buildNumber, baselineDir: baselineDir, ); if (snapshotExitCode != 0) &#123; throwToolExit('Snapshotting exited with non-zero exit code: $snapshotExitCode'); &#125; &#125; &#125; // 生成 flutter_assets final AssetBundle assets = await buildAssets( manifestPath: manifestPath, assetDirPath: assetDirPath, packagesPath: packagesPath, reportLicensedPackages: reportLicensedPackages, ); if (assets == null) throwToolExit('Error building assets', exitCode: 1); await assemble( buildMode: buildMode, assetBundle: assets, kernelContent: kernelContent, privateKeyPath: privateKeyPath, assetDirPath: assetDirPath, compilationTraceFilePath: compilationTraceFilePath, );&#125; 编译Dart代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class KernelCompiler &#123; const KernelCompiler(); Future&lt;CompilerOutput&gt; compile(&#123; String sdkRoot, String mainPath, String outputFilePath, String depFilePath, TargetModel targetModel = TargetModel.flutter, bool linkPlatformKernelIn = false, bool aot = false, @required bool trackWidgetCreation, List&lt;String&gt; extraFrontEndOptions, String incrementalCompilerByteStorePath, String packagesPath, List&lt;String&gt; fileSystemRoots, String fileSystemScheme, bool targetProductVm = false, String initializeFromDill, &#125;) async &#123; final String frontendServer = artifacts.getArtifactPath( Artifact.frontendServerSnapshotForEngineDartSdk ); FlutterProject flutterProject; if (fs.file('pubspec.yaml').existsSync()) &#123; flutterProject = await FlutterProject.current(); &#125; // TODO(cbracken): eliminate pathFilter. // Currently the compiler emits buildbot paths for the core libs in the // depfile. None of these are available on the local host. Fingerprinter fingerprinter; // 如果snapshot_blob.bin.d文件不为空，则说明有编译缓存 if (depFilePath != null) &#123; // 判断与上次编译对比，是否有文件的md5改变 fingerprinter = Fingerprinter( // snapshot_blob.bin.d.fingerprint文件 fingerprintPath: '$depFilePath.fingerprint', paths: &lt;String&gt;[mainPath], properties: &lt;String, String&gt;&#123; 'entryPoint': mainPath, 'trackWidgetCreation': trackWidgetCreation.toString(), 'linkPlatformKernelIn': linkPlatformKernelIn.toString(), 'engineHash': Cache.instance.engineRevision, 'buildersUsed': '$&#123;flutterProject != null ? flutterProject.hasBuilders : false&#125;', &#125;, depfilePaths: &lt;String&gt;[depFilePath], pathFilter: (String path) =&gt; !path.startsWith('/b/build/slave/'), ); // 判断是否有文件改动，如果没有，则直接返回。 if (await fingerprinter.doesFingerprintMatch()) &#123; printTrace('Skipping kernel compilation. Fingerprint match.'); return CompilerOutput(outputFilePath, 0, /* sources */ null); &#125; &#125; ... // 如果没有上次编译缓存，或者文件有改变，Fingerprinter不匹配，则使用dart重新编译 final List&lt;String&gt; command = &lt;String&gt;[ engineDartPath, frontendServer, '--sdk-root', sdkRoot, '--strong', '--target=$targetModel', ]; ... //参数拼接 final Process server = await processManager .start(command) .catchError((dynamic error, StackTrace stack) &#123; printError('Failed to start frontend server $error, $stack'); &#125;); final StdoutHandler _stdoutHandler = StdoutHandler(); server.stderr .transform&lt;String&gt;(utf8.decoder) .listen(printError); server.stdout .transform&lt;String&gt;(utf8.decoder) .transform&lt;String&gt;(const LineSplitter()) .listen(_stdoutHandler.handler); final int exitCode = await server.exitCode; if (exitCode == 0) &#123; if (fingerprinter != null) &#123; await fingerprinter.writeFingerprint(); &#125; return _stdoutHandler.compilerOutput.future; &#125; return null; &#125;&#125; Fingerprint对比1234567891011121314151617181920212223242526Future&lt;bool&gt; doesFingerprintMatch() async &#123; try &#123; // 获取到当前的 snapshot_blob.bin.d.fingerprint文件 final File fingerprintFile = fs.file(fingerprintPath); if (!fingerprintFile.existsSync()) return false; if (!_depfilePaths.every(fs.isFileSync)) return false; final List&lt;String&gt; paths = await _getPaths(); if (!paths.every(fs.isFileSync)) return false; // 读取缓存的的snapshot_blob.bin.d.fingerprint文件，构建一个老的Fingerprint对象 final Fingerprint oldFingerprint = Fingerprint.fromJson(await fingerprintFile.readAsString()); // 构建一个新的Fingerprint对象 final Fingerprint newFingerprint = await buildFingerprint(); // 对比两次的文件集合中的每个文件的md5是否一样 return oldFingerprint == newFingerprint; &#125; catch (e) &#123; // Log exception and continue, fingerprinting is only a performance improvement. printTrace('Fingerprint check error: $e'); &#125; return false; &#125; 重点 看看 newFingerprint 12345678910111213Future&lt;Fingerprint&gt; buildFingerprint() async &#123; final List&lt;String&gt; paths = await _getPaths(); return Fingerprint.fromBuildInputs(_properties, paths);&#125;Future&lt;List&lt;String&gt;&gt; _getPaths() async &#123; final Set&lt;String&gt; paths = _paths.toSet(); // 使用缓存的snapshot_blob.bin.d文件中的文件集合 for (String depfilePath in _depfilePaths) paths.addAll(await readDepfile(depfilePath)); final FingerprintPathFilter filter = _pathFilter ?? (String path) =&gt; true; return paths.where(filter).toList()..sort();&#125; 可以看到newFingerprint 路径依旧是使用缓存的路径，依次计算路径对应文件的md5，所以问题就在这里了 执行flutter packages upgrade更新pub依赖的时候，build目录下的缓存产物并不会有任何变动，路径依然是老的路径。有一种情况就是module工程 lib 目录下的dat文件有改动，newFingerprint就会跟old不一样，这会重新编译dart，这里又有一个问题，就是如果lib目录下是新增dart文件 则不会被编译进去。 最后综上，执行flutter clean命令，清空build目录缓存文件，build ios 就会重新编译整个dart文件，包括pub依赖中的。 参考链接Flutter深入之flutter-build-bundle命令如何编译Dart?]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
</search>
