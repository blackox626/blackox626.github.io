<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[å½¢çŠ¶ç‰¹æ•ˆ]]></title>
    <url>%2F2022%2F10%2F14%2F%E5%BD%A2%E7%8A%B6%E7%89%B9%E6%95%88%2F</url>
    <content type="text"><![CDATA[å½¢çŠ¶ç‰¹æ•ˆåˆæ¬¡æŽ¥è§¦åˆ°å½¢çŠ¶ç‰¹æ•ˆæ˜¯åœ¨å‰ªæ˜ ï¼Œå‰ªæ˜ ä¸­å«è’™ç‰ˆï¼Œå°±æ˜¯åˆ—ä¸¾äº†ä¸€äº›å¸¸è§å½¢çŠ¶çš„è’™å±‚æ•ˆæžœï¼Œé™¤äº†å¸¸è§„çš„æ—‹è½¬ã€ç¼©æ”¾ã€ä½ç§»ç­‰æ“ä½œå¤–ï¼Œè¿˜æœ‰ä¸ªè™šåŒ–çš„æ•ˆæžœã€‚å¯ä»¥åŽ»å‰ªæ˜ æ„Ÿå—ä¸‹ã€‚ æŽ¥è§¦åˆ°è¿™ä¸œè¥¿ï¼Œè§‰å¾—æ•ˆæžœæŒºä¸é”™ï¼Œæ‰“ç®—ç ”ç©¶ä¸‹ï¼Œæ­£å¥½æ‰‹å¤´çš„ç¼–è¾‘å·¥å…·é¡¹ç›®ä¹Ÿå¯ä»¥ç”¨ä¸Šã€‚çº¿æ€§ã€åœ†å½¢ã€çŸ©å½¢ï¼Œè¿™å‡ ä¸ªè§„èŒƒçš„ï¼Œé€šè¿‡å¹³æ–¹æ ¹å…¬å¼ è·Ÿ ä¸‰è§’å½¢ä½™å¼¦å®šç†åŸºæœ¬éƒ½å¯ä»¥æŽ¨ç®—å‡ºæ¥(å¯ä»¥å‚è€ƒgithub shader)ï¼Œé‡ç‚¹æ¥äº†ï¼Œçˆ±å¿ƒ &amp; äº”è§’æ˜Ÿ æ€Žä¹ˆæžï¼Ÿ ç‰¹æ®Šå½¢çŠ¶çˆ±å¿ƒ ã€äº”è§’æ˜Ÿï¼Œä¸€å¼€å§‹è§‰å¾—å¯èƒ½æ˜¯é€šè¿‡ ä¸‰è§’å‡½æ•°ã€å…³é”®ç‚¹ã€è´å¡žå°”æ›²çº¿ ç­‰æ•°å­¦è®¡ç®—å®žçŽ°çš„ï¼Ÿ æƒ³æƒ³è§‰å¾—è¿™æ ·æ˜¯ä¸æ˜¯è¿‡äºŽå¤æ‚ï¼Œ ä¸€ç¿»googleä¹‹åŽï¼Œè¿˜æ˜¯æ²¡å•¥æ€è·¯ã€‚æ”¾å¤§æ‹›æŠ“åŒ…ï¼Œå‰ªæ˜ çš„ç´ æéƒ½æ˜¯ä¸‹å‘çš„ï¼Œå¿…ç„¶ä¼šæœ‰ç½‘ç»œè¯·æ±‚çš„ï¼Œä¸€é¡¿æ“ä½œä¹‹åŽï¼Œå¦‚æ„¿æ‹¿åˆ°äº†èµ„æºåŒ…ã€‚ çˆ±å¿ƒ äº”è§’æ˜Ÿ çœ‹åˆ°äº†è¿™ä¸¤ä¸ªï¼Œå¾ˆæ˜Žæ˜¾ä¸æ˜¯é€šè¿‡å¤æ‚æ•°å­¦è®¡ç®—å¾—åˆ°çš„ã€‚ ä½†æ˜¯è¿™ä¸€å±‚ä¸€å±‚çš„æ¸å˜çº¢ç»¿å›¾ æ˜¯ä»€ä¹ˆé¬¼ï¼Ÿèµ„æºåŒ…é‡Œè¿˜æœ‰shaderæ–‡ä»¶çš„ðŸ˜„ float alpha = (col.r * 4.0 * 256.0 + col.g * 255.0) / 781.0; é‡ç‚¹çš„å°±æ˜¯è¿™è¡Œè®¡ç®—é€»è¾‘ï¼Œè¿˜æ˜¯æ‡µçš„ã€‚ col.r col.g å¯¹åº”å›¾ä¸Šçš„çº¢ç»¿åˆ†é‡å¯ä»¥ç†è§£*4 /781 æ˜¯ä»€ä¹ˆé¬¼ï¼Ÿ 4 å¯¹åº” å›¾ä¸Šçš„å››å±‚? ç”¨é¢œè‰²å–è‰²å™¨å–è‰²çœ‹çœ‹ï¼Œè¿™ä¸€çœ‹å°±æ˜Žç™½äº†ã€‚ 1234567ç¬¬1å±‚c00d00 ç¬¬2å±‚800000~80ff00 ç¬¬3å±‚400000~40ff00 ç¬¬4å±‚000000~00ff00R * 4 + G ç®—ä¸‹æ¥ ä»Ž 0 åˆ° 781 781 = 12(c0) * 16 * 4 + 13(0d) æ¯å±‚çº¢è‰²åˆ†é‡å›ºå®š(00/40/80/c0)ï¼Œç»¿è‰²åˆ†é‡æ¸å˜0åˆ°255(00-ff)ï¼Œæ‰€ä»¥æ•´ä¸ªå›¾å±‚è§£æžä¸‹æ¥å°±æ˜¯ ä»Ž0 åˆ° 781. alpha è®¡ç®—ä¸‹æ¥å°±æœ‰ 256 *3 + 1 = 769 ä¸ªå€¼ï¼Œæœ€é‡Œé¢çš„ä¸€å±‚æœ€å°çš„ï¼Œå›ºå®šä¸º1ï¼Œä¿éšœæ— è™šåŒ–çš„æ—¶å€™ä¹Ÿæœ‰æœ€åŸºæœ¬çš„å½¢çŠ¶æ•ˆæžœã€‚ æžæ˜Žç™½ä¹‹åŽï¼Œé¡¿æ—¶è§‰å¾—ç§’å•Šï¼Œ å›žå¤´ä¸€æƒ³ï¼Œä¸ºä»€ä¹ˆè¦æžçš„é‚£ä¹ˆå¤šå¤æ‚å‘¢ï¼Ÿ åæ­£æ˜¯ä¸ºäº†è®¡ç®—alphaï¼Œç›´æŽ¥æžä¸ªç°åº¦å›¾ ä»Žé»‘åˆ°ç™½ï¼Œä¸å°±å¥½äº†ï¼Ÿä»”ç»†ä¸€æƒ³ï¼Œç°åº¦å›¾ä¸€ä¸ªåˆ†é‡æœ€å¤š256ä¸ªï¼Œæœ€ç»ˆçš„æ•ˆæžœå‰²è£‚æ„Ÿä¼šå¾ˆæ˜Žæ˜¾ï¼Œæ‰€ä»¥ç”¨åˆ°äº†rã€g ä¸¤ä¸ªåˆ†é‡ï¼Œè®©æ•ˆæžœæ›´ä¸æ»‘ï¼Œå®žé™…ä¸Šå¦‚æžœä½ æƒ³ ä¹Ÿå¯ä»¥ç”¨rbgä¸‰ä¸ªåˆ†é‡ï¼Œé‡æ–°è®¾è®¡ä¸‹è®¡ç®—å…¬å¼ è®©èŒƒå›´æ›´å¤§æ›´ä¸æ»‘ã€‚ ä¸¾ä¸€åä¸‰å­¦ä»¥è‡´ç”¨ï¼Œé‚£å¿…é¡»ä¸¾ä¸€åä¸‰ä¸‹äº†ã€‚ èŠ±åž‹ ç”¨äº”è§’æ˜Ÿå›¾åŽ»æ‰¾è®¾è®¡å¸ˆï¼Œå‚è€ƒä¸€ä¸‹åšä¸€ä¸ªèŠ±åž‹çš„ã€‚è®¾è®¡å¸ˆä¹Ÿä¸€ä¸‹æ²¡æŽŒæ¡ç²¾é«“ï¼Œç…§ç€æžäº†ä¸€ä¸ªä½†ä¸æ˜¯æˆ‘æƒ³è¦çš„ã€‚æ‰€ä»¥æœ‰äº†äººç”Ÿç¬¬ä¸€æ¬¡æŒ‡å¯¼è®¾è®¡å¸ˆç”»å›¾äº†ï¼Œä¸€ç¿»æ“ä½œä¹‹åŽ æžå®šäº† æœ€åŽçš„shader 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#iUniform float iReverse = 0.#iUniform float _X = 0.5#iUniform float _Y = 0.5#iUniform float _S = 0.25#iUniform float _A = 0.#iUniform float _F = 0.00#iUniform float iPlatform_iOS = 1.0const float PI = 3.1415926;#iChannel0 &quot;file://followw813654.jpeg&quot;#iChannel1 &quot;file://mask1.png&quot;vec2 rotation(vec2 uv, float angle, float ratio)&#123; vec2 center = vec2(0.5, 0.5); mat2 zRotation = mat2(cos(angle), sin(angle), -sin(angle) * ratio, cos(angle) * ratio); vec2 centeredPoint = uv - center; vec2 newUv = zRotation * centeredPoint; return vec2(newUv.x, newUv.y / ratio) + center;&#125;vec2 scale(vec2 uv, vec2 scale)&#123; vec2 newPos = vec2(0.5) + (uv - vec2(0.5)) / scale; return newPos;&#125;vec2 offset(vec2 uv, vec2 offset)&#123; return uv + offset;&#125;void main()&#123; highp vec2 textureCoordinate = gl_FragCoord.xy/iResolution.xy; float radio = iResolution.x / iResolution.y; bool ls = (radio &gt; 1.0); vec4 base = texture(iChannel0, textureCoordinate); float _Radio = 1.0; float _Scale = _S * 5.; _Scale = ls ? _Scale / radio : _Scale; float _Angle = 360. * PI / 180. * _A; vec2 _Offset = vec2(_X * 2.0 - 1.0, (_Y * 2.0 - 1.0)); vec2 newUV = offset(textureCoordinate, vec2(-_Offset.x, _Offset.y)); newUV = scale(newUV, vec2(1. * _Scale, radio * _Scale)); newUV = rotation(newUV, _Angle, _Radio); newUV.y = (iPlatform_iOS == 1.) ? newUV.y : (1. - newUV.y); vec4 mask = texture(iChannel1, newUV) * step(newUV.x, 1.) * step(newUV.y, 1.) * step(0., newUV.x) * step(0., newUV.y); vec2 col = mask.rg; // æ€Žä¹ˆç†è§£ ï¼Ÿ æ ¹æ® maskå›¾çš„ ä½œå›¾é¢œè‰²æ­é… åŠ¨æ€è°ƒæ•´ // ç¬¬1å±‚c00d00 ç¬¬2å±‚800000~80ff00 ç¬¬3å±‚400000~40ff00 ç¬¬4å±‚000000~00ff00 // R * 4 + G ç®—ä¸‹æ¥ ä»Ž 0 åˆ° 781 // 781 = 12 * 16 * 4 + 13 float alpha = (col.r * 4.0 * 256.0 + col.g * 255.0) / 781.0; alpha = smoothstep(0.49 - abs(sin(iTime/2.)), 0.51 + abs(sin(iTime/2.)), alpha); if (iReverse &gt; .5) &#123; alpha = 1.0 - alpha; &#125; gl_FragColor = mix(vec4(0, 0, 0, alpha), base, alpha);&#125; å®Œæ•´æ•ˆæžœ]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[åŠ¨æ€æ»¤é•œ]]></title>
    <url>%2F2022%2F10%2F14%2F%E5%8A%A8%E6%80%81%E6%BB%A4%E9%95%9C%2F</url>
    <content type="text"><![CDATA[æ»¤é•œéŸ³è§†é¢‘ç¼–è¾‘å·¥å…·ä¸­ï¼Œå¯¹å›¾åƒæˆ–è€…è§†é¢‘åŠ æ»¤é•œæ˜¯ä¸€ç§å¸¸è§çš„åšæ³•ï¼Œæ™®é€šæ»¤é•œå¾ˆå¥½ç†è§£ï¼Œä¸€å¼ LUTå›¾å°±æžå®šäº†ï¼ŒLUTå›¾ä¸€èˆ¬è®¾è®¡å¸ˆä¼šæä¾›å¥½ï¼Œå¼€å‘æ‹¿è¿‡æ¥è½¬æˆçº¹ç†ï¼Œopenglåšä¸‹é¢œè‰²è½¬æ¢å°±å¥½äº†ï¼Œè¿™é‡Œå°±ä¸å¤šè¯´äº†ã€‚ ä½†æ˜¯ä»Šå¤©æƒ³è®²çš„æ˜¯åŠ¨æ€æ»¤é•œï¼Œä¹Ÿæœ‰å«ç‰¹æ•ˆçš„ï¼ŒåŠ¨æ•ˆç­‰ç­‰ã€‚æ¯”å¦‚å°çº¢ä¹¦/å‰ªæ˜  ç­‰ç­‰,æ„Ÿå—ä¸€ä¸‹å°±å¤§æ¦‚çŸ¥é“äº†ã€‚ åŠ¨æ€æ»¤é•œå…ˆä¸Šä¸€ä¸ªæ•ˆæžœæ„Ÿå—ä¸‹ï¼š è§†é¢‘ï¼š å¾ˆæ˜Žæ˜¾åŠ¨æ€æ»¤é•œè·Ÿæ™®é€šæ»¤é•œæ ¹æœ¬ä¸Šå°±ä¸æ˜¯ä¸€å›žäº‹äº†ï¼Œæ‰€ä»¥æ›´åƒæ˜¯åŠ¨æ•ˆ ç‰¹æ•ˆäº†ï¼Œè¿™é‡Œä¸çº ç»“å«ä»€ä¹ˆï¼Œé‡ç‚¹æ˜¯å…³æ³¨ä¸‹æ€Žä¹ˆåšçš„å‘¢ï¼Ÿç›´è§‚æ„Ÿå—å°±æ˜¯é™æ€å›¾ç‰‡ä¸Šè¦†ç›–äº†ä¸€å¸§å¸§çš„é€æ˜Žå›¾ç‰‡ï¼Œç¡®å®žå°±æ˜¯è¿™ä¹ˆä¸€å›žäº‹ã€‚ ç”¨ä¸€å¸§å¸§çš„å¸¦alphaé€šé“çš„å›¾ç‰‡é›†ï¼Œé€šè¿‡opengl blendä¸€å¸§å¸§èžåˆä¹Ÿå¯ä»¥å®žçŽ°ï¼Œ å¼Šç«¯å¾ˆæ˜Žæ˜¾ï¼Œè™½ç„¶è¿™ç§åŠ¨æ€æ•ˆæžœä¸€èˆ¬ä¹Ÿåªæœ‰å‡ ç§’ï¼ŒæŒ‰30fpsï¼Œä¹Ÿéœ€è¦ç™¾æ¥å¼ å›¾ï¼Œå›¾ç‰‡èµ„æºå¾ˆå¤§ï¼Œgifæ ¼å¼ä¹Ÿä¼šå­˜åœ¨åŒæ ·çš„é—®é¢˜ã€‚å¦‚æžœç”¨è§†é¢‘å‘¢ï¼Ÿ ä½†æ˜¯è§†é¢‘æ²¡æœ‰alphaé€šé“ã€‚ã€‚ æ–¹æ¡ˆå‚è€ƒè…¾è®¯åŠ¨ç”»æ–¹æ¡ˆ vap æˆ‘ä»¬ç”¨ä¸€ç§ç‰¹æ®Šçš„è§†é¢‘ï¼Œè§†é¢‘çš„ä¸€åŠè¡¨ç¤ºrgb å¦ä¸€åŠè¡¨ç¤ºalphaé€šé“ã€‚ è¡¨ç¤ºalphaé€šé“çš„ rgb ä¸‰ä¸ªåˆ†é‡å€¼ä¸€æ ·ï¼Œæ‰€ä»¥æ˜¯ç°åº¦å›¾æ•ˆæžœï¼ŒçŸ¥é“è¿™ç§ç‰¹æ®Šçš„è§†é¢‘æž„æˆ æŽ¥ä¸‹æ¥å°±å¥½å¤„ç†äº† 123456789101112( precision mediump float; varying highp vec2 textureCoordinate; uniform sampler2D inputImageTexture; void main() &#123; vec4 textureColor = texture2D(inputImageTexture,textureCoordinate); vec4 leftColor = texture2D(inputImageTexture,vec2(textureCoordinate.x / 2.0,textureCoordinate.y)); vec4 rightColor = texture2D(inputImageTexture,vec2(textureCoordinate.x / 2.0 + 0.5,textureCoordinate.y)); gl_FragColor = vec4(leftColor.rgb * rightColor.b ,rightColor.b); &#125;); å®žé™…åº”ç”¨ä¸­ï¼Œå€Ÿç”¨GPUImageMoiveæ¥è§£ç ä¸€åŠä¸€åŠçš„è§†é¢‘ï¼Œç„¶åŽè‡ªå®šä¹‰filterï¼Œfragmentshader å°±æ˜¯ä¸Šé¢çš„è¿™æ®µï¼Œæœ€åŽæ¸²æŸ“åˆ°GPUImageViewä¸Šï¼Œå°±è¾¾åˆ°äº†åœ¨é™æ€å›¾ç‰‡ä¸Šæ’­æ”¾é€æ˜Žè§†é¢‘çš„æ•ˆæžœã€‚ 12345678910111213141516171819@interface GPUImageCustomFilter : GPUImageFilter@end@implementation GPUImageCustomFilter- (id)init &#123; if (self = [super initWithFragmentShaderFromString:kGPUImageCustomFragmentShaderString]) &#123; &#125; return self;&#125;/// size width / 2- (void)setInputSize:(CGSize)newSize atIndex:(NSInteger)textureIndex &#123; [super setInputSize:CGSizeMake(newSize.width / 2.0, newSize.height) atIndex:textureIndex];&#125;@end ä½¿ç”¨customFilter 123456789101112131415161718NSURL *url = [NSURL fileURLWithPath:videoPath];CGRect frame = previewView.bounds;GPUImageView *gpuImageView = [[GPUImageView alloc] init];gpuImageView.backgroundColor = [UIColor clearColor];gpuImageView.fillMode = kGPUImageFillModePreserveAspectRatioAndFill;gpuImageView.frame = frame;GPUImageMovie *movie = [[GPUImageMovie alloc] initWithURL:url];movie.shouldRepeat = YES;movie.playAtActualSpeed = YES;movie.runBenchmark = YES;GPUImageCustomFilter *customFilter = [[GPUImageCustomFilter alloc] init];[movie addTarget:customFilter];[customFilter addTarget:gpuImageView];[movie startProcessing];]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[å›¾åƒæè¾¹]]></title>
    <url>%2F2022%2F09%2F10%2F%E5%9B%BE%E5%83%8F%E6%8F%8F%E8%BE%B9%2F</url>
    <content type="text"><![CDATA[image borderæœ€è¿‘é¡¹ç›®ä¸­æžäº†ä¸ªå›¾åƒæè¾¹çš„éœ€æ±‚ï¼Œå¸¸è§çš„ç¾Žå›¾å·¥å…·Appéƒ½æœ‰ç±»ä¼¼çš„åŠŸèƒ½ï¼Œå…¸åž‹çš„å¦‚ç¾Žå›¾ç§€ç§€ï¼Œä¸€å¼€å§‹è§‰å¾—åº”è¯¥ä¸å¤ªå¤æ‚ï¼Œæ­£å¸¸è¯„ä¼°æ—¶é—´ï¼Œå®žé™…åšçš„æ—¶å€™ï¼Œå‘çŽ°é—®é¢˜æ¯”æƒ³è±¡ä¸­çš„å¤æ‚å¤šäº†ï¼Œç»“æžœé¡¹ç›®ä¸å¾—ä¸å»¶æœŸ ðŸ˜­ï¼Œæ‰€ä»¥æœ‰å¿…è¦æžç¯‡æ–‡ç« æ¥æ€»ç»“ä¸‹æ•™è®­ã€‚ å…ˆè¯´æ•´ä½“çš„æµç¨‹ï¼š 1ã€åŽŸå›¾ -&gt; 2ã€æŠ å›¾ -&gt; 3ã€è¾¹ç¼˜æ£€æµ‹ -&gt; 4ã€ç»˜åˆ¶è¾¹ç¼˜ -&gt; 5ã€ç»“æžœå¯¼å‡º è¿™ä¸ªæµç¨‹è¿˜æ˜¯å¾ˆå®¹æ˜“æƒ³åˆ°ï¼Œä½†æ˜¯é™¤äº†æœ€åŽä¸€æ­¥ç›¸å¯¹æ¥è¯´å®¹æ˜“ç‚¹ï¼Œ2ã€3ã€4éƒ½æ˜¯ä¸€è·¯å‘ ðŸ˜ž image mattingé¦–å…ˆæ˜¯æŠ å›¾ï¼Œå°±æ˜¯è¿™æ ·çš„ è·Ÿæˆ‘ä»¬è¿™è¾¹çš„ç®—æ³•åŒå­¦å¯¹æŽ¥ï¼Œçˆ¬è™«æ”¶é›†å›¾åƒã€æ ‡æ³¨ã€æ¨¡åž‹è®­ç»ƒ ä¸€å¥—ç»„åˆä¸‹æ¥ï¼Œæ•ˆæžœä¸ç†æƒ³ï¼Œç”Ÿäº§çŽ¯å¢ƒä¸å¯ç”¨ï¼Œç¬¬ä¸€æ­¥å°±å¡ä½äº† ðŸ˜ž ä¸ºäº†èµ¶é¡¹ç›®å‘¨æœŸï¼Œæœ€åŽä½¿ç”¨äº†é˜¿é‡Œäº‘çš„æ–¹æ¡ˆï¼Œè¿™é‡Œå°±ä¸å¤šè¯´äº†ï¼Œç®—æ³•åŒå­¦æŒç»­ä¼˜åŒ–æ¨¡åž‹ï¼Œå¾…æˆç†Ÿä¹‹åŽæ›¿æ¢é˜¿é‡Œäº‘ã€‚ Edge detectionè¿™ä¸€æ­¥ç›¸å¯¹æ¥è¯´æ˜¯æœ€å¤æ‚çš„ï¼Œè¿™é‡Œé‡åˆ°çš„é—®é¢˜ä¹Ÿæ˜¯æœ€å¤§ï¼Œè€—æ—¶æœ€ä¹… æœ€åˆçš„æ–¹æ¡ˆå¤§è‡´æ˜¯è¿™æ ·çš„ï¼šæŠ å›¾ç»“æžœ-&gt;é‡‡æ ·ç¼©æ”¾å›¾åƒ-&gt;éåŽ†å›¾åƒbitmapå–æ»¡è¶³æ¡ä»¶çš„ç‚¹ï¼Œæ¡ä»¶ç®€å•çš„ç†è§£å°±æ˜¯ç‚¹å‘¨å›´3x3èŒƒå›´çš„ç‚¹åƒç´ å€¼å–å¹³å‡å€¼ã€‚ä¸ºä»€ä¹ˆè¦æ£€æµ‹è¾¹ç¼˜ï¼Œæ˜¯å› ä¸ºè¦åšè™šçº¿æè¾¹ï¼ŒèŽ·å–è¿žç»­çš„è¾¹ç¼˜ç‚¹ä¹‹åŽç„¶åŽåœ¨ç”»å¸ƒä¸Šè¿žæŽ¥ç‚¹ç”»å‡ºæ¥ã€‚ ä»£ç å¤§æ¦‚æ˜¯è¿™æ ·çš„â€¦ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647+ (NSArray *)imageFindContours:(UIImage *)image &#123; NSMutableArray *points = [[NSMutableArray array] init]; UIImage *newImage = [image mediumResolution:CGSizeMake(30, 30)]; CFDataRef imageData = CGDataProviderCopyData(CGImageGetDataProvider(newImage.CGImage)); const uint8_t *data = CFDataGetBytePtr(imageData); int w = newImage.size.width; int h = newImage.size.height; unsigned char *bitmap = malloc(w * h * 4); memcpy(bitmap, data, w * h * 4); CGFloat leftmost = 1; CGFloat rightmost = 0; for (int i = 1; i &lt; h - 1; i += 2) &#123; for (int j = 1; j &lt; w - 1; j += 2) &#123; unsigned int left = [WDImageBorder valueForBitmap:data stride:w position:CGPointMake(i, j) offsets:CGSizeMake(-1, 0)]; unsigned int right = [WDImageBorder valueForBitmap:data stride:w position:CGPointMake(i, j) offsets:CGSizeMake(1, 0)]; unsigned int up = [WDImageBorder valueForBitmap:data stride:w position:CGPointMake(i, j) offsets:CGSizeMake(0, -1)]; unsigned int down = [WDImageBorder valueForBitmap:data stride:w position:CGPointMake(i, j) offsets:CGSizeMake(0, 1)]; unsigned int leftUp = [WDImageBorder valueForBitmap:data stride:w position:CGPointMake(i, j) offsets:CGSizeMake(-1, -1)]; unsigned int rightUp = [WDImageBorder valueForBitmap:data stride:w position:CGPointMake(i, j) offsets:CGSizeMake(1, -1)]; unsigned int leftDown = [WDImageBorder valueForBitmap:data stride:w position:CGPointMake(i, j) offsets:CGSizeMake(-1, 1)]; unsigned int rightDown = [WDImageBorder valueForBitmap:data stride:w position:CGPointMake(i, j) offsets:CGSizeMake(1, 1)]; unsigned int center = [WDImageBorder valueForBitmap:data stride:w position:CGPointMake(i, j) offsets:CGSizeMake(0, 0)]; unsigned int avg = (left + right + up + down + leftUp + rightUp + leftDown + rightDown + center) / 9; int offset = i * w + j; if ((avg &gt;= (255. * 0.4) &amp;&amp; avg &lt;= (255. * 0.9)) &amp;&amp; center &gt; 65) &#123; bitmap[offset * 4] = 255; bitmap[offset * 4 + 1] = 0; bitmap[offset * 4 + 2] = 0; bitmap[offset * 4 + 3] = 255; CGFloat scale = 1.15; CGFloat x = (CGFloat)((((float) j / w) - 0.5) * scale + 0.5); CGFloat y = (CGFloat)((((float) i / h) - 0.5) * scale + 0.5); CGPoint point = CGPointMake(x, y); [points addObject:[NSValue valueWithCGPoint:point]]; if (x &lt;= leftmost) leftmost = x; if (x &gt;= rightmost) rightmost = x; &#125; &#125; &#125; ...&#125; è¿™ä¸ªæœ‰ä¸ªè‡´å‘½çš„é—®é¢˜ï¼Œå°±æ˜¯æ‰¾åˆ°ç‚¹ä¹‹åŽï¼Œä½†æ˜¯æ²¡åŠžæ³•æœ‰åºçš„è¿žèµ·æ¥ï¼Œä¹Ÿè¯•è¿‡ä¸€äº›æ–¹æ¡ˆï¼Œä½†æ˜¯å›¾åƒçš„è¾¹ç¼˜æƒ…å†µå¤ªå¤æ‚äº†ï¼Œæ€»æ˜¯æœ‰é—®é¢˜ï¼Œè¿™é‡Œå°±ä¸å¤šè¯´äº†ã€‚ æŽ¥ä¸‹æ¥å°±éœ€æ±‚å…¶ä»–çš„æ–¹æ¡ˆï¼Œå¤§åé¼Žé¼Žçš„OpenCVå‡ºåœºäº†ï¼Œå‚è€ƒå®˜æ–¹æ–‡æ¡£ï¼Œç¼–è¯‘äº§ç‰©ï¼ŒæŽ¥å…¥app è°ƒè¯•ä¸‹æ¥å°±èƒ½èŽ·å–æ­£ç¡®çš„ç»“æžœäº†ï¼Œè¿™é‡Œå°±ä¸å¤šè¯´äº†ï¼Œç›´æŽ¥çœ‹ä¸‹ä»£ç ï¼Œå¯¹åº”çš„èŠ‚ç‚¹æœ‰æ³¨é‡Šè¯´æ˜Ž 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859+ (NSArray *)findContours:(UIImage *)image &#123; Mat src; Mat src_gray; src = [self cvMatFromUIImage:image]; cvtColor(src, src_gray, COLOR_BGR2GRAY); //UIImage *grayImg = [self UIImageFromCVMat:src_gray]; blur(src_gray, src_gray, cv::Size(3, 3)); //UIImage *blurgrayImg = [self UIImageFromCVMat:src_gray]; /// åˆ©ç”¨é˜ˆå€¼äºŒå€¼åŒ– threshold(src_gray,src_gray,128,255,cv::THRESH_BINARY); /// ç”¨Cannyç®—å­æ£€æµ‹è¾¹ç¼˜ //Canny(src_gray, src_gray, 128, 255 , 3); //UIImage *canny_outputImg = [self UIImageFromCVMat:src_gray]; vector&lt;vector&lt;cv::Point&gt; &gt; contours; vector&lt;Vec4i&gt; hierarchy; /// å¯»æ‰¾è½®å»“ findContours(src_gray, contours, hierarchy, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE, cv::Point(0, 0)); /// ç»˜å‡ºè½®å»“ Mat drawing = Mat::zeros(src_gray.size(), CV_8UC3); for (int i = 0; i &lt; contours.size(); i++) &#123; Scalar color = Scalar(255, 255, 255); drawContours(drawing, contours, i, color, 1, 8, hierarchy, 0, cv::Point()); &#125; //UIImage *contoursImg = [self UIImageFromCVMat:drawing]; NSMutableArray *array = [NSMutableArray arrayWithCapacity:contours.size()]; for (int i = 0; i &lt; contours.size(); i++) &#123; if (hierarchy[i][3] &gt;= 0 || hierarchy[i][2] &gt;= 0) &#123; continue; &#125; vector&lt;cv::Point&gt; vect = contours[i]; std::vector&lt;cv::Point&gt;::const_iterator it; // declare a read-only iterator it = vect.cbegin(); // assign it to the start of the vector while (it != vect.cend()) &#123; // while it hasn't reach the end //std::cout &lt;&lt; it-&gt;x &lt;&lt;' '&lt;&lt; it-&gt;y &lt;&lt;' '; // print the value of the element it points to [array addObject:@(CGPointMake(it-&gt;x / image.size.width, it-&gt;y / image.size.height))]; ++it; // and iterate to the next element &#125; &#125; return @[array];&#125; è¿™ä¸ªæ–¹æ¡ˆå”¯ä¸€çš„ç¼ºé™·å°±æ˜¯éœ€è¦å¼•å…¥OpenCVé™æ€åº“ï¼Œå¢žåŠ åŒ…å¤§å°ï¼Œä¹Ÿæƒ³è¿‡å’±åªç”¨åˆ°äº†è¾¹ç¼˜æ£€æµ‹ï¼Œå…¶ä»–çš„ç‰›é€¼åŠŸèƒ½æš‚æ—¶ä¹Ÿç”¨ä¸åˆ°ï¼Œè£å‰ªä¸‹åªä¿ç•™éœ€è¦çš„ç±»æ˜¯ä¸æ˜¯å°±å¯ä»¥ï¼Œä½†æ˜¯å¤§è‡´ç¿»äº†ä¸‹ï¼Œç‰µæ‰¯çš„å¤ªå¤šï¼Œæœ€ç»ˆæ”¾å¼ƒäº†, æœ€åŽä¹Ÿå¹¶æ²¡æœ‰ä½¿ç”¨OpenCVçš„æ–¹æ¡ˆã€‚ å› ä¸ºå‘çŽ°äº†æ›´è½»é‡çº§çš„æ–¹æ¡ˆï¼ŒSuzukiè¾¹ç¼˜æ£€æµ‹ç®—æ³•ï¼ŒåŽé¢ä¹Ÿäº†è§£è¯¥ç®—æ³•å…¶å®žå°±æ˜¯OpenCVå†…éƒ¨çš„ä¸€ç§è¾¹ç¼˜æ£€æµ‹æ–¹æ¡ˆã€‚ æ°å¥½AndroidåŒå­¦æ‰¾åˆ°äº†ä¸€ä¸ªå¼€æºåº“ï¼Œjavaç‰ˆæœ¬çš„Suzukiè¾¹ç¼˜æ£€æµ‹ç®—æ³•ã€‚ä»£ç æ‹‰ä¸‹æ¥ç»“åˆç®—æ³•æ–‡æ¡£æ¥å›žæ’¸å‡ éï¼Œå¤§è‡´èƒ½ç†è§£äº†ï¼Œandroidç›´æŽ¥javaæ‹–è¿›åŽ»ç”¨ä¸Šï¼Œiosç¿»è¯‘æˆOCï¼Œä¹Ÿä¸å¤æ‚ï¼Œå› ä¸ºç®—æ³•æ ¸å¿ƒæ–¹æ³•ä¹Ÿä¸è¿‡å‡ åè¡Œä»£ç ï¼Œå°±ç®—ä¸ç†è§£ï¼Œç¡¬ç¿»ä¹Ÿèƒ½ç¿»è¯‘è¿‡æ¥ã€‚ è´´ä¸€ä¸‹ç¿»è¯‘æˆOCçš„ä»£ç ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212+ (NSArray *)findContours:(UIImage *)img threshold:(CGFloat)threshold &#123; img = [self blurImage:img blur:0.2]; /// è®°å½•åŽŸå›¾å°ºå¯¸ int ow = (int) img.size.width; int w = ow; int h = (int) img.size.height; /// è€ƒè™‘å­—èŠ‚å¯¹é½ w è¦é‡æ–°è®¡ç®— CFDataRef imageData = CGDataProviderCopyData(CGImageGetDataProvider(img.CGImage)); const uint8_t *data = CFDataGetBytePtr(imageData); w = (int) CFDataGetLength(imageData) / (h*4); char *F = malloc((size_t) CFDataGetLength(imageData)/4); /// äºŒå€¼åŒ–å¤„ç† threshold *= 255.f; for (int i = 0; i &lt; h; i++) &#123; for (int j = 0; j &lt; w; j++) &#123; if (data[(i * w + j) * 4] &gt; threshold) &#123; F[i * w + j] = 1; &#125; else &#123; F[i * w + j] = 0; &#125; &#125; &#125; NSMutableArray&lt;Contour *&gt; *contours = [NSMutableArray array]; for (int i = 1; i &lt; h - 1; i++) &#123; F[i * w] = 0; F[i * w + w - 1] = 0; &#125; for (int i = 0; i &lt; w; i++) &#123; F[i] = 0; F[w * h - 1 - i] = 0; &#125; int nbd = 1; int lnbd = 1; for (int i = 1; i &lt; h - 1; i++) &#123; lnbd = 1; for (int j = 1; j &lt; w - 1; j++) &#123; int i2 = 0, j2 = 0; if (F[i * w + j] == 0) &#123; continue; &#125; //(a) If fij = 1 and fi, j-1 = 0, then decide that the pixel //(i, j) is the border following starting point of an outer //border, increment NBD, and (i2, j2) &lt;- (i, j - 1). if (F[i * w + j] == 1 &amp;&amp; F[i * w + (j - 1)] == 0) &#123; nbd++; i2 = i; j2 = j - 1; //(b) Else if fij &gt;= 1 and fi,j+1 = 0, then decide that the //pixel (i, j) is the border following starting point of a //hole border, increment NBD, (i2, j2) &lt;- (i, j + 1), and //LNBD + fij in case fij &gt; 1. &#125; else if (F[i * w + j] &gt;= 1 &amp;&amp; F[i * w + j + 1] == 0) &#123; nbd++; i2 = i; j2 = j + 1; if (F[i * w + j] &gt; 1) &#123; lnbd = F[i * w + j]; &#125; &#125; else &#123; //(c) Otherwise, go to (4). //(4) If fij != 1, then LNBD &lt;- |fij| and resume the raster //scan from pixel (i,j+1). The algorithm terminates when the //scan reaches the lower right corner of the picture if (F[i * w + j] != 1) &#123; lnbd = ABS(F[i * w + j]); &#125; continue; &#125; //(2) Depending on the types of the newly found border //and the border with the sequential number LNBD //(i.e., the last border met on the current row), //decide the parent of the current border as shown in Table 1. // TABLE 1 // Decision Rule for the Parent Border of the Newly Found Border B // ---------------------------------------------------------------- // Type of border B' // \ with the sequential // \ number LNBD // Type of B \ Outer border Hole border // --------------------------------------------------------------- // Outer border The parent border The border B' // of the border B' // // Hole border The border B' The parent border // of the border B' // ---------------------------------------------------------------- Contour *B = [Contour new]; B.points = [NSMutableArray array]; [B.points addObject:[NSValue valueWithCGPoint:CGPointMake(j * 1.f / ow, i * 1.f / h)]]; B.isHole = (j2 == (j + 1)); B.idx = nbd; [contours addObject:B]; Contour *B0 = [Contour new]; for (int c = 0; c &lt; contours.count; c++) &#123; if (contours[c].idx == lnbd) &#123; B0 = contours[c]; break; &#125; &#125; if (B0.isHole) &#123; if (B.isHole) &#123; B.parentIdx = B0.parentIdx; &#125; else &#123; B.parentIdx = lnbd; &#125; &#125; else &#123; if (B.isHole) &#123; B.parentIdx = lnbd; &#125; else &#123; B.parentIdx = B0.parentIdx; &#125; &#125; //(3) From the starting point (i, j), follow the detected border: //this is done by the following substeps (3.1) through (3.5). //(3.1) Starting from (i2, j2), look around clockwise the pixels //in the neigh- borhood of (i, j) and tind a nonzero pixel. //Let (i1, j1) be the first found nonzero pixel. If no nonzero //pixel is found, assign -NBD to fij and go to (4). int i1j1[2] = &#123;-1, -1&#125;; cwNon0(F, w, h, i, j, i2, j2, 0, i1j1); if (i1j1[0] == -1 &amp;&amp; i1j1[1] == -1) &#123; F[i * w + j] = -nbd; //go to (4) if (F[i * w + j] != 1) &#123; lnbd = ABS(F[i * w + j]); &#125; continue; &#125; int i1 = i1j1[0]; int j1 = i1j1[1]; // (3.2) (i2, j2) &lt;- (i1, j1) ad (i3,j3) &lt;- (i, j). i2 = i1; j2 = j1; int i3 = i; int j3 = j; while (true) &#123; //(3.3) Starting from the next elementof the pixel (i2, j2) //in the counterclock- wise order, examine counterclockwise //the pixels in the neighborhood of the current pixel (i3, j3) //to find a nonzero pixel and let the first one be (i4, j4). int i4j4[2] = &#123;-1, -1&#125;; ccwNon0(F, w, h, i3, j3, i2, j2, 1, i4j4); int i4 = i4j4[0]; int j4 = i4j4[1]; [contours[contours.count - 1].points addObject:[NSValue valueWithCGPoint:CGPointMake(j4 * 1.f / ow, i4 * 1.f / h)]]; //(a) If the pixel (i3, j3 + 1) is a O-pixel examined in the //substep (3.3) then fi3, j3 &lt;- -NBD. if (F[i3 * w + j3 + 1] == 0) &#123; F[i3 * w + j3] = (char) -nbd; //(b) If the pixel (i3, j3 + 1) is not a O-pixel examined //in the substep (3.3) and fi3,j3 = 1, then fi3,j3 &lt;- NBD. &#125; else if (F[i3 * w + j3] == 1) &#123; F[i3 * w + j3] = (char) nbd; &#125; else &#123; //(c) Otherwise, do not change fi3, j3. &#125; //(3.5) If (i4, j4) = (i, j) and (i3, j3) = (i1, j1) //(coming back to the starting point), then go to (4); if (i4 == i &amp;&amp; j4 == j &amp;&amp; i3 == i1 &amp;&amp; j3 == j1) &#123; if (F[i * w + j] != 1) &#123; lnbd = ABS(F[i * w + j]); &#125; break; //otherwise, (i2, j2) + (i3, j3),(i3, j3) + (i4, j4), //and go back to (3.3). &#125; else &#123; i2 = i3; j2 = j3; i3 = i4; j3 = j4; &#125; &#125; &#125; &#125; free(F); ...&#125; SDFä¸Šé¢æåˆ°è¾¹ç¼˜æ£€æµ‹æ‰¾è¿žç»­çš„è¾¹ç¼˜ç‚¹åªæ˜¯ä¸ºäº†è§£å†³è™šçº¿æè¾¹ï¼Œå…¶ä»–çš„æè¾¹æƒ…å†µå…¶å®žæ˜¯ç”¨ä¸åˆ°è¿™äº›ç‚¹çš„ï¼Œä½†æ˜¯è¿™é‡Œä¹Ÿé‡åˆ°é—®é¢˜äº†ã€‚ ä¸€å¼€å§‹çš„æƒ³æ³•è·Ÿä¸Šé¢é€šè¿‡3x3èŒƒå›´å–å¹³å‡å€¼ï¼Œé€šè¿‡æ¡ä»¶è¿‡æ»¤æ¥åšçš„ï¼Œkernel codeå¤§æ¦‚æ˜¯è¿™æ · 12345678910111213141516171819static NSString *KernelString = @&quot;\kernel vec4 borderDraw(sampler image, sampler mask, sampler source, vec4 rgba, float midpoint, float width) \&#123;\ vec2 uv = destCoord();\ vec4 color = sample(image, samplerTransform(image, uv));\ vec4 sumColor = vec4(0.0);\ float radiu = 2 * width;\ for (float m = -radiu; m &lt;= radiu; m += 2) &#123;\ for (float n = -radiu; n &lt;= radiu; n += 2) &#123;\ vec4 rgba = sample(image, samplerTransform(image, vec2(uv.x + m, uv.y + n)));\ sumColor += rgba;\ &#125;\ &#125;\ float avg = sumColor.a / float(radiu * radiu / 2.0);\ if (color.a &lt; 1.0 &amp;&amp; (avg &gt; .05 &amp;&amp; avg &lt; 1.)) &#123;\ return rgba;\ &#125;\ return color;\&#125;&quot;; è¿™å¥—æ–¹æ¡ˆåšdemoçš„æ—¶å€™ï¼Œæ„Ÿè§‰æ•ˆæžœè¿˜è¡Œï¼Œä¸€ç‚¹ç‚¹æ¯›ç–µï¼Œä»¥ä¸ºæ˜¯æ¡ä»¶åˆ¤æ–­ä¸ä¸¥è°¨ï¼Œä»¥ä¸ºåŽç»­è°ƒæ•´ä¸‹å¯ä»¥è§£å†³ï¼Œè¿˜æœ‰ä¸ªä¸¥é‡çš„é—®é¢˜ï¼Œå°±æ˜¯è¿™ä¸ªæ–¹æ¡ˆè®¡ç®—é‡å¤ªå¤§ï¼Œå›¾ç‰‡åˆ†è¾¨çŽ‡1080å·¦å³ï¼Œè¡¨çŽ°å°±æœ‰ç‚¹å¡ï¼Œå°¤å…¶æ˜¯æ‹–åŠ¨æ»‘ç«¿è°ƒæ•´ï¼Œæè¾¹ç²—ç»† ã€é—´è· ï¼Œå®žæ—¶æ¸²æŸ“æœ‰æ˜Žæ˜¾çš„å¡é¡¿ï¼Œä½†æ˜¯æˆ‘ä»¬åˆä¸èƒ½é™ä½Žå›¾ç‰‡è´¨é‡ï¼Œæ‰€ä»¥è¿™ä¸ªæ–¹æ¡ˆæœ€ç»ˆä¹Ÿå°±æ˜¯åœç•™åœ¨demoé˜¶æ®µäº†ã€‚ å› ä¸ºè®¡ç®—é‡å¤ªå¤§ï¼Œæ‰€ä»¥æƒ³åŠžæ³•é™ä½Žåƒç´ è®¡ç®—é‡ï¼ŒSDFå‡ºåœºäº†ï¼Œé€šè¿‡è·ç¦»åœºï¼Œå¯ä»¥ç”Ÿæˆä¸€å¼ å›¾ï¼Œè¿™å¼ å›¾å¯ä»¥å‘ŠçŸ¥åƒç´ è¾¹ç•Œä¿¡æ¯ï¼Œç›´æŽ¥é€šè¿‡è¾¹ç•Œä¿¡æ¯ï¼ŒçœåŽ»äº†æžå¤§çš„è®¡ç®—é‡ã€‚ SDF ï¼šsigned distance filed æœ‰å‘è·ç¦»åœºsdfæœ‰ä¸¤ç§æ–¹å¼ï¼Œä¸€ç§æ˜¯å¾ªçŽ¯ï¼ˆæ¨ªå‘xçºµå‘ï¼‰ ä¸€ç§æ˜¯åŒçº¿æ€§ï¼ˆæ¨ªå‘+çºµå‘ï¼‰ï¼Œå¾ˆæ˜Žæ˜¾å‰ä¸€ç§è®¡ç®—é‡è¿œè¿œå¤§äºŽåŽä¸€ç§ï¼Œè”è°ƒä¸‹æ¥ç¬¬äºŒç§æ–¹æ¡ˆå®žé™…æ•ˆæžœä¹Ÿæ˜¯ç›¸å½“ä¸é”™äº†ã€‚ è¿™é‡Œè¿˜è¦è€ƒè™‘ä¸€ä¸ªé—®é¢˜ï¼Œå› ä¸ºæè¾¹æ˜¯æœ‰ç²—ç»†è·Ÿé—´è·çš„ï¼Œæ‰€ä»¥å¯ä»¥é€šè¿‡è°ƒæ•´è·ç¦»å‚æ•°ç”Ÿæˆå›¾ï¼Œå¾ˆå¥½çš„è§£å†³äº†æè¾¹ç²—ç»†è·Ÿé—´è·é—®é¢˜çš„ï¼ŒSDFæ–¹æ¡ˆåœ¨è™šçº¿æè¾¹çš„caseä¹Ÿæ˜¯æœ‰ç”¨çš„ï¼Œé€šè¿‡æŠŠSDFç”Ÿæˆå›¾æ‹¿åŽ»åšè¾¹ç¼˜æ£€æµ‹æ‰¾è¿žç»­ç‚¹ã€‚ æ¥çœ‹ä¸‹SDFç”Ÿæˆå›¾çš„æ•ˆæžœ æŠ å›¾æ¨ªå‘SDFç»“æžœæŽ¥çºµå‘SDFç»“æžœ è´´ä¸€ä¸‹Metalç‰ˆæœ¬çš„SDFè®¡ç®—é€»è¾‘ æ¨ªå‘SDF 12345678910111213141516171819202122232425262728293031323334353637383940extern "C" &#123; namespace coreimage &#123; constant float threshold = 0.5; float source(sampler image,float2 uv) &#123; return image.sample(image.transform(uv)).a - threshold; &#125; float4 sdfhor(sampler image,float width,destination dest) &#123; float D2 = width * 2.0 + 1.0; // èŽ·å–å½“å‰ç‚¹åæ ‡ float2 uv = dest.coord(); float s = sign(source(image,uv)); float d = 0.; for(int i= 0; i &lt; width; i++) &#123; d ++; float sp = sign(source(image,float2(uv.x + d, uv.y))); if(s * sp &lt; 0.) &#123; break; &#125; sp = sign(source(image,float2(uv.x - d, uv.y))); if(s * sp &lt; 0.) &#123; break; &#125; &#125; float sd = -s * d / D2 ; return float4(float3(sd),1.0); &#125; &#125;&#125; çºµå‘SDF 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758extern "C" &#123; namespace coreimage &#123; float sd(sampler image,float2 uv,float width) &#123; float D2 = float(width * 2 + 1); float x = image.sample(image.transform(uv)).x; return x * D2; &#125; float4 sdf(sampler image,float width,destination dest) &#123; // èŽ·å–å½“å‰ç‚¹åæ ‡ float2 uv = dest.coord(); float dx = sd(image,uv,width); float dMin = abs(dx); float dy = 0.0; for(int i= 0; i &lt; width; i++)&#123; dy += 1.0; float2 offset = float2(0.0, dy); float dx1 = sd(image,uv+offset,width); //sign switch if(dx1 * dx &lt; 0.)&#123; dMin = dy; break; &#125; dMin = min(dMin, length (float2(dx1, dy))); float dx2 = sd(image,uv-offset,width); //sign switch if(dx2 * dx &lt; 0.)&#123; dMin = dy; break; &#125; dMin = min(dMin, length (float2(dx2, dy))); if(dy &gt; dMin)break; &#125; float D2 = float(width * 2 + 1); dMin *= sign(dx); float d = dMin/D2; d = 1.0 - d; d = smoothstep(0.5 ,1.0, d); return float4(float3(d),1.0); &#125; &#125;&#125; borderæœ‰äº†è·ç¦»åœºï¼Œæè¾¹çš„å·¥ä½œå°±ä¸€ä¸‹å­ç®€å•å¤šäº†ã€‚ ç›®å‰å®žçŽ°çš„äº”ç§æè¾¹æ•ˆæžœå°±æ˜¯è¿™æ ·å¼çš„ é¡¹ç›®ä¸­ä½¿ç”¨coreimageè‡ªå®šä¹‰kernelåšçš„ï¼Œå½“ç„¶ä¹Ÿå¯ä»¥metalæžå®š sdfsourceKernelString å¯¹åº”ä¸Šé¢ç¬¬ä¸‰ä¸ªæ•ˆæžœ 12345678910111213141516171819202122232425262728293031static NSString *sdfsourceKernelString = @"\kernel vec4 borderDraw(sampler image, sampler sdf, sampler source, float d1, float d2) \&#123;\ vec2 uv = destCoord();\ vec4 color = sample(image, samplerTransform(image, uv));\ vec4 sdfcolor = sample(sdf, samplerTransform(sdf, uv));\ vec4 sourcecolor = sample(source, samplerTransform(source, uv));\ if (sdfcolor.x &gt;= d1 &amp;&amp; sdfcolor.x &lt;= d2) &#123;\ return sourcecolor;\ &#125;\ return color;\&#125;";static NSString *sdfKernelString = @"\kernel vec4 borderDraw(sampler image, sampler sdf, sampler source, vec4 rgba, vec2 offset, float d1, float d2) \&#123;\ vec2 uv = destCoord();\ vec4 color = sample(image, samplerTransform(image, uv));\ vec4 offsetColor = sample(image, samplerTransform(image, uv-offset));\ vec4 sdfcolor = sample(sdf, samplerTransform(sdf, uv));\ vec4 sourcecolor = sample(source, samplerTransform(source, uv));\ if(offset.x != 0.0 || offset.y != 0.0) &#123;\ if(color.a &lt; 0.5 &amp;&amp; offsetColor.a &gt; 0.5 ) &#123;\ return mix(rgba,color,color.a);\ &#125;\ &#125; else if (sdfcolor.x &gt;= d1 &amp;&amp; sdfcolor.x &lt;= d2) &#123;\ return mix(rgba,sourcecolor,offsetColor.a);\ &#125;\ return color;\&#125;"; æœ€åŽä¸€ä¸ªè™šçº¿æè¾¹å°±æ˜¯å¸¸è§„çš„è¿žæŽ¥è¾¹ç¼˜ç‚¹å®‰æŽ’ç”»å¸ƒç»˜åˆ¶ï¼Œç„¶åŽè·ŸæŠ å›¾åšä¸€ä¸ªåˆå¹¶å¯¼å‡ºï¼Œå°±ä¸å±•å¼€è¯´äº†ã€‚ Othteræœ€åŽè¿˜æœ‰ä¸€äº›æ³¨æ„ç‚¹ï¼Œæ¯”å¦‚æŠ å›¾å›¾åƒæ˜¯åœ¨è¾¹ç¼˜ï¼Œåˆ™éœ€è¦è€ƒè™‘ä¸‹é¢„ç•™æè¾¹ç©ºé—´ï¼Œåˆ¤æ–­æ˜¯å¦æœ‰è½åœ¨è¾¹ç¼˜ï¼Œå¦‚æžœæœ‰åˆ™è¡¥å……ç‚¹ç©ºé—´ã€‚è¿˜æœ‰ä¸€ä¸ªå°±æ˜¯æœ€å°åŒ…å›´ç›’ï¼ŒæŠ å›¾å¾ˆå¯èƒ½åªå æ®åŽŸå›¾çš„ä¸€éƒ¨åˆ†é¢„æœŸï¼Œä¸ºäº†å±•ç¤ºæ•ˆæžœï¼Œéœ€è¦æŠŠæŠ å›¾çš„æœ€å°åŒ…å›´ç›’æ‰¾åˆ°ï¼Œæ‰¾è¿™ä¸ªæœ€å°åŒ…å›´ç›’ï¼Œä¸éœ€è¦é‚£ä¹ˆç²¾ç¡®ï¼Œæ‰¾å‡ºä¸€ä¸ªå·®ä¸å¤šçš„æœ€å°çŸ©å½¢æ¡†å°±è¡Œï¼Œé¡¹ç›®ä¸Šç”¨çš„å°±æ˜¯ç²—æš´çš„åƒç´ éåŽ†ï¼Œæ‰¾å››ä¸ªè§’çš„ä½ç½®å°±å¯ä»¥äº†ï¼Œé€šè¿‡æœ€å°åŒ…å›´ç›’ï¼Œä¹Ÿèƒ½åˆ¤æ–­æŠ å›¾æ˜¯å¦é è¿‘è¾¹ç¼˜ã€‚ The Lastç»¼ä¸Šï¼Œå…³é”®çš„å‡ ä¸ªæ­¥éª¤åŸºæœ¬éƒ½å°è¯•äº†å¤šç§æ–¹å¼ï¼Œåˆ†æžæ¯”è¾ƒå¾—å‡ºæœ€åˆé€‚é¡¹ç›®éœ€æ±‚çš„æŠ€æœ¯æ–¹æ¡ˆï¼Œ æœ€ç»ˆä»Žæ€§èƒ½ã€ä½“éªŒç­‰ç»´åº¦æ‹¿åˆ°ç›¸å¯¹ä¸é”™çš„ç»“æžœï¼Œå•çº¯ä»Žæè¾¹åŠŸèƒ½ä¸Šæ¥è¯´ï¼Œå¯¹æ¯”ä¿®å¤å·¥å…·ä¹Ÿä¸è¾“ O(âˆ©_âˆ©)Oå“ˆå“ˆ~ referencePContourSDFåŒçº¿æ€§SDF]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[camera orientation]]></title>
    <url>%2F2022%2F09%2F09%2Fcamera-orientation%2F</url>
    <content type="text"><![CDATA[cameraæ‰‹æœºç›¸æœºå½•è§†é¢‘æˆ–è€…æ‹ç…§ï¼Œéœ€è¦è€ƒè™‘è®¾å¤‡çš„æ–¹å‘ï¼Œä¸»è¦åœ¨ä¸¤æ–¹é¢ é‡‡é›†è¿‡ç¨‹ä¸­ï¼Œæ— è®ºæ‰‹æœºä»€ä¹ˆæ–¹å‘é‡‡é›†ï¼Œé‡‡é›†ç”»é¢éƒ½æ˜¯æ­£ç€çœ‹ï¼Œä¸ç”¨ä¾§å¤´ å½•åˆ¶/æˆ–è€…æ‹ç…§åŽï¼Œè§†é¢‘/å›¾ç‰‡åœ¨æ­£å¸¸æ‰‹æŒè®¾å¤‡çš„æƒ…å†µä¸‹æ­£å¸¸æ˜¾ç¤ºï¼Œä¸ç”¨æ¨ªç€æ‰‹æœº æ­£å¸¸æ‰‹æŒä¸€èˆ¬éƒ½æ˜¯ç«–ç€æ‹¿æ‰‹æœºï¼Œæ‰€ä»¥å°±ç®—æ¨ªç€æ‹æ‘„ï¼Œç«–ç€æ‹¿æ‰‹æœºä¹Ÿéœ€è¦æ­£å¸¸æ˜¾ç¤ºï¼Œä¸ç†è§£å¯ä»¥å‚è€ƒä¸‹ç³»ç»Ÿç›¸æœºã€‚ æ‰€ä»¥è¿™é‡Œå°±å­˜åœ¨ä¸€ä¸ªæ–¹å‘ä¿®æ­£çš„é—®é¢˜ã€‚ device orientationè‹¹æžœæ‰‹æœºï¼Œå¦‚æžœè®¾ç½®é‡Œé”å®šäº†æ–¹å‘ï¼Œæ˜¯æ²¡åŠžæ³•é€šè¿‡ [UIDevice currentDevice].orientationè¿™ä¸ªæ–¹æ³•æ‹¿åˆ°çš„ï¼ŒåŒæ ·UIDeviceOrientationDidChangeNotificationè¿™ä¸ªé€šçŸ¥ä¹ŸèŽ·å–ä¸åˆ°ã€‚åŒç† [[UIApplication sharedApplication] statusBarOrientation]; è·Ÿ **UIApplicationDidChangeStatusBarOrientationNotification** ä¹Ÿæ˜¯ä¸å¯ç”¨çš„ã€‚ å¯ä»¥é€šè¿‡ CMMotionManager ç›‘å¬è®¾å¤‡çš„æ–¹å‘ 12345678910111213141516171819202122232425262728293031323334_motionManager = [[CMMotionManager alloc] init];_motionManager.deviceMotionUpdateInterval = 1/15.0;if (!_motionManager.deviceMotionAvailable) &#123; _motionManager = nil; return self;&#125;OBJC_WEAK(self)[_motionManager startDeviceMotionUpdatesToQueue:[NSOperationQueue currentQueue] withHandler: ^(CMDeviceMotion*motion, NSError *error)&#123; [weak_self performSelectorOnMainThread:@selector(handleDeviceMotion:) withObject:motion waitUntilDone:YES];&#125;];- (void)handleDeviceMotion:(CMDeviceMotion *)deviceMotion &#123; double x = deviceMotion.gravity.x; double y = deviceMotion.gravity.y; if (fabs(y) &gt;= fabs(x)) &#123; if (y &gt;= 0) &#123; _deviceOrientation = UIDeviceOrientationPortraitUpsideDown; _videoOrientation = AVCaptureVideoOrientationPortraitUpsideDown; &#125; else &#123; _deviceOrientation = UIDeviceOrientationPortrait; _videoOrientation = AVCaptureVideoOrientationPortrait; &#125; &#125; else &#123; if (x &gt;= 0) &#123; _deviceOrientation = UIDeviceOrientationLandscapeRight; _videoOrientation = AVCaptureVideoOrientationLandscapeRight; &#125; else &#123; _deviceOrientation = UIDeviceOrientationLandscapeLeft; _videoOrientation = AVCaptureVideoOrientationLandscapeLeft; &#125; &#125;&#125; captureé¡¹ç›®ä¸­éœ€è¦æ”¯æŒè®¾ç½®æ»¤é•œã€ç‰¹æ•ˆç­‰ç­‰ï¼Œæ‰€ä»¥æ˜¾ç¤ºé‡‡é›†çš„å›¾åƒéœ€è¦è‡ªå·±æ¸²æŸ“ï¼Œé€šè¿‡å®˜æ–¹çš„AVCaptureSessioné…ç½®å¥½é‡‡é›†æµç¨‹ï¼Œä¸ç®¡æ˜¯ç«–ç€è¿˜æ˜¯æ¨ªç€é‡‡é›†ï¼ŒèŽ·å–åˆ°çš„pixelBufferéƒ½æ˜¯æ¨ªå‘çš„ï¼Œå› ä¸ºé»˜è®¤å°±æ˜¯homeé”®åœ¨å³è¾¹é‡‡é›†å›¾åƒï¼Œä½†æ˜¯æ˜¾ç¤ºçš„è§†å›¾ä¸€èˆ¬éƒ½æ˜¯ç«–å‘ï¼Œæ‰€ä»¥è¿™é‡Œè¦åšä¸€ä¸ª90Â°çš„æ—‹è½¬å¤„ç†,OPENGL å°±æ˜¯ä¸€ä¸ªæ—‹è½¬çŸ©é˜µã€‚ 123456789101112void main()&#123; // z mat4 rotationMatrix = mat4(cos(angle) , sin(angle) , 0.0, 0.0, -sin(angle) , cos(angle) , 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0); vec4 outPosition = rotationMatrix * position; gl_Position = outPosition; textureCoordinate = inputTextureCoordinate.xy;&#125; å¦‚æžœåªæ˜¯è§£å†³é‡‡é›†ç”»é¢æ˜¾ç¤ºï¼Œä¹Ÿå¯ä»¥é€šè¿‡è®¾ç½®connection.videoOrientation = [self currentVideoOrientation]; æ¥è§£å†³é¡¹ç›®ä¸­æ²¡æœ‰ç”¨è¿™ä¸ªï¼Œå› ä¸ºåŽé¢è¿˜éœ€è¦å½•åˆ¶è§†é¢‘å¯¼å‡ºè§†é¢‘æ–‡ä»¶ã€‚ 12345678910111213141516171819202122// å½“å‰è®¾å¤‡å–å‘- (AVCaptureVideoOrientation)currentVideoOrientation&#123; AVCaptureVideoOrientation orientation; switch (self.motionManager.deviceOrientation) &#123; case UIDeviceOrientationPortrait: orientation = AVCaptureVideoOrientationPortrait; break; case UIDeviceOrientationLandscapeLeft: orientation = AVCaptureVideoOrientationLandscapeRight; break; case UIDeviceOrientationLandscapeRight: orientation = AVCaptureVideoOrientationLandscapeLeft; break; case UIDeviceOrientationPortraitUpsideDown: orientation = AVCaptureVideoOrientationPortraitUpsideDown; break; default: orientation = AVCaptureVideoOrientationPortrait; break; &#125; return orientation;&#125; Recordå½•åˆ¶è¿‡ç¨‹é€šè¿‡AVAssetWriterInput *writerInput = [AVAssetWriterInput assetWriterInputWithMediaType:obj outputSettings:options]; å’Œ[self.mPixelBufferAdaptor appendPixelBuffer:pixelBuffer withPresentationTime:ts] æ¥ç§¯ç´¯pixelBufferï¼Œ ä¸ºäº†ä¿éšœå¯¼å‡ºçš„è§†é¢‘å¯ä»¥æ­£å¸¸æ˜¾ç¤ºï¼Œéœ€è¦è®°å½•è§†é¢‘çš„æ–¹å‘ï¼Œé€šè¿‡è®¾ç½®writerInput.transform[ = self transformFromCurrentVideoOrientationToOrientation:AVCaptureVideoOrientationPortrait],ç³»ç»Ÿè‡ªåŠ¨å¸®æˆ‘ä»¬åšè½¬æ¢ 1234567891011121314151617181920212223242526272829303132// æ—‹è½¬è§†é¢‘æ–¹å‘å‡½æ•°å®žçŽ°- (CGAffineTransform)transformFromCurrentVideoOrientationToOrientation:(AVCaptureVideoOrientation)orientation &#123; CGFloat orientationAngleOffset = [self angleOffsetFromPortraitOrientationToOrientation:orientation]; CGFloat videoOrientationAngleOffset = [self angleOffsetFromPortraitOrientationToOrientation:self.currentOrientation]; CGFloat angleOffset; if (self.position == AVCaptureDevicePositionBack) &#123; angleOffset = videoOrientationAngleOffset - orientationAngleOffset + M_PI_2; &#125; else &#123; angleOffset = orientationAngleOffset - videoOrientationAngleOffset + M_PI_2; &#125; CGAffineTransform transform = CGAffineTransformMakeRotation(angleOffset); return transform;&#125;- (CGFloat)angleOffsetFromPortraitOrientationToOrientation:(AVCaptureVideoOrientation)orientation &#123; CGFloat angle = 0.0; switch (orientation) &#123; case AVCaptureVideoOrientationPortrait: angle = 0.0; break; case AVCaptureVideoOrientationPortraitUpsideDown: angle = M_PI; break; case AVCaptureVideoOrientationLandscapeRight: angle = -M_PI_2; break; case AVCaptureVideoOrientationLandscapeLeft: angle = M_PI_2; break; &#125; return angle;&#125; ä¸»è¦å°±æ˜¯é€šè¿‡å½•åˆ¶è§†é¢‘æ—¶å€™çš„è®¾å¤‡æ–¹å‘è·Ÿæ˜¾ç¤ºæ–¹å‘è®¡ç®—ä¸€ä¸‹transform Picæ‹ç…§ç”Ÿæˆå›¾ç‰‡æ˜¯åŒæ ·çš„é“ç†ï¼Œç›´æŽ¥ç»™å‡ºæ–¹æ³•ï¼Œä¸»è¦å°±æ˜¯å›¾ç‰‡æ–¹å‘çš„æ—‹è½¬ 123456789101112131415161718- (UIImageOrientation)getImageRotationOrientationFromCaptureVideoOrientation:(AVCaptureVideoOrientation)orientation &#123; UIImageOrientation imageOrientation; switch (orientation) &#123; case AVCaptureVideoOrientationPortrait: imageOrientation = UIImageOrientationRight; break; case AVCaptureVideoOrientationPortraitUpsideDown: imageOrientation = UIImageOrientationLeft; break; case AVCaptureVideoOrientationLandscapeRight: imageOrientation = UIImageOrientationUp; break; case AVCaptureVideoOrientationLandscapeLeft: imageOrientation = UIImageOrientationDown; break; &#125; return imageOrientation;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455+ (UIImage *)image:(UIImage *)image rotation:(UIImageOrientation)orientation &#123; long double rotate = 0.0; CGRect rect; float translateX = 0; float translateY = 0; float scaleX = 1.0; float scaleY = 1.0; switch (orientation) &#123; case UIImageOrientationLeft: rotate = M_PI_2; rect = CGRectMake(0, 0, image.size.height, image.size.width); translateX = 0; translateY = -rect.size.width; scaleY = rect.size.width/rect.size.height; scaleX = rect.size.height/rect.size.width; break; case UIImageOrientationRight: rotate = -M_PI_2; rect = CGRectMake(0, 0, image.size.height, image.size.width); translateX = -rect.size.height; translateY = 0; scaleY = rect.size.width/rect.size.height; scaleX = rect.size.height/rect.size.width; break; case UIImageOrientationDown: rotate = M_PI; rect = CGRectMake(0, 0, image.size.width, image.size.height); translateX = -rect.size.width; translateY = -rect.size.height; break; default: rotate = 0.0; rect = CGRectMake(0, 0, image.size.width, image.size.height); translateX = 0; translateY = 0; break; &#125; UIGraphicsBeginImageContext(rect.size); CGContextRef context = UIGraphicsGetCurrentContext(); //åšCTMå˜æ¢ CGContextTranslateCTM(context, 0.0, rect.size.height); CGContextScaleCTM(context, 1.0, -1.0); CGContextRotateCTM(context, rotate); CGContextTranslateCTM(context, translateX, translateY); CGContextScaleCTM(context, scaleX, scaleY); //ç»˜åˆ¶å›¾ç‰‡ CGContextDrawImage(context, CGRectMake(0, 0, rect.size.width, rect.size.height), image.CGImage); UIImage *newPic = UIGraphicsGetImageFromCurrentImageContext(); return newPic;&#125;]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>camera</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[__has_include]]></title>
    <url>%2F2022%2F09%2F06%2Fhas-include%2F</url>
    <content type="text"><![CDATA[VSåœ¨æžéŸ³è§†é¢‘çš„è¿‡ç¨‹ä¸­ï¼Œæ—©æœŸä¸ºäº†å¿«é€Ÿå®žçŽ°åŠŸèƒ½ï¼Œä¼šç”¨åˆ°ä¸€äº›å¼€æºåº“ï¼Œæ¯”å¦‚FFMpegã€OpenCVã€LibYUV ç­‰ï¼Œè¿™äº›å¤§åé¼Žé¼Žçš„å¼€æºåº“èƒ½å¤Ÿè§£å†³éŸ³è§†é¢‘é¢†åŸŸçš„å¾ˆå¤šé—®é¢˜ï¼Œç¼–è§£ç ã€è¾¹ç¼˜æ£€æµ‹ã€RGB-YUVæ ¼å¼è½¬æ¢ç­‰ç­‰ã€‚ è¿™å‡ ä¸ªå¼€æºåº“è¿˜éƒ½æ˜¯C/C++çš„ï¼Œå®Œç¾Žè§£å†³è·¨å¹³å°çš„é—®é¢˜ï¼Œæ‰€ä»¥æ—©æœŸå¯ä»¥å¿«é€Ÿä¸Šçº¿ï¼Œä½†ä¹Ÿä¼šå¸¦æ¥å¢žåŠ åŒ…å¤§å°çš„é—®é¢˜ï¼Œè¿™æ˜¯æœ€æ˜Žæ˜¾çš„ï¼Œå¦å¤–å¼€æºæ–¹æ¡ˆä¹Ÿå¹¶éžæ²¡æœ‰BUGã€‚å¯¹å¼€æºåº“åšè£å‰ªå‡å°‘å¤§å°/æissueç­‰å¾…å®˜æ–¹å¤„ç†ã€è‡ªå·±å¤„ç†BUGç­‰è¿™äº›æˆæœ¬ç›¸å¯¹ä¹Ÿä¸å°ã€‚ å¦ä¸€ä¸ªé€‰æ‹©å°±æ˜¯ä½¿ç”¨å…¶ä»–çš„æ›¿ä»£æ–¹æ¡ˆï¼šæ¯”å¦‚åŽŸç”Ÿçš„æŠ€æœ¯å®žçŽ°ã€è§£å†³æŒ‡å®šé—®é¢˜ç‹¬ç«‹æ¨¡å—ç®—æ³•ã€DIY \ ç¼–è§£ç  è¾¹ç¼˜æ£€æµ‹ æ ¼å¼è½¬æ¢ å¼€æºæ–¹æ¡ˆ FFmpeg OpenCV LibYUV æ›¿ä»£æ–¹æ¡ˆ VideoToolBox/MediaCodec è¾¹ç•Œè·Ÿè¸ªç®—æ³•Suzuki85 DIY è¯´æ˜Ž è½¯è§£-&gt; ç¡¬è§£ è¾¹ç•Œè·Ÿè¸ªç®—æ³•Suzuki85 å°±æ˜¯ OpenCV å†…éƒ¨çš„ä¸€ç§è¾¹ç¼˜æ£€æµ‹æ–¹æ¡ˆ è‡ªå·±å¤„ç†åƒç´ æ•°æ® åŽæœŸé€šè¿‡æ›¿ä»£æ–¹æ¡ˆå¯ä»¥è§£å†³ä¸Šé¢æåˆ°çš„é—®é¢˜ï¼Œä¸»è¦æ˜¯åŒ…å¤§å°é—®é¢˜ã€‚å¦å¤–ä¹Ÿå¯ä»¥è‡ªå·±åŠ¨æ‰‹åŠ æ·±äº†è§£å¼€æºçš„æŠ€æœ¯æ–¹æ¡ˆ __has_includeé€šè¿‡æ›¿ä»£æ–¹æ¡ˆå¯ä»¥ç§»é™¤å¼€æºåº“ï¼Œä½†æ˜¯æŽ¥å…¥å¼€æºæ–¹æ¡ˆå®žçŽ°åŠŸèƒ½çš„ç›¸å…³ä»£ç å°±æ²¡å¿…è¦ç§»é™¤äº†ã€‚æ‰€ä»¥å¯ä»¥é€šè¿‡æ¡ä»¶ç¼–è¯‘åšä¸€ä¸ªåŒºåˆ†ã€‚æ­£å¥½__has_includeè¿™ä¸ªå®å¯ä»¥æ»¡è¶³è¦æ±‚ æè¿°æ­¤å®ä¼ å…¥ä¸€ä¸ªä½ æƒ³å¼•å…¥æ–‡ä»¶çš„åç§°ä½œä¸ºå‚æ•°ï¼Œå¦‚æžœè¯¥æ–‡ä»¶èƒ½å¤Ÿè¢«å¼•å…¥åˆ™è¿”å›ž1ï¼Œå¦åˆ™è¿”å›ž0ã€‚ ç”¨æ³• 12345#if __has_include(&lt;XXX/XXX.h&gt;)#import &lt;XXX/XXX.h&gt;#else#import "YYY.h"#endif é¡¹ç›®ä¸­çš„å®žé™…ç”¨æ³•ï¼š 123456789#if __cplusplus &amp;&amp; __has_include(&lt;Libyuv/libyuv.h&gt;)#include &lt;Libyuv/libyuv.h&gt;#endif#if __cplusplus &amp;&amp; __has_include(&lt;Libyuv/libyuv.h&gt;)...#else...#endif 12345#if __has_include(&lt;opencv2/imgcodecs/ios.h&gt;) contourArr = [OpenCVWrapper findContours:image];#else contourArr = [PContour findContours:image threshold:threshold];#endif 12345678910111213141516#if __cplusplus &amp;&amp; __has_include(&lt;ffmpeg/avformat.h&gt;)extern "C" &#123;#include "ffmpeg/timestamp.h"#include "ffmpeg/avformat.h"#include "ffmpeg/bsf.h"#include "ffmpeg/swscale.h"#include "ffmpeg/swresample.h"#include "ffmpeg/avformat.h"#include "ffmpeg/imgutils.h"#include "ffmpeg/samplefmt.h"&#125;#endif ...#endif]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RGB2YUV]]></title>
    <url>%2F2022%2F09%2F05%2FRGB2YUV%2F</url>
    <content type="text"><![CDATA[RGB2YUVå¤„ç†éŸ³è§†é¢‘ï¼Œå¯¹YUV RGBè‚¯å®šä¸é™Œç”Ÿï¼Œè¿™é‡Œè®°å½•ä¸‹ç»è¿‡OpenGLå¤„ç†åŽçš„ RGB æ ¼å¼çš„pixelBuffer è½¬æˆ YUV æ ¼å¼å¯¼å‡ºè§†é¢‘ã€‚ DIYè‡ªå·±å¤„ç†çŸ©é˜µçš„è®¡ç®—ï¼ŒYUVçš„å­˜å‚¨æ ¼å¼ï¼Œå¯ä»¥åŠ æ·±å¯¹YUVçš„ç†è§£ï¼Œ ç±»ä¼¼çš„åè¿‡æ¥å¤„ç†ï¼Œæˆ–è€…å¤„ç†å…¶ä»–æ ¼å¼çš„YUV 422 444ç­‰ï¼Œä¹Ÿæ˜¯ä¸€æ ·çš„ã€‚æ‰€ä»¥è¿˜æ˜¯æœ‰å¿…è¦äº†è§£ä¸€ä¸‹ï¼ŒDO IT YOURSELF. é‡ç‚¹æ˜¯æ³¨æ„å†…å­˜å¯¹é½ï¼ŒYUV420é‡‡æ ·å­˜å‚¨æ–¹å¼å°±å¥½äº†ï¼Œå…¶ä»–æ²¡ä»€ä¹ˆå¤æ‚çš„ã€‚ è½¬æ¢åŽ å¦‚æžœå‡ºçŽ°è¿™ç§åƒç´ é”™ä½çš„æƒ…å†µï¼Œä¸€èˆ¬æ˜¯å†…å­˜å¯¹é½ å¯¼è‡´çš„è¡¥ä½æ²¡æœ‰è€ƒè™‘åˆ°ï¼Œå‚è€ƒä¸‹ä»£ç é‡Œé¢çš„ strideå­—æ®µ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109CFDictionaryRef CreateCFDictionary(CFTypeRef* keys, CFTypeRef* values, size_t size) &#123; return CFDictionaryCreate(kCFAllocatorDefault, keys, values, size, &amp;kCFTypeDictionaryKeyCallBacks, &amp;kCFTypeDictionaryValueCallBacks); &#125;static void bt709_rgb2yuv8bit_TV(uint8_t R, uint8_t G, uint8_t B, uint8_t &amp;Y, uint8_t &amp;U, uint8_t &amp;V) &#123; Y = 0.183 * R + 0.614 * G + 0.062 * B + 16; U = -0.101 * R - 0.339 * G + 0.439 * B + 128; V = 0.439 * R - 0.399 * G - 0.040 * B + 128; &#125;CVPixelBufferRef RGB2YCbCr8Bit(CVPixelBufferRef pixelBuffer) &#123; CVPixelBufferLockBaseAddress(pixelBuffer, 0); uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddress(pixelBuffer); int w = (int) CVPixelBufferGetWidth(pixelBuffer); int h = (int) CVPixelBufferGetHeight(pixelBuffer); int stride = (int) CVPixelBufferGetBytesPerRow(pixelBuffer) / 4; OSType pixelFormat = kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange; CVPixelBufferRef pixelBufferCopy = NULL; const size_t attributes_size = 1; CFTypeRef keys[attributes_size] = &#123; kCVPixelBufferIOSurfacePropertiesKey, &#125;; CFDictionaryRef io_surface_value = CreateCFDictionary(nullptr, nullptr, 0); CFTypeRef values[attributes_size] = &#123;io_surface_value&#125;; CFDictionaryRef attributes = CreateCFDictionary(keys, values, attributes_size); CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, w, h, pixelFormat, attributes, &amp;pixelBufferCopy); if (status != kCVReturnSuccess) &#123; std::cout &lt;&lt; "YUVBufferCopyWithPixelBuffer :: failed" &lt;&lt; std::endl; return nullptr; &#125; if (attributes) &#123; CFRelease(attributes); attributes = nullptr; &#125; CVPixelBufferLockBaseAddress(pixelBufferCopy, 0); size_t y_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferCopy, 0); size_t uv_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferCopy, 1); int plane_h1 = (int) CVPixelBufferGetHeightOfPlane(pixelBufferCopy, 0); int plane_h2 = (int) CVPixelBufferGetHeightOfPlane(pixelBufferCopy, 1); uint8_t *y = (uint8_t *) CVPixelBufferGetBaseAddressOfPlane(pixelBufferCopy, 0); memset(y, 0x80, plane_h1 * y_stride); uint8_t *uv = (uint8_t *) CVPixelBufferGetBaseAddressOfPlane(pixelBufferCopy, 1); memset(uv, 0x80, plane_h2 * uv_stride); int y_bufferSize = w * h; int uv_bufferSize = w * h / 4; uint8_t *y_planeData = (uint8_t *) malloc(y_bufferSize * sizeof(uint8_t)); uint8_t *u_planeData = (uint8_t *) malloc(uv_bufferSize * sizeof(uint8_t)); uint8_t *v_planeData = (uint8_t *) malloc(uv_bufferSize * sizeof(uint8_t)); int u_offset = 0; int v_offset = 0; uint8_t R, G, B; uint8_t Y, U, V; for (int i = 0; i &lt; h; i ++) &#123; for (int j = 0; j &lt; w; j ++) &#123; int offset = i * stride + j; B = baseAddress[offset * 4]; G = baseAddress[offset * 4 + 1]; R = baseAddress[offset * 4 + 2]; bt709_rgb2yuv8bit_TV(R, G, B, Y, U, V); y_planeData[i * w + j] = Y; //éš”è¡Œæ‰«æ å¶æ•°è¡Œçš„å¶æ•°åˆ—å–U å¥‡æ•°è¡Œçš„å¶æ•°åˆ—å–V if (j % 2 == 0) &#123; (i % 2 == 0) ? u_planeData[u_offset++] = U : v_planeData[v_offset++] = V; &#125; &#125; &#125; for (int i = 0; i &lt; plane_h1; i ++) &#123; memcpy(y + i * y_stride, y_planeData + i * w, w); if (i &lt; plane_h2) &#123; for (int j = 0 ; j &lt; w ; j+=2) &#123; //NV12 å’Œ NV21 æ ¼å¼éƒ½å±žäºŽ YUV420SP ç±»åž‹ã€‚å®ƒä¹Ÿæ˜¯å…ˆå­˜å‚¨äº† Y åˆ†é‡ï¼Œä½†æŽ¥ä¸‹æ¥å¹¶ä¸æ˜¯å†å­˜å‚¨æ‰€æœ‰çš„ U æˆ–è€… V åˆ†é‡ï¼Œè€Œæ˜¯æŠŠ UV åˆ†é‡äº¤æ›¿è¿žç»­å­˜å‚¨ã€‚ //NV12 æ˜¯ IOS ä¸­æœ‰çš„æ¨¡å¼ï¼Œå®ƒçš„å­˜å‚¨é¡ºåºæ˜¯å…ˆå­˜ Y åˆ†é‡ï¼Œå† UV è¿›è¡Œäº¤æ›¿å­˜å‚¨ã€‚ memcpy(uv + i * y_stride + j, u_planeData + i * w/2 + j/2, 1); memcpy(uv + i * y_stride + j + 1, v_planeData + i * w/2 + j/2, 1); &#125; &#125; &#125; free(y_planeData); free(u_planeData); free(v_planeData); CVPixelBufferUnlockBaseAddress(pixelBuffer, 0); CVPixelBufferUnlockBaseAddress(pixelBufferCopy, 0); return pixelBufferCopy; &#125; LibYUVçœ‹è¿‡äº†ä¸Šä¸€ç§æ–¹å¼ï¼ŒLibYUVå°±æ›´å¥½ç†è§£äº†ï¼Œè¿™é‡Œä¸»è¦é€šè¿‡pod ä¾èµ–ä¸‹ LibYUV-iosï¼Œ å°±ä¸è‡ªå·±ç¼–è¯‘äº†ã€‚ pod &#39;Libyuv&#39;,&#39;1703&#39; LibYUV ä¸èƒ½ç›´æŽ¥RGBè½¬æˆNV12 ,éœ€è¦é€šè¿‡I420è¿‡åº¦ä¸‹ã€‚ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990CVPixelBufferLockBaseAddress(pixelBuffer, 0); uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddress(pixelBuffer); size_t bgraStride = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer,0); int w = (int) CVPixelBufferGetWidth(pixelBuffer); int h = (int) CVPixelBufferGetHeight(pixelBuffer); OSType pixelFormat = kCVPixelFormatType_420YpCbCr8Planar; CVPixelBufferRef pixelBufferCopy = NULL; const size_t attributes_size = 1; CFTypeRef keys[attributes_size] = &#123; kCVPixelBufferIOSurfacePropertiesKey &#125;; CFDictionaryRef io_surface_value = vtc::CreateCFDictionary(nullptr, nullptr, 0); CFTypeRef values[attributes_size] = &#123;io_surface_value&#125;; CFDictionaryRef attributes = vtc::CreateCFDictionary(keys, values, attributes_size); CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, w, h, pixelFormat, attributes, &amp;pixelBufferCopy); if (status != kCVReturnSuccess) &#123; std::cout &lt;&lt; "YUVBufferCopyWithPixelBuffer :: failed" &lt;&lt; std::endl; return nullptr; &#125; if (attributes) &#123; CFRelease(attributes); attributes = nullptr; &#125; CVPixelBufferLockBaseAddress(pixelBufferCopy, 0); unsigned char* y = (unsigned char*)CVPixelBufferGetBaseAddressOfPlane(pixelBufferCopy,0); unsigned char* u = (unsigned char*)CVPixelBufferGetBaseAddressOfPlane(pixelBufferCopy,1); unsigned char* v = (unsigned char*)CVPixelBufferGetBaseAddressOfPlane(pixelBufferCopy,2); int32_t width = (int32_t)CVPixelBufferGetWidth(pixelBufferCopy); int32_t height = (int32_t)CVPixelBufferGetHeight(pixelBufferCopy); size_t y_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferCopy,0); size_t u_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferCopy,1); size_t v_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferCopy,2); libyuv::ARGBToI420(baseAddress, (int)bgraStride, y, (int)y_stride, u, (int)u_stride, v, (int)v_stride, width, height); CVPixelBufferRef pixelBufferNV12 = NULL; const size_t size = 1; CFTypeRef _keys[size] = &#123; kCVPixelBufferIOSurfacePropertiesKey &#125;; CFDictionaryRef _io_surface_value = vtc::CreateCFDictionary(nullptr, nullptr, 0); CFTypeRef _values[size] = &#123;_io_surface_value&#125;; CFDictionaryRef _attributes = vtc::CreateCFDictionary(_keys, _values, size); CVReturn _status = CVPixelBufferCreate(kCFAllocatorDefault, w, h, kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange, _attributes, &amp;pixelBufferNV12); if (_status != kCVReturnSuccess) &#123; std::cout &lt;&lt; "YUVBufferCopyWithPixelBuffer :: failed" &lt;&lt; std::endl; return nullptr; &#125; if (_attributes) &#123; CFRelease(_attributes); _attributes = nullptr; &#125; CVPixelBufferLockBaseAddress(pixelBufferNV12, 0); unsigned char* _y = (unsigned char*)CVPixelBufferGetBaseAddressOfPlane(pixelBufferNV12,0); unsigned char* _uv = (unsigned char*)CVPixelBufferGetBaseAddressOfPlane(pixelBufferNV12,1); size_t _y_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferNV12, 0); size_t _uv_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferNV12, 1); int32_t _width = (int32_t)CVPixelBufferGetWidth(pixelBufferNV12); int32_t _height = (int32_t)CVPixelBufferGetHeight(pixelBufferNV12); libyuv::I420ToNV12(y, (int)y_stride, u, (int)u_stride, v, (int)v_stride, _y, (int)_y_stride, _uv, (int)_uv_stride, _width, _height); CVPixelBufferUnlockBaseAddress(pixelBuffer, 0); CVPixelBufferUnlockBaseAddress(pixelBufferCopy, 0); CVPixelBufferUnlockBaseAddress(pixelBufferNV12, 0); CVPixelBufferRelease(pixelBufferCopy); RGB-&gt;NV21æ›´æ–°ä¸‹:ä¸Šæ¬¡ä½¿ç”¨libyuvçš„æ—¶å€™ çœ‹æ¼äº†ï¼Œå…¶å®žæœ‰argbè½¬nv21çš„ 123456789101112131415161718192021222324252627282930313233343536373839404142CVPixelBufferLockBaseAddress(pixelBuffer, 0);uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddress(pixelBuffer);size_t bgraStride = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer,0);int w = (int) CVPixelBufferGetWidth(pixelBuffer);int h = (int) CVPixelBufferGetHeight(pixelBuffer);CVPixelBufferRef pixelBufferNV12 = NULL;const size_t attributes_size = 1;CFTypeRef keys[attributes_size] = &#123; kCVPixelBufferIOSurfacePropertiesKey&#125;;CFDictionaryRef io_surface_value = vtc::CreateCFDictionary(nullptr, nullptr, 0);CFTypeRef values[attributes_size] = &#123;io_surface_value&#125;;CFDictionaryRef attributes = vtc::CreateCFDictionary(keys, values, attributes_size);CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, w, h, kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange, attributes, &amp;pixelBufferNV12);if (status != kCVReturnSuccess) &#123; std::cout &lt;&lt; "YUVBufferCopyWithPixelBuffer :: failed" &lt;&lt; std::endl; return nullptr;&#125;if (attributes) &#123; CFRelease(attributes); attributes = nullptr;&#125;CVPixelBufferLockBaseAddress(pixelBufferNV12, 0);unsigned char* y = (unsigned char*)CVPixelBufferGetBaseAddressOfPlane(pixelBufferNV12,0);unsigned char* uv = (unsigned char*)CVPixelBufferGetBaseAddressOfPlane(pixelBufferNV12,1);size_t y_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferNV12, 0);size_t uv_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferNV12, 1);int32_t width = (int32_t)CVPixelBufferGetWidth(pixelBufferNV12);int32_t height = (int32_t)CVPixelBufferGetHeight(pixelBufferNV12);// ARGB-&gt;NV21libyuv::ARGBToNV12(baseAddress, (int)bgraStride, y, (int)y_stride, uv, (int)uv_stride, width, height)CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);CVPixelBufferUnlockBaseAddress(pixelBufferNV12, 0);return pixelBufferNV12;]]></content>
      <categories>
        <category>media</category>
      </categories>
      <tags>
        <tag>YUV</tag>
        <tag>media</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter Display P3]]></title>
    <url>%2F2022%2F08%2F31%2Fflutter-Display-P3%2F</url>
    <content type="text"><![CDATA[Display P3Display P3 æ˜¯è‹¹æžœæ‰‹æœºç›¸æœºä½¿ç”¨çš„ä¸€ç§è‰²åŸŸï¼ŒæŸ¥çœ‹å›¾ç‰‡ä¿¡æ¯å¯ä»¥çœ‹åˆ°ï¼Œ ç„¶è€Œåœ¨flutterä¸­ æ¸²æŸ“ Display P3æ ¼å¼çš„å›¾ç‰‡ bitmapé¢œè‰²å¤±çœŸ,ä¸äº†è§£è‰²åŸŸçš„å‚è€ƒä¸‹å‰é¢HDRç›¸å…³çš„æ–‡ç«  å¤±çœŸæ•ˆæžœï¼š ä¿®å¤æ•ˆæžœï¼š åŽŸå› å°±æ˜¯Flutter ç›´æŽ¥æŠŠDisplay P3ç¤¾åŒºçš„å½“åšsRGBè‰²åŸŸçš„å›¾åƒå¤„ç†äº†ï¼Œè€Œæ²¡æœ‰åšè‰²åŸŸè½¬æ¢ FlutterFlutter è·Ÿ Native å›¾ç‰‡æ‰“é€šï¼Œå¸¸è§æœ‰ä¸¤ç§æ–¹å¼ï¼šbitmapä¼ é€’ &amp;&amp; å¤–æŽ¥çº¹ç†ï¼Œè¿™è¾¹æ–‡ç« é’ˆå¯¹çš„æ˜¯å‰è€…ï¼Œå¤–æŽ¥çº¹ç†ä¹Ÿä¼šæœ‰è¿™ç§é—®é¢˜çš„ï¼Œæ— éžå°±æ˜¯pixelBuffer è½¬çº¹ç†ï¼ŒpixelBufferä¸€æ ·ä¹Ÿæ˜¯æœ‰è‰²åŸŸé—®é¢˜çš„ï¼Œè§£å†³æ–¹æ¡ˆå¯ä»¥å‚è€ƒ Flutter HDR,åŽŸç†æ˜¯ä¸€æ ·çš„ã€‚ é’ˆå¯¹å›¾ç‰‡çš„bitmapåšè‰²åŸŸè½¬æ¢ï¼Œæ–¹æ¡ˆæœ‰å¾ˆå¤šï¼Œè¿™é‡Œåˆ—å‡ºå¸¸è§çš„ä¸¤ç§ï¼š ImageIO123456789101112131415161718192021222324252627282930CGImageSourceRef src = CGImageSourceCreateWithData((__bridge CFDataRef) imageData, NULL); NSUInteger frameCount = CGImageSourceGetCount(src); if (frameCount &gt; 0) &#123; NSDictionary *options = @&#123;(__bridge NSString *)kCGImageSourceShouldCache : @YES, (__bridge NSString *)kCGImageSourceShouldCacheImmediately : @NO &#125;; NSDictionary *props = (NSDictionary *) CFBridgingRelease(CGImageSourceCopyPropertiesAtIndex(src, (size_t) 0, (__bridge CFDictionaryRef)options)); NSString *profileName = [props objectForKey:(NSString *) kCGImagePropertyProfileName]; if ([profileName isEqualToString:@"Display P3"]) &#123; NSMutableData *data = [NSMutableData data]; CGImageDestinationRef destRef = CGImageDestinationCreateWithData((__bridge CFMutableDataRef)data, kUTTypePNG, 1, NULL); NSMutableDictionary *properties = [NSMutableDictionary dictionary]; properties[(__bridge NSString *)kCGImageDestinationLossyCompressionQuality] = @(1); properties[(__bridge NSString *)kCGImageDestinationEmbedThumbnail] = @(0); properties[(__bridge NSString *)kCGImagePropertyNamedColorSpace] = (__bridge id _Nullable)(kCGColorSpaceSRGB); properties[(__bridge NSString *)kCGImageDestinationOptimizeColorForSharing] = @(YES); CGImageDestinationAddImageFromSource(destRef, src, 0, (__bridge CFDictionaryRef)properties); CGImageDestinationFinalize(destRef); CFRelease(destRef); return data; &#125; &#125; return imageData; æ ¸å¿ƒå°±æ˜¯è¿™ä¸ªå±žæ€§ï¼Œå¾ˆå¥½ç†è§£å§ 12345/* Create an image using a colorspace, that has is compatible with older devices * The value should be kCFBooleanTrue or kCFBooleanFalse * Defaults to kCFBooleanFalse = don&apos;t do any color conversion */IMAGEIO_EXTERN const CFStringRef kCGImageDestinationOptimizeColorForSharing IMAGEIO_AVAILABLE_STARTING(10.12, 9.3); é‡æ–°Renderä¸€å¼ å›¾1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980CGImageSourceRef src = CGImageSourceCreateWithData((__bridge CFDataRef) imageData, NULL); NSUInteger frameCount = CGImageSourceGetCount(src); if (frameCount &gt; 0) &#123; NSDictionary *frameProperties = (NSDictionary *) CFBridgingRelease(CGImageSourceCopyPropertiesAtIndex(src, (size_t) 0, NULL)); NSString *profileName = [frameProperties objectForKey:(NSString *) kCGImagePropertyProfileName]; if ([profileName isEqualToString:@"Display P3"]) &#123; CGImageRef imageRef = CGImageSourceCreateImageAtIndex(src, (size_t) 0, NULL); CIImage *image = [CIImage imageWithCGImage:imageRef]; CIContext *context = [[CIContext alloc] init]; float w = image.extent.size.width; float h = image.extent.size.height; unsigned char *bitmap = malloc(w * h * 4); CIRenderDestination *destination = [[CIRenderDestination alloc] initWithBitmapData:bitmap width:w height:h bytesPerRow:w * 4 format:kCIFormatBGRA8]; NSError *error = nil; [context startTaskToRender:image toDestination:destination error:&amp;error]; if (error) &#123; CFRelease(src); return imageData; &#125; CFRelease(src); UIImage *newImage = [FlutterImagePlugin imageFromBRGABytes:bitmap imageSize:image.extent.size]; free(bitmap); CGImageRelease(imageRef); if (newImage == nil) &#123; return imageData; &#125; return UIImagePNGRepresentation(newImage); &#125; &#125;+ (UIImage *)imageFromBRGABytes:(unsigned char *)imageBytes imageSize:(CGSize)imageSize &#123; CGImageRef imageRef = [self imageRefFromBGRABytes:imageBytes imageSize:imageSize]; if (imageRef == NULL) &#123; return nil; &#125; UIImage *image = [UIImage imageWithCGImage:imageRef]; CGImageRelease(imageRef); return image;&#125;+ (CGImageRef)imageRefFromBGRABytes:(unsigned char *)imageBytes imageSize:(CGSize)imageSize &#123; CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(imageBytes, imageSize.width, imageSize.height, 8, imageSize.width * 4, colorSpaceSDImage, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst); if (context == NULL) &#123; return NULL; &#125; CGImageRef imageRef = CGBitmapContextCreateImage(context); if (imageRef == NULL) &#123; CGContextRelease(context); return NULL; &#125; CGContextRelease(context); return imageRef;&#125; ä»Žä»£ç é‡è·Ÿæ€§èƒ½è€ƒé‡ï¼Œæ— è„‘é€‰å‰è€… ðŸ˜]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter-hdr]]></title>
    <url>%2F2022%2F08%2F24%2Fflutter-hdr%2F</url>
    <content type="text"><![CDATA[flutterflutter æ’­æ”¾ HDR è§†é¢‘ï¼Œè‰²å½©è·Ÿäº®åº¦éƒ½æœ‰é—®é¢˜ ï¼Œgithub ä¹Ÿæœ‰åé¦ˆè¿™ä¸ªissue Video Player HDR Problem è·ŸåŽŸç”Ÿçš„å¯¹æ¯”å¯ä»¥å¾ˆæ˜Žæ˜¾çœ‹åˆ°å·®è·ï¼Œå®˜æ–¹çœ‹èµ·æ¥å¥½åƒä¹Ÿä¸é‡è§†è¿™ä¸ªé—®é¢˜ ðŸ˜• å…³äºŽ HDR æ ¼å¼ï¼Œå¯ä»¥çœ‹ä¸‹å‰é¢çš„æ–‡ç«  HDRç¬”è®° è¿™é‡Œè®°å½•ä¸‹Flutter video player plugin ä¸­å¤„ç†è§†é¢‘è‰²å½©çš„æ–¹æ³•ï¼Œäº®åº¦æå‡éœ€è¦é€šè¿‡ç¡¬ä»¶æ¿€æ´»ï¼ŒFlutterä¸­å¥½åƒæ²¡æ³•å¤„ç†ã€‚ é¢œè‰²çš„å¤„ç†æ ¸å¿ƒå°±æ˜¯åšäº†ä¸€ä¸ªHDR-&gt;SDRçš„tonemap,æ°å¥½CIImageä¸­æä¾›äº†è¿™æ ·çš„Filterï¼Œå¤„ç†å°±æ–¹ä¾¿å¤šäº†ï¼Œçœ‹è¿‡HDRç¬”è®° è¿™ç¯‡æ–‡ç« çš„è¯ï¼Œåº”è¯¥ä¹Ÿå¯ä»¥è‡ªå·±é€šè¿‡ EOTF + è‰²åŸŸæ˜ å°„ æ¥å¤„ç†ã€‚æš‚æ—¶ä¸çŸ¥é“ CIImageä¸­æ˜¯æ€Žä¹ˆå¤„ç†çš„ï¼ŒçŒœæµ‹æ˜¯å·®ä¸å¤šçš„ã€‚ 12345678910111213141516171819202122232425262728293031323334353637383940- (CVPixelBufferRef)pixelBufferFormCIImage:(CIImage *)image &#123; NSDictionary *options = [NSDictionary dictionaryWithObjectsAndKeys: @&#123;&#125;, kCVPixelBufferIOSurfacePropertiesKey, @YES, kCVPixelBufferCGImageCompatibilityKey, @YES, kCVPixelBufferCGBitmapContextCompatibilityKey, nil]; CVPixelBufferRef pixelBufferCopy = NULL; CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, image.extent.size.width, image.extent.size.height, kCVPixelFormatType_32BGRA, (__bridge CFDictionaryRef) options, &amp;pixelBufferCopy); if (status == kCVReturnSuccess) &#123; CIRenderDestination *destination = [[CIRenderDestination alloc] initWithPixelBuffer:pixelBufferCopy]; [self.mContext startTaskToRender:image toDestination:destination error:nil]; &#125; return pixelBufferCopy;&#125;- (CVPixelBufferRef)copyPixelBuffer &#123; CMTime outputItemTime = [_videoOutput itemTimeForHostTime:CACurrentMediaTime()]; if ([_videoOutput hasNewPixelBufferForItemTime:outputItemTime]) &#123; CVPixelBufferRef p = [_videoOutput copyPixelBufferForItemTime:outputItemTime itemTimeForDisplay:NULL]; CFTypeRef colorPrimaries = CVBufferGetAttachment(p, kCVImageBufferTransferFunctionKey, NULL); if (colorPrimaries &amp;&amp; CFEqual(colorPrimaries, kCVImageBufferTransferFunction_ITU_R_2100_HLG)) &#123; if (@available(iOS 14.1, *)) &#123; CIImage *image = [CIImage imageWithCVPixelBuffer:p options:@&#123;kCIImageToneMapHDRtoSDR : @(YES)&#125;]; CVPixelBufferRef newP = [self pixelBufferFormCIImage:image]; CVPixelBufferRelease(p); return newP; &#125; &#125; return p; &#125; else &#123; return NULL; &#125;&#125;]]></content>
      <categories>
        <category>HDR</category>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>HDR</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HDRç¬”è®°]]></title>
    <url>%2F2022%2F08%2F18%2FHDR%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[Noun explanationITUï¼šå›½é™…ç”µä¿¡è”ç›Ÿ International Telecommunication UnionITU-Rï¼šå›½é™…ç”µä¿¡è”ç›Ÿæ— çº¿ç”µé€šä¿¡éƒ¨é—¨ ITU Radiocommunication Sector CIE :å›½é™…ç…§æ˜Žåä¼š ï¼ˆè‹±æ–‡ï¼šInternational Commission on Illumination ï¼Œæ³•æ–‡ï¼šCommission internationale de l&#39;Ã©clairage ï¼Œé‡‡ç”¨æ³•æ–‡ç¼©å†™ï¼šCIE ï¼‰ SMPTEï¼šç”µå½±ç”µè§†å·¥ç¨‹å¸ˆåä¼š Society of Motion Picture and Television Engineers Hueï¼šè‰²è°ƒ è‰²å½© è‰²ç›¸Chromaï¼šè‰²è°ƒé¥±å’Œåº¦ æµ“åº¦Luminanceï¼šäº®åº¦ æ˜Žåº¦ HDR ConceptHDR:High Dynamic Range å­—é¢ä¸Šæ˜¯åŠ¨æ€èŒƒå›´ï¼Œä¸€èˆ¬æŒ‡äº®åº¦ä¸Šå¯ä»¥è¡¨è¾¾æ›´å¤§çš„äº®åº¦èŒƒå›´ï¼Œå‘ˆçŽ°æ›´å¤§çš„äº®åº¦å¯¹æ¯”åº¦ã€‚ä½†æ˜¯å®žé™…å®žé™…ä¸ŠHDRçš„æŠ€æœ¯å’Œæ ‡å‡†æ¶‰åŠè‰²å½©ç›¸å…³çš„ä¸€ç»„å±žæ€§çš„æ”¹å–„ï¼Œå¯ä»¥å¸¦æ¥æ›´å¤šçš„é¢œè‰²ã€æ›´å¤§çš„äº®åº¦å¯¹æ¯”åº¦ã€æ›´é«˜ç²¾åº¦çš„é‡åŒ–ã€‚ OETF/EOTF: Optical-Electro/Electro-Optical Transfer Function å…‰ç”µ/ç”µå…‰è½¬æ¢å‡½æ•° äººå¯¹äº®åº¦çš„æ„ŸçŸ¥æ˜¯éžçº¿æ€§çš„ï¼Œå¯¹æš—éƒ¨ç»†èŠ‚æ•æ„Ÿï¼Œå¯¹äº®éƒ¨ç»†èŠ‚ä¸æ•æ„Ÿï¼Œåˆ©ç”¨è¿™ä¸ªç‰¹ç‚¹è®¾è®¡äº†éžçº¿æ€§çš„å…‰ç”µè½¬æ¢å’Œç”µå…‰è½¬æ¢çš„å‡½æ•°ã€‚è¿™æ ·çš„å¤„ç†ä¸ä»…å¯ä»¥èŠ‚çœå¸¦å®½ï¼Œä¹Ÿå¯ä»¥åŸºæœ¬æ»¡è¶³ç”¨æˆ·ä½“éªŒéœ€æ±‚ã€‚å…‰ç”µè½¬æ¢çš„æ—¶å€™åšäº†ç‰¹æ®Šçš„éžçº¿æ€§ç¼–ç ï¼Œä¸ºæš—éƒ¨ç»†èŠ‚åˆ†é…æ›´å¤šçš„ç çŽ‡ï¼Œäº®éƒ¨ç»†èŠ‚è¿›è¡Œäº†åŽ‹ç¼©æˆ–è€…æˆªæ–­å‡å°‘ç çŽ‡çš„åˆ†é…ã€‚ç”µå…‰è½¬æ¢è¿›è¡Œæ˜¾ç¤ºè¿˜åŽŸçš„æ—¶å€™ï¼Œé€šè¿‡åº”ç”¨ä¸€ä¸ªé€†çš„éžçº¿æ€§å˜åŒ–ï¼Œè¿˜åŽŸå‡ºçº¿æ€§å…‰ã€‚ Infoé€šè¿‡mediainfo æŸ¥çœ‹ä¸€ä¸ªHDRè§†é¢‘ä¿¡æ¯ Video ID 1 Format HEVC Format/Info High Efficiency Video Coding Format profile Main 10@L5@High Codec ID hvc1 Codec ID/Info High Efficiency Video Coding Duration 14 s 0 ms Bit rate 123 kb/s Width 3 840 pixels Height 2 160 pixels Display aspect ratio 16:9 Frame rate mode Constant Frame rate 30.000 FPS Color space YUV Chroma subsampling 4:2:0 Bit depth 10 bits Scan type Progressive Bits/(PixelFrame)* 0.000 Stream size 211 KiB (98%) Title Core Media Video Encoded date UTC 2020-06-14 21:45:40 Tagged date UTC 2020-06-14 21:47:33 Color range Limited Color primaries BT.2020 Transfer characteristics HLG Matrix coefficients BT.2020 non-constant Codec configuration box hvcC ä¸‹é¢å‡ ä¸ªå‚æ•°å±žäºŽå…ƒæ•°æ® ï¼Œå¯èƒ½æ²¡æœ‰ åŽæ–‡ä¼šè®²åˆ° Video Mastering display color primaries Display P3 / R: x=0.677980 y=0.321980, G: x=0.245000 y=0.703000, B: x=0.137980 y=0.052000, White point: x=0.312680 y=0.328980 Mastering display luminance min: 0.0001 cd/m2, max: 1000 cd/m2 Maximum Content Light Level 1000 cd/m2 Maximum Frame-Average Light Level 400 cd/m2 é‡ç‚¹å…³æ³¨ ï¼š Color range ï¼šè‰²å½©èŒƒå›´ Color primaries ï¼šè‰²å½©åŽŸè‰² Transfer characteristics ï¼šä¼ è¾“ç‰¹æ€§ Matrix coefficients ï¼šçŸ©é˜µç³»æ•° å…ƒæ•°æ®å­—æ®µ Mastering display color primaries Mastering display luminance Maximum Content Light Level Maximum Frame-Average Light Level éƒ¨åˆ†å‚æ•°å¯ä»¥é€šè¿‡ffprobeæŸ¥çœ‹å¯¹åº”çš„é€‰é¡¹ ffprobe -h &gt;&gt; ffprobe.txt Color rangeè‰²å½©èŒƒå›´ä¸»è¦æ˜¯ä¸¤ä¸ªï¼š Full range ï¼ˆPC range ï¼‰ Video rangeï¼ˆlimited rangeï¼Œtv rangeï¼‰ Full Range å°±æ˜¯æˆ‘ä»¬æ‰€ç†Ÿæ‚‰çš„ [0, 255]ï¼Œè€Œåœ¨ Limited Range ä¸­ï¼ŒYâ€™ çš„å€¼è¢«é™åˆ¶åœ¨ [16, 235]ï¼ŒCb å’Œ Cr çš„å€¼è¢«é™åˆ¶åœ¨ [16, 240] ï¼ˆé’ˆå¯¹8bitçš„ï¼‰ã€‚ HDRä¸€ä¸ªé‡è¦å±žæ€§å°±æ˜¯é‡åŒ–ç²¾åº¦ã€‚ SDRæŠ€æœ¯ä½¿ç”¨8bitè¿›è¡Œé¢œè‰²çš„è¡¨è¾¾ï¼Œè€ŒHDRä½¿ç”¨10bit/12bitè¿›è¡Œé¢œè‰²çš„è¡¨ç¤ºï¼Œä»Žè€Œå‡å°‘äº†8bitå®¹æ˜“å‡ºçŽ°çš„äººä¸ºæ¡å¸¦æ•ˆåº”ã€‚ ios ä¸­çš„ç²¾åº¦ &amp; è‰²å½©èŒƒå›´ ï¼š 123kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange = &apos;420v&apos;, /* Bi-Planar Component Y&apos;CbCr 8-bit 4:2:0, video-range (luma=[16,235] chroma=[16,240]). baseAddr points to a big-endian CVPlanarPixelBufferInfo_YCbCrBiPlanar struct */kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange = &apos;x420&apos;, /* 2 plane YCbCr10 4:2:0, each 10 bits in the MSBs of 16bits, video-range (luma=[64,940] chroma=[64,960]) */ 123kCVPixelFormatType_420YpCbCr8BiPlanarFullRange = &apos;420f&apos;, /* Bi-Planar Component Y&apos;CbCr 8-bit 4:2:0, full-range (luma=[0,255] chroma=[1,255]). baseAddr points to a big-endian CVPlanarPixelBufferInfo_YCbCrBiPlanar struct */ kCVPixelFormatType_420YpCbCr10BiPlanarFullRange = &apos;xf20&apos;, /* 2 plane YCbCr10 4:2:0, each 10 bits in the MSBs of 16bits, full-range (Y range 0-1023) */ å…³äºŽä¸ºä»€ä¹ˆè¦å°†YUVé‡åŒ–ä¸ºtv range 16-235 ï¼Ÿ ä»¥ä¸‹æ˜¯ç»´åŸºç™¾ç§‘æ‘˜æŠ„çš„ä¸€æ®µï¼Œ æ„æ€æ˜¯tv rangeæ˜¯ä¸ºäº†è§£å†³æ»¤æ³¢ï¼ˆæ¨¡æ•°è½¬æ¢ï¼‰åŽçš„è¿‡å†²çŽ°è±¡ï¼Œ Yâ€² values are conventionally shifted and scaled to the range [16, 235] (referred to as studio swing or â€œTV levelsâ€) rather than using the full range of [0, 255] (referred to as full swing or â€œPC levelsâ€). This practice was standardized in SMPTE-125M in order to accommodate signal overshoots (â€œringingâ€) due to filtering. The value 235 accommodates a maximal black-to-white overshoot of 255 âˆ’ 235 = 20, or 20 / (235 âˆ’ 16) = 9.1%, which is slightly larger than the theoretical maximal overshoot (Gibbs phenomenon) of about 8.9% of the maximal step. The toe-room is smaller, allowing only 16 / 219 = 7.3% overshoot, which is less than the theoretical maximal overshoot of 8.9%. This is why 16 is added to Yâ€² and why the Yâ€² coefficients in the basic transform sum to 220 instead of 255.^[9]^ U and V values, which may be positive or negative, are summed with 128 to make them always positive, giving a studio range of 16â€“240 for U and V. (These ranges are important in video editing and production, since using the wrong range will result either in an image with â€œclippedâ€ blacks and whites, or a low-contrast image.) Color primariesä¸€èˆ¬ç†è§£ä¸ºè‰²åŸŸï¼Œè‰²åŸŸæŒ‡å¯ä»¥æ˜¾ç¤ºçš„æ‰€æœ‰é¢œè‰²çš„èŒƒå›´ï¼Œå¸¸è§çš„æœ‰Rec.709ï¼ˆå…¨é«˜æ¸…å¹¿æ’­æ ‡å‡†ï¼‰ã€Rec.2020ï¼ˆ4K/8Kå¹¿æ’­æ ‡å‡†BT.2020ï¼‰ã€Adobe RGBã€P3ç­‰ã€‚ bt709 unknown reserved bt470m bt470bg smpte170m smpte240m film bt2020 smpte428 smpte431 smpte432 ä¸‹å›¾æ˜¾ç¤ºäº†äººçœ¼èƒ½å¤Ÿæ„ŸçŸ¥çš„æ‰€æœ‰RGBå€¼çš„èŒƒå›´ã€‚ä¸‰è§’å½¢è¡¨ç¤ºè‰²åŸŸï¼šä¸‰è§’å½¢è¶Šå¤§ï¼Œå¯ä»¥æ˜¾ç¤ºçš„é¢œè‰²è¶Šå¤šã€‚ è¿™å¼ é©¬è¹„å½¢çš„å›¾ä¸Šé¢å¯ä»¥çœ‹åˆ°HDRä½¿ç”¨çš„è‰²åŸŸæ˜¯BT2020ï¼Œ SDRä½¿ç”¨çš„æ˜¯BT709ï¼Œå¯ä»¥æ˜Žæ˜¾çœ‹åˆ°HDRçš„è‰²åŸŸå¤§äºŽSDRã€‚ ç†è§£é¢œè‰²ç©ºé—´ï¼š é¢œè‰²ç©ºé—´ ç”± é¢œè‰²æ¨¡åž‹ è·Ÿ è‰²åŸŸ å…±åŒå®šä¹‰ã€‚é¢œè‰²æ¨¡åž‹çš„æ¦‚å¿µä¸ºï¼šä¸€ç§æŠ½è±¡æ•°å­¦æ¨¡åž‹ï¼Œé€šè¿‡ä¸€ç»„æ•°å­—æ¥æè¿°é¢œè‰²ï¼ˆä¾‹å¦‚RGBä½¿ç”¨ä¸‰å…ƒç»„ã€CMYKä½¿ç”¨å››å…ƒç»„ï¼‰ä¾‹å¦‚Adobe RGBå’ŒsRGBéƒ½åŸºäºŽRGBé¢œè‰²æ¨¡åž‹ï¼Œä½†å®ƒä»¬æ˜¯ä¸¤ä¸ªä¸åŒçš„é¢œè‰²ç©ºé—´ï¼Œå› ä¸ºè‰²åŸŸä¸ä¸€æ · Color Transferæè¿°å…‰ç”µè½¬æ¢è¿‡ç¨‹çš„è§†é¢‘å±žæ€§ä¹Ÿå«é¢œè‰²ä¼ è¾“å‡½æ•°Color Transfer å°±æ˜¯ä¸Šé¢è¡¨æ ¼é‡Œé¢çš„ Transfer characteristics å¸¸è§çš„hdrè½¬æ¢æ›²çº¿ä¸ºHLGå’ŒPQï¼Œå…¶ä¸­ï¼Œsmpte2084ä¸ºPQæ›²çº¿ï¼ˆæ„ŸçŸ¥é‡åŒ–ï¼‰ï¼Œarib-std-b67ä¸ºHLGæ›²çº¿ï¼ˆæ··åˆå¯¹æ•°ä¼½çŽ›ï¼‰ bt709 unknown reserved bt470m bt470bg smpte170m smpte240m linear log100 log316 iec61966-2-4 bt1361e iec61966-2-1 bt2020-10 bt2020-12 smpte2084 smpte428 arib-std-b67 ä¼ ç»Ÿçš„SDRè§†é¢‘ä½¿ç”¨çš„BT709çš„å…‰ç”µè½¬æ¢å‡½æ•°ï¼Œå¯¹é«˜äº®éƒ¨åˆ†è¿›è¡Œäº†æˆªæ–­ï¼Œå¯ä»¥è¡¨è¾¾çš„äº®åº¦åŠ¨æ€èŒƒå›´æœ‰é™ï¼Œæœ€å¤§äº®åº¦åªæœ‰100nitã€‚è€ŒHDRè§†é¢‘ï¼Œå¢žåŠ äº†é«˜äº®éƒ¨åˆ†ç»†èŠ‚çš„è¡¨è¾¾ï¼Œå¾ˆå¤§çš„æ‰©å±•äº®åº¦çš„åŠ¨æ€èŒƒå›´ã€‚ ä¸åŒHDRçš„è®¾è®¡åˆè¡·ä¸åŒï¼Œå…¶ä¸­PQçš„è®¾è®¡æ›´æŽ¥è¿‘äººçœ¼çš„ç‰¹ç‚¹ï¼Œäº®åº¦è¡¨è¾¾æ›´å‡†ç¡®ï¼Œå¯ä»¥è¡¨ç¤ºé«˜è¾¾10000nitçš„äº®åº¦ã€‚è€ŒHLGçš„è®¾è®¡è€ƒè™‘äº†è€è®¾å¤‡çš„å…¼å®¹æ€§ï¼Œå’Œä¼ ç»Ÿbt709çš„ä¼ è¾“å‡½æ•°æœ‰éƒ¨åˆ†æ˜¯é‡åˆçš„ï¼Œå¤©ç„¶çš„å¯¹è€è®¾å¤‡å…·æœ‰ä¸€å®šå…¼å®¹æ€§ MetadataHDRå…ƒæ•°æ®åˆ†ä¸ºä¸¤ç§ï¼Œé™æ€å…ƒæ•°æ® å’ŒåŠ¨æ€å…ƒæ•°æ® ï¼› ä½¿ç”¨PQæ›²çº¿çš„HDR10æ˜¯é‡‡ç”¨é™æ€å…ƒæ•°æ®çš„ï¼Œä½†æ˜¯æœæ¯”å…¬å¸æå‡ºæ¥çš„æœæ¯”è§†ç•Œå’Œä¸‰æ˜Ÿçš„HDR10+ï¼Œå°½ç®¡ä½¿ç”¨äº†PQæ›²çº¿ï¼Œä½†æ˜¯ä»–ä»¬ä½¿ç”¨çš„æ˜¯åŠ¨æ€å…ƒæ•°æ®ï¼ŒHLGæ²¡æœ‰å…ƒæ•°æ®ã€‚ å…¶ä¸­ DolbyVision ç­‰ä»·äºŽSMPTE ST 2094-10, HDR10+ ç­‰ä»·äºŽ SMPTE ST 2094-40 é™æ€å…ƒæ•°æ®è§„å®šäº†æ•´ä¸ªç‰‡å­åƒç´ çº§åˆ«æœ€å¤§äº®åº¦ä¸Šé™ï¼Œåœ¨ST 2086ä¸­æœ‰æ ‡å‡†åŒ–çš„å®šä¹‰ã€‚é™æ€å…ƒæ•°æ®çš„ç¼ºç‚¹æ˜¯å¿…é¡»åšå…¨å±€çš„è‰²è°ƒæ˜ å°„ï¼Œæ²¡æœ‰è¶³å¤Ÿçš„è°ƒèŠ‚ç©ºé—´ï¼Œå…¼å®¹æ€§ä¸å¥½ã€‚ åŠ¨æ€å…ƒæ•°æ®å¯ä»¥å¾ˆå¥½åœ°è§£å†³è¿™ä¸ªé—®é¢˜ã€‚åŠ¨æ€å…ƒæ•°æ®ä¸»è¦æœ‰ä¸¤ä¸ªæ–¹é¢çš„ä½œç”¨ï¼šä¸Žé™æ€å…ƒæ•°æ®ç›¸æ¯”ï¼Œå®ƒå¯ä»¥åœ¨æ¯ä¸€ä¸ªåœºæ™¯æˆ–è€…æ¯ä¸€å¸§ç”»é¢ï¼Œç»™è°ƒè‰²å¸ˆä¸€ä¸ªå‘æŒ¥çš„ç©ºé—´ï¼Œä»¥å±•çŽ°æ›´ä¸°å¯Œçš„ç»†èŠ‚ï¼›å¦ä¸€ä¸ªæ–¹é¢ï¼Œé€šè¿‡åŠ¨æ€å…ƒæ•°æ®ï¼Œåœ¨ç›®æ ‡æ˜¾ç¤ºäº®åº¦ä¸Šåšè‰²è°ƒæ˜ å°„ï¼Œå¯ä»¥æœ€å¤§ç¨‹åº¦åœ¨ç›®æ ‡æ˜¾ç¤ºå™¨ä¸Šå‘ˆçŽ°ä½œè€…çš„åˆ›ä½œæ„å›¾ã€‚ æœ€å¤§å†…å®¹äº®åº¦ï¼ˆMaxCLLï¼‰ï¼šæ•´ä¸ªè§†é¢‘æµä¸­æœ€äº®åƒç´ çš„äº®åº¦ã€‚ æœ€å¤§å¸§å¹³å‡äº®åº¦ï¼ˆMaxFALLï¼‰ï¼šæ•´ä¸ªè§†é¢‘æµä¸­æœ€äº®å¸§çš„å¹³å‡äº®åº¦ å¦å¤–è§£é‡Šä¸€ä¸‹å¤šå‡ºçŽ°çš„å‡ ä¸ªå‚æ•°:progressive,SAR,DAR. progressive,å…¶å®žå°±æ˜¯æ‰«ææ–¹å¼,é€è¡Œæ‰«æ.å¦å¤–çš„ä¸€ç§æ–¹å¼å°±æ˜¯éš”è¡Œæ‰«æ:interlaced.æˆ‘ä»¬å¹³æ—¶æ‰€è°“çš„1080p,è¿™ä¸ªpå°±æ˜¯progressive,è¡¨ç¤ºçš„æ˜¯1080å°ºå¯¸çš„é€è¡Œæ‰«æè§†é¢‘.DAR - display aspect ratioå°±æ˜¯è§†é¢‘æ’­æ”¾æ—¶ï¼Œæˆ‘ä»¬çœ‹åˆ°çš„å›¾åƒå®½é«˜çš„æ¯”ä¾‹ï¼Œç¼©æ”¾è§†é¢‘ä¹Ÿè¦æŒ‰è¿™ä¸ªæ¯”ä¾‹æ¥ï¼Œå¦åˆ™ä¼šä½¿å›¾åƒçœ‹èµ·æ¥è¢«åŽ‹æ‰æˆ–è€…æ‹‰é•¿äº†ä¼¼çš„ã€‚ SAR - storage aspect ratioå°±æ˜¯å¯¹å›¾åƒé‡‡é›†æ—¶ï¼Œæ¨ªå‘é‡‡é›†ä¸Žçºµå‘é‡‡é›†æž„æˆçš„ç‚¹é˜µï¼Œæ¨ªå‘ç‚¹æ•°ä¸Žçºµå‘ç‚¹æ•°çš„æ¯”å€¼ã€‚æ¯”å¦‚VGAå›¾åƒ640/480 = 4:3ï¼ŒD-1 PALå›¾åƒ720/576 = 5:4 PAR - pixel aspect ratioå¤§å¤šæ•°æƒ…å†µä¸º1:1,å°±æ˜¯ä¸€ä¸ªæ­£æ–¹å½¢åƒç´ ï¼Œå¦åˆ™ä¸ºé•¿æ–¹å½¢åƒç´ è¿™ä¸‰è€…çš„å…³ç³»PAR x SAR = DARæˆ–è€…PAR = DAR/SAR Tone Mappingè‰²è°ƒæ˜ å°„çš„ç›®çš„æ˜¯ä½¿é«˜åŠ¨æ€èŒƒå›´HDRå›¾åƒèƒ½å¤Ÿé€‚åº”ä½ŽåŠ¨æ€èŒƒå›´LDRæ˜¾ç¤ºå™¨ã€‚ è‰²è°ƒæ˜ å°„ç®—æ³•çš„ç›®çš„åœ¨äºŽå°†HDRå›¾åƒçš„äº®åº¦è¿›è¡ŒåŽ‹ç¼©ï¼Œè¿›è€Œæ˜ å°„åˆ°LDRæ˜¾ç¤ºè®¾å¤‡çš„æ˜¾ç¤ºèŒƒå›´ä¹‹å†…ï¼ŒåŒæ—¶ï¼Œåœ¨æ˜ å°„çš„è¿‡ç¨‹ä¸­è¦å°½é‡ä¿æŒåŽŸHDRå›¾åƒçš„ç»†èŠ‚ä¸Žé¢œè‰²ç­‰é‡è¦ä¿¡æ¯ã€‚ æ‰€ä»¥è‰²è°ƒæ˜ å°„ç®—æ³•éœ€è¦å…·æœ‰ä¸¤æ–¹é¢çš„æ€§è´¨ï¼š èƒ½å¤Ÿå°†å›¾åƒäº®åº¦è¿›è¡ŒåŽ‹ç¼©ã€‚ èƒ½å¤Ÿä¿æŒå›¾åƒç»†èŠ‚ä¸Žé¢œè‰²ã€‚ EOTF/OETF HLG 1234567891011121314151617181920212223242526272829float ARIB_B67_A = 0.17883277;float ARIB_B67_B = 0.28466892;float ARIB_B67_C = 0.55991073;highp float arib_b67_inverse_oetf(highp float x)&#123; x = max(x, 0.0); if (x &lt;= (1.0/2.0)) x = (x * x) * (1.0 / 3.0); else x = (exp((x - ARIB_B67_C) / ARIB_B67_A) + ARIB_B67_B) / 12.0; return x;&#125;highp float arib_b67_ootf(highp float x)&#123; return x &lt; 0.0 ? x : pow(x, 1.2);&#125;highp float arib_b67_eotf(highp float x)&#123; return arib_b67_ootf(arib_b67_inverse_oetf(x));&#125;highp float arib_b67_oetf(highp float x)&#123; x = max(x, 0.0); if (x &lt;= (1.0 / 12.0)) x = sqrt(3.0 * x); else x = ARIB_B67_A * log(12.0 * x - ARIB_B67_B) + ARIB_B67_C; return x;&#125; PQ 12345678910111213highp float ST2084_M1 = 0.1593017578125;const float ST2084_M2 = 78.84375;const float ST2084_C1 = 0.8359375;const float ST2084_C2 = 18.8515625;const float ST2084_C3 = 18.6875;highp float FLT_MIN = 1.17549435082228750797e-38;highp float st_2084_eotf(highp float x)&#123; highp float xpow = pow(x, float(1.0 / ST2084_M2)); highp float num = max(xpow - ST2084_C1, 0.0); highp float den = max(ST2084_C2 - ST2084_C3 * xpow, FLT_MIN); return pow(num/den, 1.0 / ST2084_M1);&#125; BT.709 1234567891011const float REC709_ALPHA = 1.09929682680944;const float REC709_BETA = 0.018053968510807;highp float rec_709_oetf(highp float x)&#123; x = max(x, 0.0); if (x &lt; REC709_BETA ) x = x * 4.5; else x = REC709_ALPHA * pow(x, 0.45) - (REC709_ALPHA - 1.0); return x;&#125; bt2020 -&gt; bt709 1231.6605, -0.5876, -0.0728-0.1246, 1.1329, -0.0083-0.0182, -0.1006, 1.1187 bt709 -&gt; bt2020 1230.6274, 0.3293, 0.04330.0691, 0.9195, 0.01140.0164, 0.0880, 0.8956 Matrix coefficientsYCbCr-&gt;RGB Video Range 1234567891011121314151617181920// BT.601, which is the standard for SDTV.static const GLfloat kColorConversion601[] = &#123; 1.164, 1.164, 1.164, 0.0, -0.392, 2.017, 1.596, -0.813, 0.0,&#125;;// BT.709, which is the standard for HDTV.static const GLfloat kColorConversion709[] = &#123; 1.164, 1.164, 1.164, 0.0, -0.213, 2.112, 1.793, -0.533, 0.0,&#125;;// BT.2020 (which is the standard for UHDTV, ITU_R_2020 )static const GLfloat kColorConversion2020[] = &#123; 1.1644f, 1.1644f, 1.1644f, 0.0f, -0.1881, 2.1501, 1.6853, -0.6529, 0.0f,&#125;; Full Range 1234567891011121314151617181920// BT.601 full range static const GLfloat kColorConversion601FullRange[] = &#123;1.0, 1.0, 1.0,0.0, -0.343, 1.765,1.4, -0.711, 0.0,&#125;;// BT.709 full range static const GLfloat kColorConversion709FullRange[] = &#123;1.0, 1.0, 1.0,0.0, -0.187, 1.855,1.574, -0.468, 0.0,&#125;;// BT.2020 full range static const GLfloat kColorConversion2020FullRange[] = &#123;1.0, 1.0, 1.0,0.0, -0.1645, 1.8814,1.4746, -0.5713, 0.0,&#125;; OpenGL Video Range 1234567891011121314151617precision mediump float; varying mediump vec2 textureCoordinate; uniform sampler2D luminanceTexture; uniform sampler2D chrominanceTexture; uniform highp mat3 colorConversionMatrix; void main() &#123; mediump vec3 yuv; highp vec3 rgb; yuv.x = texture2D(luminanceTexture, textureCoordinate).r - (16.0/255.0); yuv.yz = texture2D(chrominanceTexture, textureCoordinate).ra - vec2(0.5, 0.5); rgb = colorConversionMatrix * yuv; gl_FragColor = vec4(rgb, 1.); &#125; Full Range 12345678910111213141516precision mediump float; varying mediump vec2 textureCoordinate; uniform sampler2D luminanceTexture; uniform sampler2D chrominanceTexture; uniform highp mat3 colorConversionMatrix; void main() &#123; mediump vec3 yuv; highp vec3 rgb; yuv.x = texture2D(luminanceTexture, textureCoordinate).r; yuv.yz = texture2D(chrominanceTexture, textureCoordinate).ra - vec2(0.5, 0.5); rgb = colorConversionMatrix * yuv; gl_FragColor = vec4(rgb, 1.); &#125; RGB-YUV123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687// FULL RANGE static void bt2020_rgb2yuv10bit_PC(uint8_t R, uint8_t G, uint8_t B, uint16_t &amp;Y, uint16_t &amp;U, uint16_t &amp;V) &#123; Y = 0.2627 * R + 0.6780 * G + 0.0593 * B; U = -0.1396 * R - 0.3604 * G + 0.5000 * B + 128; V = 0.5000 * R - 0.4598 * G - 0.0402 * B + 128; Y = Y &lt;&lt; 8; U = U &lt;&lt; 8; V = V &lt;&lt; 8; &#125; // VIDEO RANGE static void bt2020_rgb2yuv10bit_TV(uint8_t R, uint8_t G, uint8_t B, uint16_t &amp;Y, uint16_t &amp;U, uint16_t &amp;V) &#123; Y = 0.2256 * R + 0.5823 * G + 0.0509 * B + 16; U = -0.1222 * R - 0.3154 * G + 0.4375 * B + 128; V = 0.4375 * R - 0.4023 * G - 0.0352 * B + 128; /// 8 åˆ†è§£ä¸º2 + 6 /// &lt;&lt;2 ï¼šå¯¹åº” æŠŠ yuv ä»Ž (luma=[16,235] chroma=[16,240]) æ‹‰åˆ° (luma=[64,940] chroma=[64,960]) /// &lt;&lt;6 ï¼š10bit æŒ‰å­—èŠ‚ä¸ºå•ä½éœ€è¦ä¸¤ä¸ªå­—èŠ‚ï¼Œå› ä¸ºæŒ‰ç…§å¤§ç«¯æ¨¡å¼å­˜å‚¨ï¼ˆä½Žåœ°å€åˆ°é«˜åœ°å€çš„é¡ºåºå­˜æ”¾æ•°æ®çš„é«˜ä½å­—èŠ‚åˆ°ä½Žä½å­—èŠ‚ï¼‰åŽé¢6ä¸ªbitæ˜¯padding è¡¥0 Y = Y &lt;&lt; 8; U = U &lt;&lt; 8; V = V &lt;&lt; 8; &#125; // FULL RANGE static void bt709_rgb2yuv10bit_PC(uint8_t R, uint8_t G, uint8_t B, uint16_t &amp;Y, uint16_t &amp;U, uint16_t &amp;V) &#123; Y = 0.2126 * R + 0.7152 * G + 0.0722 * B; U = -0.1146 * R - 0.3854 * G + 0.5000 * B + 128; V = 0.5000 * R - 0.4542 * G - 0.0458 * B + 128; Y = Y &lt;&lt; 8; U = U &lt;&lt; 8; V = V &lt;&lt; 8; &#125; // VIDEO RANGE static void bt709_rgb2yuv10bit_TV(uint8_t R, uint8_t G, uint8_t B, uint16_t &amp;Y, uint16_t &amp;U, uint16_t &amp;V) &#123; Y = 0.183 * R + 0.614 * G + 0.062 * B + 16; U = -0.101 * R - 0.339 * G + 0.439 * B + 128; V = 0.439 * R - 0.399 * G - 0.040 * B + 128; Y = Y &lt;&lt; 8; U = U &lt;&lt; 8; V = V &lt;&lt; 8; &#125; // FULL RANGE static void bt601_rgb2yuv10bit_PC(uint8_t R, uint8_t G, uint8_t B, uint16_t &amp;Y, uint16_t &amp;U, uint16_t &amp;V) &#123; Y = 0.299 * R + 0.587 * G + 0.114 * B; U = -0.169 * R - 0.331 * G + 0.500 * B + 128; V = 0.500 * R - 0.419 * G - 0.081 * B + 128; Y = Y &lt;&lt; 8; U = U &lt;&lt; 8; V = V &lt;&lt; 8; &#125; // VIDEO RANGE static void bt601_rgb2yuv10bit_TV(uint8_t R, uint8_t G, uint8_t B, uint16_t &amp;Y, uint16_t &amp;U, uint16_t &amp;V) &#123; Y = 0.257 * R + 0.504 * G + 0.098 * B + 16; U = -0.148 * R - 0.291 * G + 0.439 * B + 128; V = 0.439 * R - 0.368 * G - 0.071 * B + 128; Y = Y &lt;&lt; 8; U = U &lt;&lt; 8; V = V &lt;&lt; 8; &#125; // FULL RANGE static void bt601_rgb2yuv_PC(uint8_t R, uint8_t G, uint8_t B, uint8_t &amp;Y, uint8_t &amp;U, uint8_t &amp;V) &#123; Y = 0.299 * R + 0.587 * G + 0.114 * B; U = -0.169 * R - 0.331 * G + 0.500 * B + 128; V = 0.500 * R - 0.419 * G - 0.081 * B + 128; &#125; // VIDEO RANGE static void bt601_rgb2yuv_TV(uint8_t R, uint8_t G, uint8_t B, uint8_t &amp;Y, uint8_t &amp;U, uint8_t &amp;V) &#123; Y = 0.257 * R + 0.504 * G + 0.098 * B + 16; U = -0.148 * R - 0.291 * G + 0.439 * B + 128; V = 0.439 * R - 0.368 * G - 0.071 * B + 128; &#125; 12345678910111213141516171819202122inline CFDictionaryRef HDRAttachmentsOfMedium(void) &#123; const size_t attributes_size = 6; CFTypeRef keys[attributes_size] = &#123; kCVImageBufferFieldCountKey, kCVImageBufferChromaLocationBottomFieldKey, kCVImageBufferChromaLocationTopFieldKey, kCVImageBufferTransferFunctionKey, kCVImageBufferColorPrimariesKey, kCVImageBufferYCbCrMatrixKey &#125;; CFTypeRef values[attributes_size] = &#123; kCFBooleanTrue, kCVImageBufferChromaLocation_Left, kCVImageBufferChromaLocation_Left, kCVImageBufferTransferFunction_ITU_R_2100_HLG, kCVImageBufferColorPrimaries_ITU_R_2020, kCVImageBufferYCbCrMatrix_ITU_R_2020 &#125;; return CreateCFDictionary(keys, values, attributes_size); &#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495CVPixelBufferRef RGB2YCbCr10Bit(CVPixelBufferRef pixelBuffer, CFDictionaryRef dic) &#123; CVPixelBufferLockBaseAddress(pixelBuffer, 0); uint8_t *baseAddress = (uint8_t *)CVPixelBufferGetBaseAddress(pixelBuffer); int w = (int) CVPixelBufferGetWidth(pixelBuffer); int h = (int) CVPixelBufferGetHeight(pixelBuffer); //int stride = (int) CVPixelBufferGetBytesPerRow(pixelBuffer) / 4; OSType pixelFormat = kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange; CVPixelBufferRef pixelBufferCopy = NULL; const size_t attributes_size = 5; CFTypeRef keys[attributes_size] = &#123; kCVPixelBufferIOSurfacePropertiesKey, kCVPixelBufferExtendedPixelsBottomKey, kCVPixelBufferExtendedPixelsTopKey, kCVPixelBufferExtendedPixelsRightKey, kCVPixelBufferExtendedPixelsLeftKey &#125;; CFDictionaryRef io_surface_value = vtc::CreateCFDictionary(nullptr, nullptr, 0); CFTypeRef values[attributes_size] = &#123;io_surface_value, kCFBooleanFalse, kCFBooleanFalse, kCFBooleanFalse, kCFBooleanFalse&#125;; CFDictionaryRef attributes = vtc::CreateCFDictionary(keys, values, attributes_size); CVReturn status = CVPixelBufferCreate(kCFAllocatorDefault, w, h, pixelFormat, attributes, &amp;pixelBufferCopy); if (status != kCVReturnSuccess) &#123; std::cout &lt;&lt; "YUVBufferCopyWithPixelBuffer :: failed" &lt;&lt; std::endl; return nullptr; &#125; if (attributes) &#123; CFRelease(attributes); attributes = nullptr; &#125; int plane_h1 = (int) CVPixelBufferGetHeightOfPlane(pixelBufferCopy, 0); int plane_h2 = (int) CVPixelBufferGetHeightOfPlane(pixelBufferCopy, 1); CVPixelBufferLockBaseAddress(pixelBufferCopy, 0); if (dic == nullptr || CFDictionaryGetCount(dic) &lt;= 0) &#123; dic = HDRAttachmentsOfMedium(); &#125; CVBufferSetAttachments(pixelBufferCopy, dic, kCVAttachmentMode_ShouldPropagate); size_t y_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferCopy, 0); //size_t uv_stride = CVPixelBufferGetBytesPerRowOfPlane(pixelBufferCopy, 1); unsigned long y_bufferSize = w * h; unsigned long uv_bufferSize = w * h / 4; uint16_t *y_planeData = (uint16_t *) malloc(y_bufferSize * sizeof(uint16_t)); uint16_t *u_planeData = (uint16_t *) malloc(uv_bufferSize * sizeof(uint16_t)); uint16_t *v_planeData = (uint16_t *) malloc(uv_bufferSize * sizeof(uint16_t)); uint16_t *y = (uint16_t *) CVPixelBufferGetBaseAddressOfPlane(pixelBufferCopy, 0); uint16_t *uv = (uint16_t *) CVPixelBufferGetBaseAddressOfPlane(pixelBufferCopy, 1); int u_offset = 0; int v_offset = 0; uint8_t R, G, B; uint16_t Y, U, V; for (int i = 0; i &lt; h; i ++) &#123; for (int j = 0; j &lt; w; j ++) &#123; int offset = i * w + j; B = baseAddress[offset * 4]; G = baseAddress[offset * 4 + 1]; R = baseAddress[offset * 4 + 2]; bt2020_rgb2yuv10bit_TV(R, G, B, Y, U, V); y_planeData[offset] = Y; //éš”è¡Œæ‰«æ å¶æ•°è¡Œçš„å¶æ•°åˆ—å–U å¥‡æ•°è¡Œçš„å¶æ•°åˆ—å–V if (j % 2 == 0) &#123; (i % 2 == 0) ? u_planeData[++u_offset] = U : v_planeData[++v_offset] = V; &#125; &#125; &#125; for (int i = 0; i &lt; plane_h1; i ++) &#123; memcpy(y + i * y_stride / 2, y_planeData + i * w, 2 * w); if (i &lt; plane_h2) &#123; for (int j = 0 ; j &lt; w ; j ++) &#123; //NV12 å’Œ NV21 æ ¼å¼éƒ½å±žäºŽ YUV420SP ç±»åž‹ã€‚å®ƒä¹Ÿæ˜¯å…ˆå­˜å‚¨äº† Y åˆ†é‡ï¼Œä½†æŽ¥ä¸‹æ¥å¹¶ä¸æ˜¯å†å­˜å‚¨æ‰€æœ‰çš„ U æˆ–è€… V åˆ†é‡ï¼Œè€Œæ˜¯æŠŠ UV åˆ†é‡äº¤æ›¿è¿žç»­å­˜å‚¨ã€‚ //NV12 æ˜¯ IOS ä¸­æœ‰çš„æ¨¡å¼ï¼Œå®ƒçš„å­˜å‚¨é¡ºåºæ˜¯å…ˆå­˜ Y åˆ†é‡ï¼Œå† UV è¿›è¡Œäº¤æ›¿å­˜å‚¨ã€‚ memcpy(uv + i * y_stride / 2 + 2*j, u_planeData + i * w/2 + j, 2); memcpy(uv + i * y_stride / 2 + 2*j + 1, v_planeData + i * w/2 + j, 2); &#125; &#125; &#125; free(y_planeData); free(u_planeData); free(v_planeData); CVPixelBufferUnlockBaseAddress(pixelBuffer, 0); CVPixelBufferUnlockBaseAddress(pixelBufferCopy, 0); return pixelBufferCopy; &#125; Formula BT.601 BT.709 BT.2020 a 0.299 0.2126 0.2627 b 0.587 0.7152 0.6780 c 0.114 0.0722 0.0593 d 1.772 1.8556 1.8814 e 1.402 1.5748 1.4747 123Y = a * R + b * G + c * BCb = (B - Y) / dCr = (R - Y) / e 123R = Y + e * CrG = Y - (a * e / b) * Cr - (c * d / b) * CbB = Y + d * Cb 123a+b+c = 1e = 2 * (1 - a)d = 2* (a + b) https://www.itu.int/rec/R-REC-BT.601 https://www.itu.int/rec/R-REC-BT.709 https://www.itu.int/rec/R-REC-BT.2020 Range Deduce1234567891011121314[16/255, 16/255, 16/255, 1.0][235/255, 240/255, 240/255, 1.0]x[255/219, 0, 0, 0][0, 255/224, 0, 0][0, 0, 255/224, 0][-16/219, -128/224, -128/224, 1]=[0, -0.5, -0.5, 1.0][1, 0.5, 0.5, 1.0] å°† videorange é€šè¿‡ é½æ¬¡çŸ©é˜µ è½¬æ¢ä¸º fullrange Otherå¤§éƒ¨åˆ†å›¾åƒæ•æ‰è®¾å¤‡åœ¨ä¿å­˜å›¾åƒæ—¶ä¼šè‡ªåŠ¨åŠ ä¸Šä¼½é©¬æ ¡æ­£ï¼Œä¹Ÿå°±æ˜¯è¯´å›¾åƒä¸­å­˜å‚¨çš„æ˜¯éžçº¿æ€§ç©ºé—´ä¸­çš„é¢œè‰² éžçº¿æ€§çš„RGBè½¬æ¢ä¸ºYUVä¹Ÿæ˜¯éžçº¿æ€§ OpenGL æ— æ³•ç›´æŽ¥å¯¹ 10bit YUV è¿›è¡Œå¤„ç†ï¼Œéœ€è¦å…ˆè½¬æ¢ä¸º 8bit YUV tone mapping éœ€è¦åœ¨çº¿æ€§RGBç©ºé—´è¿›è¡Œ Referencesæžæ¸…æ¥šç¼–ç¨‹ä¸­YUVå’ŒRGBé—´çš„ç›¸äº’è½¬æ¢YUV - RGB colorconversionæŽ¨å¯¼è§†é¢‘YUVè½¬RGBçŸ©é˜µé½æ¬¡åæ ‡# Gammaæ ¡æ­£# æˆ‘ç†è§£çš„ä¼½é©¬æ ¡æ­£Colour gamut conversion from Recommendation ITU-R BT.2020 to Recommendation ITU-R BT.709Colour conversion from Recommendation ITU-R BT.709 to Recommendation ITU-R BT.2020]]></content>
      <categories>
        <category>HDR</category>
      </categories>
      <tags>
        <tag>YUV</tag>
        <tag>HDR</tag>
        <tag>OPENGL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[coreimage with metal ç¬”è®°]]></title>
    <url>%2F2022%2F08%2F08%2Fcoreimage-with-metal-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[xcodeè¿‘æœŸæœ‰è‡ªå®šä¹‰CoreImageçš„CIFilterçš„éœ€æ±‚ï¼Œå‰æœŸé€šè¿‡CIKL å®šä¹‰ CIKernelå®Œæˆäº†ä»»åŠ¡ï¼ŒåŽé¢äº†è§£åˆ°CoreImageæ–°ç‰¹æ€§æ”¯æŒmetalçš„æ–¹å¼ç›´æŽ¥è‡ªå®šä¹‰ CIKernelï¼Œæé«˜æ•ˆçŽ‡ã€‚ CIKLçš„æ–¹å¼ï¼Œå­˜åœ¨ä¸¤ä¸ªé—®é¢˜ï¼š ç¼–å†™ kernel çš„æ—¶å€™ï¼Œæ²¡æœ‰æŠ¥é”™æç¤ºï¼Œå“ªæ€•æ˜¯å‚æ•°åé”™è¯¯éƒ½æ— æ³•æ£€æŸ¥å¤„ç†ã€‚æ•ˆçŽ‡æžä½Žã€‚ ç¿»è¯‘è½¬æ¢ï¼Œç¼–è¯‘ï¼Œéƒ½æ˜¯å‘ç”Ÿåˆ°è¿è¡Œæ—¶ï¼Œå¯¼è‡´ç¬¬ä¸€æ¬¡ä½¿ç”¨æ»¤é•œçš„æ—¶å€™ï¼Œè€—æ—¶è¾ƒä¹…ã€‚ Metal: åœ¨buildé˜¶æ®µ å°±å¯ä»¥ç¼–è¯‘ é“¾æŽ¥ .metalæ–‡ä»¶ å‚è€ƒè‹¹æžœçš„å®˜æ–¹æ–‡æ¡£ Metal Shading Language for CoreImage Kernels ,åœ¨xcode integration éƒ¨åˆ†æåˆ°åœ¨build setting è®¾ç½® Other Metal Compiler Flags, æ–‡æ¡£å·²ç»å¾ˆè€äº†ï¼ˆ2018å¹´çš„ï¼‰ï¼Œæ–°ç‰ˆçš„xcodeå·²ç»æ²¡æœ‰è¿™ä¸ªé€‰é¡¹äº†ï¼Œå¦‚æžœä¸åšå¤„ç†ï¼Œä¼šæœ‰æŠ¥é”™ &quot;/air-lld:1:1: symbol(s) not found for target &#39;air64-apple-ios12.0.0&#39;&quot; and &quot;air-lld command failed with exit code 1 (use -v to see invocation)&quot; build rulesæ–°ç‰ˆxcodeä¸­å¯ä»¥é€šè¿‡é…ç½®build rulesè§£å†³ä¸Šé¢çš„æŠ¥é”™ *.metal 1xcrun metal -c $MTL_HEADER_SEARCH_PATHS -fcikernel &quot;$&#123;INPUT_FILE_PATH&#125;&quot; -o &quot;$&#123;SCRIPT_OUTPUT_FILE_0&#125;&quot; output files : $(METAL_LIBRARY_OUTPUT_DIR)/$(INPUT_FILE_BASE).metallib *.air 1xcrun metallib -cikernel &quot;$&#123;INPUT_FILE_PATH&#125;&quot; -o &quot;$&#123;SCRIPT_OUTPUT_FILE_0&#125;&quot; output files : $(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).air å¦‚å›¾ï¼š cocoapodsbuild rules çš„æ–¹å¼å­˜åœ¨ä¸€ä¸ªé—®é¢˜ï¼Œå¦‚æžœmetal shaderæ–‡ä»¶åœ¨podåº“ä¸­ï¼Œåœ¨ä¸»å·¥ç¨‹ä»Žé…ç½®build rulesæ— æ³•é’ˆå¯¹podä¸­çš„resouce ç”Ÿæ•ˆï¼Œè™½ç„¶å¯ä»¥æ‰‹åŠ¨é’ˆå¯¹pod target é…ç½®build rulesè§£å†³é—®é¢˜ï¼Œä½†æ˜¯è¿™æ ·é…ç½®æ˜¯ä¸€æ¬¡æ€§çš„ï¼Œæ— æ³•æäº¤ä¿å­˜ï¼Œä¸‹ä¸€æ¬¡pod updateå°±æ¸…ç©ºäº†ï¼Œæ‰€ä»¥åˆ°äº†è¿™é‡Œå°±å¾ˆè‡ªç„¶çš„èƒ½æƒ³åˆ°é€šè¿‡pod çš„post hook æ¥è§£å†³é—®é¢˜ï¼ŒæŽ¥ä¸‹æ¥å°±æ˜¯æ€Žä¹ˆç”¨ruby æ¥å†™ pod hook è„šæœ¬äº† é€šè¿‡ä¹‹å‰åœ¨ä¸»å·¥ç¨‹é…ç½®build rules, å¯ä»¥çœ‹åˆ°project.pbxprojæ–‡ä»¶çš„å˜æ›´æƒ…å†µ 123456789101112131415161718192021222324252627282930/* Begin PBXBuildRule section */ BF25E98B28A0A91A00188AE3 /* PBXBuildRule */ = &#123; isa = PBXBuildRule; compilerSpec = com.apple.compilers.proxy.script; filePatterns = &quot;*.metal&quot;; fileType = pattern.proxy; inputFiles = ( ); isEditable = 1; outputFiles = ( &quot;$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).air&quot;, ); runOncePerArchitecture = 0; script = &quot;# Type a script or drag a script file from your workspace to insert its path.\nxcrun metal -c $MTL_HEADER_SEARCH_PATHS -fcikernel \&quot;$&#123;INPUT_FILE_PATH&#125;\&quot; -o \&quot;$&#123;SCRIPT_OUTPUT_FILE_0&#125;\&quot;\n&quot;; &#125;; BF25E98C28A0A92200188AE3 /* PBXBuildRule */ = &#123; isa = PBXBuildRule; compilerSpec = com.apple.compilers.proxy.script; filePatterns = &quot;*.air&quot;; fileType = pattern.proxy; inputFiles = ( ); isEditable = 1; outputFiles = ( &quot;$(METAL_LIBRARY_OUTPUT_DIR)/$(INPUT_FILE_BASE).metallib&quot;, ); runOncePerArchitecture = 0; script = &quot;# Type a script or drag a script file from your workspace to insert its path.\nxcrun metallib -cikernel \&quot;$&#123;INPUT_FILE_PATH&#125;\&quot; -o \&quot;$&#123;SCRIPT_OUTPUT_FILE_0&#125;\&quot;\n&quot;; &#125;;/* End PBXBuildRule section */ å“ˆå“ˆ ï¼Œè¿™æ­£æ˜¯æˆ‘ä»¬éœ€è¦çš„build ruleçš„å­—æ®µ æœ€ç»ˆçš„ MetalBuildRule.rb æ–‡ä»¶å¦‚ä¸‹ ï¼š 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/ruby# -*- coding: UTF-8 -*-def add_build_rule(target_name, project) project.targets.each do |target| if target.name == target_name# puts "#&#123;target.name&#125; has #&#123;target.build_rules.count&#125; build rule." if target.build_rules.count &gt;= 2 puts "#&#123;target.name&#125; already has 2 build rule." return end puts "Updating #&#123;target.name&#125; build rules" metal_rule = project.new(Xcodeproj::Project::Object::PBXBuildRule) metal_rule.name = 'Metal Build Rule' metal_rule.compiler_spec = 'com.apple.compilers.proxy.script' metal_rule.file_patterns = '*.metal' metal_rule.file_type = 'pattern.proxy' metal_rule.is_editable = '1' metal_rule.run_once_per_architecture = '0' metal_rule.output_files = ["$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).air"] metal_rule.input_files = [] metal_rule.output_files_compiler_flags = [] metal_rule.script = "xcrun metal -c $MTL_HEADER_SEARCH_PATHS -fcikernel \"$&#123;INPUT_FILE_PATH&#125;\" -o \"$&#123;SCRIPT_OUTPUT_FILE_0&#125;\"" target.build_rules.append(metal_rule) air_rule = project.new(Xcodeproj::Project::Object::PBXBuildRule) air_rule.name = 'Air Build Rule' air_rule.compiler_spec = 'com.apple.compilers.proxy.script' air_rule.file_patterns = '*.air' air_rule.file_type = 'pattern.proxy' air_rule.is_editable = '1' air_rule.run_once_per_architecture = '0' air_rule.output_files = ["$(METAL_LIBRARY_OUTPUT_DIR)/$(INPUT_FILE_BASE).metallib"] air_rule.input_files = [] air_rule.output_files_compiler_flags = [] air_rule.script = "xcrun metallib -cikernel \"$&#123;INPUT_FILE_PATH&#125;\" -o \"$&#123;SCRIPT_OUTPUT_FILE_0&#125;\"" target.build_rules.append(air_rule) project.objects_by_uuid[metal_rule.uuid] = metal_rule project.objects_by_uuid[air_rule.uuid] = air_rule project.save() end endend podfile æ–‡ä»¶é‡ŒåŠ è½½ MetalBuildRule.rb, é…ç½®hook 123post_install do |installer| add_build_rule("your-target-name", installer.pods_project)end frameworkå¦‚æžœpodåº“æ˜¯é€šè¿‡cocoapods-packageræ’ä»¶ æ‰“.a æˆ–è€… .frameworkçš„æ–¹å¼æä¾›ç»™ä¸»å·¥ç¨‹ä½¿ç”¨çš„è¯ï¼Œå‘çŽ°è¿˜æ˜¯ä¼šé‡åˆ°ä¸Šæ–‡æåˆ°çš„é”™è¯¯ &quot;/air-lld:1:1: symbol(s) not found for target &#39;air64-apple-ios12.0.0&#39;&quot; and &quot;air-lld command failed with exit code 1 (use -v to see invocation)&quot; è¿™é‡Œéœ€è¦ç®€å•äº†è§£ä¸‹ cocoapods-packager çš„åŽŸç†ï¼Œæµ…æž Cocoapods-Packager å®žçŽ°.å› ä¸º cocoapods-packager ä¼šé‡æ–°ç”Ÿæˆä¸€ä¸ªpodfile æ¥æž„é€ ä¸€ä¸ªæ‰“åŒ…ç”¨çš„å·¥ç¨‹ï¼Œæ‰€ä»¥è¿™ä¸ªé”™è¯¯çš„å‡ºçŽ°è·Ÿæ–‡ç« æœ€å¼€å§‹æåˆ°çš„æƒ…å†µæ˜¯ä¸€æ¨¡ä¸€æ ·çš„ï¼Œè§£æ³•æ˜¯ä¸æ˜¯ä¹Ÿå¯ä»¥é€šè¿‡é…ç½®build ruleæ¥è§£å‘¢ï¼Œä¸è¿‡æ‰“åŒ…å·¥ç¨‹æˆ‘ä»¬çœ‹èµ·æ¥å¥½åƒæ— æ³•å¹²é¢„ï¼Œæ€Žä¹ˆè§£å‘¢ï¼Ÿ è¿˜æ˜¯è¦å›žåˆ°cocoapods-packageræ’ä»¶æ¥è§£å†³é—®é¢˜ã€‚ 1https://github.com/CocoaPods/cocoapods-packager git ä»£ç æ‹‰ä¸‹æ¥ é€šè¿‡ide(vscode/rubymine) æ‰“å¼€æ’ä»¶å·¥ç¨‹ é…ç½®å¥½å·¥ç¨‹rubyçŽ¯å¢ƒ DEBUG ä»£ç ï¼Œæ‰¾åˆ°å¹²é¢„ç‚¹ è®¾ç½®build rule ç”Ÿæˆpackager gemï¼Œå®‰è£… è¿™é‡Œæ¶‰åŠåˆ°ruby gem bundleç­‰rubyçŽ¯å¢ƒçš„åŸºæœ¬å‘½ä»¤/ç”¨æ³•ï¼Œå¯ä»¥è‡ªè¡Œgoogleä¸€ä¸‹ã€‚ é€šè¿‡åˆšåˆšæåˆ°çš„æ’ä»¶åŽŸç†ï¼Œå¾ˆå®¹æ˜“æ‰¾åˆ°å¹²é¢„ç‚¹ 1234pod_utils.rbdef install_pod(platform_name, sandbox)...end ä¿®æ”¹ï¼š 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172def install_pod(platform_name, sandbox) # åˆ¤æ–­resource_bundle æ˜¯å¦æœ‰.metalæ–‡ä»¶ metal = false if @spec.attributes_hash["resource_bundle"] metal = @spec.attributes_hash["resource_bundle"][@spec.name].include?("metal") end if @spec.attributes_hash["resource_bundles"] if @spec.attributes_hash["resource_bundles"][@spec.name] @spec.attributes_hash["resource_bundles"][@spec.name].each &#123; |res| metal ||= res.include?("metal") &#125; end end ... unless static_installer.nil? static_installer.pods_project.targets.each do |target| # å¦‚æžœæœ‰.metalæ–‡ä»¶ &amp;&amp; targetåŒ¹é… -&gt; è®¾ç½® build rule if metal &amp;&amp; target.name.start_with?(@spec.name) UI.puts "#&#123;target.name&#125; has #&#123;target.build_rules.count&#125; build rule." if target.build_rules.count &gt;= 2 UI.puts "#&#123;target.name&#125; already has 2 build rule." return end metal_rule = static_installer.pods_project.new(Xcodeproj::Project::Object::PBXBuildRule) UI.puts "Updating #&#123;target.name&#125; rules" metal_rule.name = 'Metal Build Rule' metal_rule.compiler_spec = 'com.apple.compilers.proxy.script' metal_rule.file_patterns = '*.metal' metal_rule.file_type = 'pattern.proxy' metal_rule.is_editable = '1' metal_rule.run_once_per_architecture = '0' metal_rule.output_files = ["$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).air"] metal_rule.input_files = [] metal_rule.output_files_compiler_flags = [] metal_rule.script = "xcrun metal -c $MTL_HEADER_SEARCH_PATHS -fcikernel \"$&#123;INPUT_FILE_PATH&#125;\" -o \"$&#123;SCRIPT_OUTPUT_FILE_0&#125;\"" target.build_rules.append(metal_rule) air_rule = static_installer.pods_project.new(Xcodeproj::Project::Object::PBXBuildRule) UI.puts "Updating #&#123;target.name&#125; rules" air_rule.name = 'Air Build Rule' air_rule.compiler_spec = 'com.apple.compilers.proxy.script' air_rule.file_patterns = '*.air' air_rule.file_type = 'pattern.proxy' air_rule.is_editable = '1' air_rule.run_once_per_architecture = '0' air_rule.output_files = ["$(METAL_LIBRARY_OUTPUT_DIR)/$(INPUT_FILE_BASE).metallib"] air_rule.input_files = [] air_rule.output_files_compiler_flags = [] air_rule.script = "xcrun metallib -cikernel \"$&#123;INPUT_FILE_PATH&#125;\" -o \"$&#123;SCRIPT_OUTPUT_FILE_0&#125;\"" target.build_rules.append(air_rule) static_installer.pods_project.objects_by_uuid[metal_rule.uuid] = metal_rule static_installer.pods_project.objects_by_uuid[air_rule.uuid] = air_rule static_installer.pods_project.save end ... end ... end ... end æœ€åŽé‡æ–°ç”Ÿæˆã€å®‰è£…gem 12345#!/bin/bashgem uninstall cocoapods-packagergem build cocoapods-packager.gemspecgem install cocoapods-packager podfileä½¿ç”¨è‡ªå®šä¹‰çš„cocoapods-packageræ‰“å‡ºæ¥çš„äºŒæ–¹åº“ FrameworkåŒ…ï¼ŒåŒ…å†…å®¹é‡Œé¢å·²ç»æ›¿æ¢æˆxxx.metallibæ–‡ä»¶äº†,æ‰€ä»¥ä¸»å·¥ç¨‹çš„podfile pod post hook è¦æ ¹æ®äºŒæ–¹åº“çš„æŽ¥å…¥æ–¹å¼åšä¸‹å¤„ç†ã€‚ æˆ‘è¿™è¾¹ä¸»å·¥ç¨‹æ˜¯ç”¨è¿‡cocoapod-binaryæ’ä»¶ç®¡ç†äºŒæ–¹åº“çš„åŠ å…¥ï¼Œæºç &amp;é™æ€Frameworkï¼Œä¸€èˆ¬Releaseæ¨¡å¼æå‡ç¼–è¯‘é€Ÿåº¦ï¼Œéƒ½æ˜¯ä»¥frameworkæ–¹å¼ï¼ŒDebugæ¨¡å¼æœ‰æ—¶å€™éœ€è¦åœ¨ä¸»å·¥ç¨‹DebugäºŒæ–¹åº“ï¼Œå¯ä»¥é€‰æ‹©æ˜¯æºç æ–¹å¼æŽ¥å…¥ã€‚ æœ€ç»ˆçš„é€»è¾‘å¦‚ä¸‹ï¼š 1234567891011121314151617post_install do |installer| installer.pods_project.targets.each do |target| ... target.build_configurations.each do |config| ... #Release model, no need execute if config.name != 'Release' &amp;&amp; target.name == 'your target name' puts "===================&gt; #&#123;config.name&#125;" eval(File.open('MetalBuildRule.rb').read) if File.exist? 'MetalBuildRule.rb' # metal shader build rule add_build_rule(target, installer.pods_project) end end endend DONE referencesMetalCIKLReferenceAdd custom build rule with Podfile post_install hookxcodeprojxcodeå·¥ç¨‹æ–‡ä»¶è§£æžCocoaPodsæºç ä¸Žæ’ä»¶æ–­ç‚¹è°ƒè¯•]]></content>
      <categories>
        <category>metal</category>
      </categories>
      <tags>
        <tag>metal</tag>
        <tag>coreimage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter 1.17å…±äº«engine]]></title>
    <url>%2F2020%2F06%2F03%2Fflutter-1-17%E5%85%B1%E4%BA%ABengine%2F</url>
    <content type="text"><![CDATA[å‰è¨€flutter å‡çº§åˆ° 1.17ä¹‹åŽï¼Œapp ios çº¿ä¸Šé‡åˆ°ä¸€ä¸ªcrash ,é€šè¿‡å®˜æ–¹çš„ ç¬¦å·è¡¨æ–‡ä»¶ flutter.dsym è¿˜åŽŸå‡ºå †æ ˆå¦‚ä¸‹ 1234560 auto fml::internal::CopyableLambda&lt;flutter::Shell::OnPlatformViewCreated(std::__1::unique_ptr&lt;flutter::Surface, std::__1::default_delete&lt;flutter::Surface&gt; &gt;)::$_8&gt;::operator()&lt;&gt;() const (in Flutter) (make_copyable.h:24)1 auto fml::internal::CopyableLambda&lt;flutter::Shell::OnPlatformViewCreated(std::__1::unique_ptr&lt;flutter::Surface, std::__1::default_delete&lt;flutter::Surface&gt; &gt;)::$_8&gt;::operator()&lt;&gt;() const (in Flutter) (make_copyable.h:24)2 fml::MessageLoopImpl::FlushTasks(fml::FlushType) (in Flutter) (message_loop_impl.cc:129)3 fml::MessageLoopDarwin::OnTimerFire(__CFRunLoopTimer*, fml::MessageLoopDarwin*) (in Flutter) (message_loop_darwin.mm:76)9 fml::MessageLoopDarwin::Run() (in Flutter) (message_loop_darwin.mm:47)10 void* std::__1::__thread_proxy&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, fml::Thread::Thread(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;)::$_0&gt; &gt;(void*) (in Flutter) (thread:352) è¿™é‡Œè¿˜åªèƒ½çœ‹åˆ°crashåœ¨engineçš„c++ä»£ç ä¸­ï¼Œå…·ä½“åŽŸå› æœªçŸ¥ å®šä½æˆ‘ä»¬æ ¹æ®crash ç”¨æˆ·çš„ åŸ‹ç‚¹æ—¥å¿— åˆ†æžcrashå‰çš„ ä½¿ç”¨è·¯å¾„ï¼ŒåŸºæœ¬éƒ½æ˜¯æ‰“å¼€push è½åœ°åˆ°ä¸€ä¸ªflutteré¡µé¢app çš„ ç¬¬ä¸€ä¸ªtab ä¹Ÿæ˜¯ä¸ª flutter é¡µé¢ï¼Œæ‰€ä»¥æ˜¯push å”¤èµ·appï¼Œè¿žç»­æ‰“å¼€ä¸¤ä¸ªflutteré¡µé¢ã€‚æ‰‹åŠ¨æ‰“å¼€appï¼Œç‚¹å‡»è¿›åˆ°flutteré¡µé¢æ˜¯ä¸ä¼šcrashçš„ï¼ˆè¿™ä¹ˆç®€å•çš„è·¯å¾„ï¼Œå¦‚æžœcrashï¼Œé‚£å°±è¯¥æ­»äº†ï¼‰å¾ˆå¿«æˆ‘ä»¬å°±å¯ä»¥é€šè¿‡è¿™ä¸ª è·¯å¾„ å¤çŽ° crash ï¼Œèƒ½å¤çŽ°å°±å¥½è¯´ã€‚ debug engineæºç ï¼Œå¯ä»¥å®šä½åˆ°æ›´å…·ä½“çš„åœ°æ–¹ surface_ ä¸º null ï¼ŒEXC_BAD_ACCESS é‡ŽæŒ‡é’ˆ åˆ†æžå®šä½åˆ°äº†å…·ä½“çš„ä»£ç ä½ç½®ï¼ŒæŽ¥ä¸‹æ¥åˆ†æžä¸‹é‡ŽæŒ‡é’ˆçš„åŽŸå› xcodeä¸­ crash çš„æ—¶å€™ï¼Œçœ‹åˆ°ä¸»çº¿ç¨‹çš„ å †æ ˆè®°å½• æ˜¯ä»Ž application çš„ didbecomeactive çš„ notificationå‘èµ·çš„ç”±äºŽæ˜¯ push å”¤èµ·app ï¼Œæœ‰è¿™ä¸ªé€šçŸ¥æ˜¯å¯¹çš„ï¼Œcrash æ˜¯åœ¨ å…±äº«engine çš„ raster çº¿ç¨‹ã€‚ çœ‹ä»£ç  1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#pragma mark - Application lifecycle notifications// app çš„ é¦–é¡µ flutter é¡µé¢ä¼š æ‰§è¡Œ surfaceUpdated æ–¹æ³•- (void)applicationBecameActive:(NSNotification*)notification &#123; TRACE_EVENT0("flutter", "applicationBecameActive"); if (_viewportMetrics.physical_width) [self surfaceUpdated:YES]; [self goToApplicationLifecycle:@"AppLifecycleState.resumed"];&#125;#pragma mark - Surface creation and teardown updates- (void)surfaceUpdated:(BOOL)appeared &#123; // NotifyCreated/NotifyDestroyed are synchronous and require hops between the UI and raster // thread. if (appeared) &#123; [self installFirstFrameCallback]; [_engine.get() platformViewsController] -&gt; SetFlutterView(_flutterView.get()); [_engine.get() platformViewsController] -&gt; SetFlutterViewController(self); // è¿™é‡Œ [_engine.get() platformView] -&gt; NotifyCreated(); &#125; else &#123; self.displayingFlutterUI = NO; [_engine.get() platformView] -&gt; NotifyDestroyed(); [_engine.get() platformViewsController] -&gt; SetFlutterView(nullptr); [_engine.get() platformViewsController] -&gt; SetFlutterViewController(nullptr); &#125;&#125;void PlatformView::NotifyCreated() &#123; std::unique_ptr&lt;Surface&gt; surface; // Threading: We want to use the platform view on the non-platform thread. // Using the weak pointer is illegal. But, we are going to introduce a latch // so that the platform view is not collected till the surface is obtained. auto* platform_view = this; fml::ManualResetWaitableEvent latch; fml::TaskRunner::RunNowOrPostTask( task_runners_.GetRasterTaskRunner(), [platform_view, &amp;surface, &amp;latch]() &#123; surface = platform_view-&gt;CreateRenderingSurface(); latch.Signal(); &#125;); latch.Wait(); //è¿™é‡Œ delegate_.OnPlatformViewCreated(std::move(surface));&#125;// |PlatformView::Delegate|void Shell::OnPlatformViewCreated(std::unique_ptr&lt;Surface&gt; surface) &#123; TRACE_EVENT0("flutter", "Shell::OnPlatformViewCreated"); FML_DCHECK(is_setup_); FML_DCHECK(task_runners_.GetPlatformTaskRunner()-&gt;RunsTasksOnCurrentThread()); // Note: // This is a synchronous operation because certain platforms depend on // setup/suspension of all activities that may be interacting with the GPU in // a synchronous fashion. fml::AutoResetWaitableEvent latch; auto raster_task = fml::MakeCopyable([&amp; waiting_for_first_frame = waiting_for_first_frame_, rasterizer = rasterizer_-&gt;GetWeakPtr(), // surface = std::move(surface), // &amp;latch]() mutable &#123; if (rasterizer) &#123; //è¿™é‡Œ rasterizer-&gt;Setup(std::move(surface)); &#125; waiting_for_first_frame.store(true); // Step 3: All done. Signal the latch that the platform thread is // waiting on. latch.Signal(); &#125;); ... &#125;void Rasterizer::Setup(std::unique_ptr&lt;Surface&gt; surface) &#123; surface_ = std::move(surface); if (max_cache_bytes_.has_value()) &#123; SetResourceCacheMaxBytes(max_cache_bytes_.value(), user_override_resource_cache_bytes_); &#125; compositor_context_-&gt;OnGrContextCreated(); // surface_ nullï¼ŒBAD_ACCESS if (surface_-&gt;GetExternalViewEmbedder()) &#123; const auto platform_id = task_runners_.GetPlatformTaskRunner()-&gt;GetTaskQueueId(); const auto gpu_id = task_runners_.GetRasterTaskRunner()-&gt;GetTaskQueueId(); raster_thread_merger_ = fml::MakeRefCounted&lt;fml::RasterThreadMerger&gt;(platform_id, gpu_id); &#125;&#125; è¿™ä¹ˆä¸€è·¯çœ‹ä¸‹æ¥ï¼Œsurface_æ€Žä¹ˆä¼šå˜æˆnullå‘¢ï¼Ÿä¸€èˆ¬æƒ…å†µæ˜¯ï¼Œæ‰§è¡Œ [self surfaceUpdated:NO] çš„æ—¶å€™ä¼šé”€æ¯surfaceï¼Œæ–­ç‚¹æ ¹æœ¬éƒ½æ²¡è¿›åŽ»ã€‚ç»§ç»­çœ‹ä»£ç  123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// push è½åœ°é¡µ flutter é¡µé¢ init çš„æ—¶å€™ï¼Œä¼šé‡æ–°attach åˆ° engineï¼Œä¼šæ‰§è¡ŒsetViewControlleræ–¹æ³•- (void)setViewController:(FlutterViewController*)viewController &#123; FML_DCHECK(self.iosPlatformView); _viewController = viewController ? [viewController getWeakPtr] : fml::WeakPtr&lt;FlutterViewController&gt;(); //è¿™é‡Œ self.iosPlatformView-&gt;SetOwnerViewController(_viewController); [self maybeSetupPlatformViewChannels]; if (viewController) &#123; __block FlutterEngine* blockSelf = self; self.flutterViewControllerWillDeallocObserver = [[NSNotificationCenter defaultCenter] addObserverForName:FlutterViewControllerWillDealloc object:viewController queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification* note) &#123; [blockSelf notifyViewControllerDeallocated]; &#125;]; &#125; else &#123; self.flutterViewControllerWillDeallocObserver = nil; &#125;&#125;void PlatformViewIOS::SetOwnerViewController(fml::WeakPtr&lt;FlutterViewController&gt; owner_controller) &#123; FML_DCHECK(task_runners_.GetPlatformTaskRunner()-&gt;RunsTasksOnCurrentThread()); std::lock_guard&lt;std::mutex&gt; guard(ios_surface_mutex_); // é‡ç‚¹æ˜¯è¿™é‡Œ if (ios_surface_ || !owner_controller) &#123; // è¿™é‡Œä¼šé”€æ¯ NotifyDestroyed(); ios_surface_.reset(); accessibility_bridge_.reset(); &#125; owner_controller_ = owner_controller; // Add an observer that will clear out the owner_controller_ ivar and // the accessibility_bridge_ in case the view controller is deleted. dealloc_view_controller_observer_.reset( [[[NSNotificationCenter defaultCenter] addObserverForName:FlutterViewControllerWillDealloc object:owner_controller_.get() queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification* note) &#123; // Implicit copy of 'this' is fine. accessibility_bridge_.reset(); owner_controller_.reset(); &#125;] retain]); if (owner_controller_ &amp;&amp; [owner_controller_.get() isViewLoaded]) &#123; this-&gt;attachView(); &#125; // Do not call `NotifyCreated()` here - let FlutterViewController take care // of that when its Viewport is sized. If `NotifyCreated()` is called here, // it can occasionally get invoked before the viewport is sized resulting in // a framebuffer that will not be able to completely attach.&#125;void PlatformView::NotifyDestroyed() &#123; delegate_.OnPlatformViewDestroyed();&#125;// |PlatformView::Delegate|void Shell::OnPlatformViewDestroyed() &#123; TRACE_EVENT0("flutter", "Shell::OnPlatformViewDestroyed"); FML_DCHECK(is_setup_); FML_DCHECK(task_runners_.GetPlatformTaskRunner()-&gt;RunsTasksOnCurrentThread()); // Note: // This is a synchronous operation because certain platforms depend on // setup/suspension of all activities that may be interacting with the GPU in // a synchronous fashion. fml::AutoResetWaitableEvent latch; auto io_task = [io_manager = io_manager_.get(), &amp;latch]() &#123; // Execute any pending Skia object deletions while GPU access is still // allowed. io_manager-&gt;GetIsGpuDisabledSyncSwitch()-&gt;Execute( fml::SyncSwitch::Handlers().SetIfFalse( [&amp;] &#123; io_manager-&gt;GetSkiaUnrefQueue()-&gt;Drain(); &#125;)); // Step 3: All done. Signal the latch that the platform thread is waiting // on. latch.Signal(); &#125;; auto raster_task = [rasterizer = rasterizer_-&gt;GetWeakPtr(), io_task_runner = task_runners_.GetIOTaskRunner(), io_task]() &#123; if (rasterizer) &#123; // è¿™é‡Œ rasterizer-&gt;Teardown(); &#125; // Step 2: Next, tell the IO thread to complete its remaining work. fml::TaskRunner::RunNowOrPostTask(io_task_runner, io_task); &#125;; ...void Rasterizer::Teardown() &#123; compositor_context_-&gt;OnGrContextDestroyed(); // è¿™é‡Œ reset surface_.reset(); last_layer_tree_.reset();&#125; æ‰€ä»¥åŽŸå›  å°±æ˜¯ è½åœ°é¡µ init çš„æ—¶å€™ é‡æ–°attach å¼•æ“Žï¼ŒNotifyDestroyed æ–¹æ³• æœ€ç»ˆä¼šé”€æ¯ surfaceï¼Œè¿™æ—¶å€™æ­£å¥½rasterçº¿ç¨‹ä½¿ç”¨ surface_åšæ–¹æ³•è°ƒç”¨ã€‚ ä¿®å¤å®šä½åˆ°åŽŸå› ï¼Œä¿®å¤å°±ç®€å•äº†ï¼Œåšä¸‹ç©ºåˆ¤æ–­å°±å¥½äº†,å¦‚æžœä¸ºç©º å°±ç›´æŽ¥return 123456789101112131415161718192021void Rasterizer::Setup(std::unique_ptr&lt;Surface&gt; surface) &#123; surface_ = std::move(surface); if (!surface_) &#123; FML_DLOG(INFO) &lt;&lt; "Rasterizer::Setup called with no surface."; return; &#125; if (max_cache_bytes_.has_value()) &#123; SetResourceCacheMaxBytes(max_cache_bytes_.value(), user_override_resource_cache_bytes_); &#125; compositor_context_-&gt;OnGrContextCreated(); if (surface_-&gt;GetExternalViewEmbedder()) &#123; const auto platform_id = task_runners_.GetPlatformTaskRunner()-&gt;GetTaskQueueId(); const auto gpu_id = task_runners_.GetRasterTaskRunner()-&gt;GetTaskQueueId(); raster_thread_merger_ = fml::MakeRefCounted&lt;fml::RasterThreadMerger&gt;(platform_id, gpu_id); &#125;&#125; è¿™é‡Œæ˜¯ç›´æŽ¥ä¿®æ”¹äº†å¼•æ“Žçš„ä»£ç ï¼Œæ‰€ä»¥éœ€è¦é‡æ–°ç¼–è¯‘engine äº§ç‰©ï¼Œæ›¿æ¢æŽ‰å°±æžå®šäº† å…¶ä»–1.17ä¹‹å‰çš„ç‰ˆæœ¬ 1.12.13 çš„æ—¶å€™ï¼Œä¸ç¡®å®šengineå­˜ä¸å­˜åœ¨è¿™ä¸ªé—®é¢˜ï¼Œæœ‰ç©ºå†çœ‹çœ‹ã€‚åŽé¢githubæissueã€PRï¼Œçœ‹çœ‹å®˜æ–¹æ€Žä¹ˆçœ‹å¾…è¿™ä¸ªé—®é¢˜ï¼Œä¿®å¤åº”è¯¥è¿˜æœ‰å…¶ä»–åŠžæ³•ã€‚]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter 1.17å‡çº§]]></title>
    <url>%2F2020%2F05%2F21%2Fflutter-1-17%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[å‡çº§æœ€è¿‘å®˜æ–¹å‘å¸ƒäº†flutter ç¨³å®šç‰ˆæœ¬1.17.0 ï¼Œè®°å½•ä¸‹å‡çº§1.17 iosä¸Šç¢°åˆ°çš„çš„é—®é¢˜ Appäº§ç‰©åœ¨ 1.12.13 çš„æ—¶å€™ï¼Œä¸ºäº†æ”¯æŒæ¨¡æ‹Ÿå™¨è¿è¡Œï¼Œä¼šè¿›è¡Œ debug äº§ç‰© è·Ÿ release äº§ç‰©çš„merge ï¼ˆlipo create â€¦ï¼‰debug äº§ç‰© x86 ã€release äº§ç‰© arm64 arm7 å‡çº§åˆ°1.17.0 ä¹‹åŽ ï¼ŒmergeæŠ¥é”™ lipo æŸ¥çœ‹ä¸‹ å‘çŽ°é’ˆå¯¹æ¨¡æ‹Ÿå™¨çš„debugäº§ç‰© å«æœ‰arm64 Debug Flutter toolæºç ï¼Œ build é‡Œé¢è¿›è¡Œäº†ä¸¤æ¬¡createStubAppFrameworkï¼ˆiphone &amp;&amp; simulatorï¼‰ç„¶åŽåšäº†mergeï¼Œå®žé™…ä¸Šenvironmentå‚æ•°é‡Œé¢ iosArchsåªæœ‰ arch x86ï¼Œæ‰€ä»¥é—®é¢˜å‡ºåœ¨è¿™é‡Œ DebugUniveralFramework1234567891011121314151617181920212223242526272829303132333435363738394041@overrideFuture&lt;void&gt; build(Environment environment) async &#123; // Generate a trivial App.framework. final Set&lt;DarwinArch&gt; iosArchs = environment.defines[kIosArchs] ?.split(' ') ?.map(getIOSArchForName) ?.toSet() ?? &lt;DarwinArch&gt;&#123;DarwinArch.arm64&#125;; final File iphoneFile = environment.buildDir.childFile('iphone_framework'); final File simulatorFile = environment.buildDir.childFile('simulator_framework'); final File lipoOutputFile = environment.buildDir.childFile('App'); final RunResult iphoneResult = await createStubAppFramework( iphoneFile, SdkType.iPhone, // Only include 32bit if it is contained in the active architectures. include32Bit: iosArchs.contains(DarwinArch.armv7) ); final RunResult simulatorResult = await createStubAppFramework( simulatorFile, SdkType.iPhoneSimulator, ); if (iphoneResult.exitCode != 0 || simulatorResult.exitCode != 0) &#123; throw Exception('Failed to create App.framework.'); &#125; final List&lt;String&gt; lipoCommand = &lt;String&gt;[ 'xcrun', 'lipo', '-create', iphoneFile.path, simulatorFile.path, '-output', lipoOutputFile.path ]; final RunResult lipoResult = await processUtils.run( lipoCommand, ); if (lipoResult.exitCode != 0) &#123; throw Exception('Failed to create App.framework.'); &#125;&#125; è§£å†³åŠžæ³• å¯ä»¥é€šè¿‡archs åˆ¤æ–­ä¸‹å…·ä½“æ‰§è¡Œ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@override Future&lt;void&gt; build(Environment environment) async &#123; // Generate a trivial App.framework. final Set&lt;DarwinArch&gt; iosArchs = environment.defines[kIosArchs] ?.split(' ') ?.map(getIOSArchForName) ?.toSet() ?? &lt;DarwinArch&gt;&#123;DarwinArch.arm64&#125;; final File iphoneFile = environment.buildDir.childFile('iphone_framework'); final File simulatorFile = environment.buildDir.childFile('simulator_framework'); final File lipoOutputFile = environment.buildDir.childFile('App'); RunResult iphoneResult; if(iosArchs.contains(DarwinArch.arm64) || iosArchs.contains(DarwinArch.armv7)) &#123; iphoneResult = await createStubAppFramework( iphoneFile, SdkType.iPhone, // Only include 32bit if it is contained in the active architectures. include32Bit: iosArchs.contains(DarwinArch.armv7) ); if (iphoneResult.exitCode != 0) &#123; throw Exception('(iphoneResult)Failed to create App.framework.'); &#125; &#125; RunResult simulatorResult; if(iosArchs.contains(DarwinArch.x86_64)) &#123; simulatorResult = await createStubAppFramework( simulatorFile, SdkType.iPhoneSimulator, ); if (simulatorResult.exitCode != 0) &#123; throw Exception('(simulatorResult)Failed to create App.framework.'); &#125; &#125; if(simulatorResult == null) &#123; iphoneFile.copySync(lipoOutputFile.path); return; &#125; if(iphoneResult == null) &#123; simulatorFile.copySync(lipoOutputFile.path); return; &#125; final List&lt;String&gt; lipoCommand = &lt;String&gt;[ 'xcrun', 'lipo', '-create', iphoneFile.path, simulatorFile.path, '-output', lipoOutputFile.path ]; final RunResult lipoResult = await processUtils.run( lipoCommand, ); if (lipoResult.exitCode != 0) &#123; throw Exception('Failed to create App.framework.'); &#125; &#125; çªç„¶æƒ³åˆ° æ—¢ç„¶1.17 å¯¹debug äº§ç‰©åšäº†arm64çš„æ”¯æŒï¼Œé‚£æˆ‘ä»¬æ”¶é›†äº§ç‰©æ˜¯ä¸æ˜¯å¯ä»¥ä¸ç”¨è‡ªå·±åšmergeï¼Œå‘çŽ°æ˜¯ä¸å¯ä»¥çš„å› ä¸ºé™¤äº†App.framework,è¿˜æœ‰plugin nativeä»£ç ç”Ÿæˆçš„podé™æ€åº“ libxxx.aã€‚é™æ€åº“ æ˜¯å“ªé‡Œç”Ÿæˆçš„å‘¢ï¼Ÿ è¿™é‡Œ build_ios.dart -&gt; buildXcodeProject 123456789101112131415161718...final List&lt;String&gt; buildCommands = &lt;String&gt;[ &apos;/usr/bin/env&apos;, &apos;xcrun&apos;, &apos;xcodebuild&apos;, &apos;-configuration&apos;, configuration,]; ...if (buildForDevice) &#123; buildCommands.addAll(&lt;String&gt;[&apos;-sdk&apos;, &apos;iphoneos&apos;]);&#125; else &#123; buildCommands.addAll(&lt;String&gt;[&apos;-sdk&apos;, &apos;iphonesimulator&apos;, &apos;-arch&apos;, &apos;x86_64&apos;]);&#125;... è¿™é‡Œåªé’ˆå¯¹x86åšäº†xcode buildï¼Œæ‰€ä»¥è¿˜æ˜¯è¦è‡ªå·±mergeçš„â€¦]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter tool debug]]></title>
    <url>%2F2020%2F03%2F13%2Fflutter-tool-debug%2F</url>
    <content type="text"><![CDATA[Flutterflutter å¼€å‘è¿‡ç¨‹ä¸­ï¼Œå°‘ä¸äº†ä¼šè¿è¡Œä¸€äº› flutter å‘½ä»¤ ï¼Œæ¯”å¦‚ flutter build xxx ã€ flutter run ç­‰ç­‰çœ‹ä¸‹ bin/flutter è„šæœ¬ï¼ŒèƒŒåŽéƒ½æ˜¯ flutter_tool åœ¨æ‰§è¡Œå„ç§æ“ä½œã€‚ 12345678FLUTTER_TOOLS_DIR="$FLUTTER_ROOT/packages/flutter_tools"SNAPSHOT_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.snapshot"STAMP_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.stamp"SCRIPT_PATH="$FLUTTER_TOOLS_DIR/bin/flutter_tools.dart"DART_SDK_PATH="$FLUTTER_ROOT/bin/cache/dart-sdk""$DART" --packages="$FLUTTER_TOOLS_DIR/.packages" $FLUTTER_TOOL_ARGS "$SNAPSHOT_PATH" "$@" å…³äºŽ debug flutter_tool,å°±ä¸è¯´çš„äº†ï¼Œè‡ªè¡Œgoogleä¸€ä¸‹ã€‚ã€‚ è¿™é‡Œè®°å½•ä¸‹ debug è¿‡ç¨‹ä¸­é‡åˆ°çš„é—®é¢˜ ExceptionæŒ‡å®šç«¯å£å¯¼å‡ºFLUTTER_TOOL_ARGS çŽ¯å¢ƒå˜é‡ export FLUTTER_TOOL_ARGS=&quot;--pause_isolates_on_start --enable-vm-service:65432&quot; run èµ·æ¥ ä¼šåœåœ¨è¿™é‡Œâ€¦ Observatory listening on http://127.0.0.1:65432/ZbWg3veM6kY=/ IDE ä¸­æ‰“å¼€flutter tool é¡¹ç›®ï¼Œé…ç½® dart remote debug attach å‡ºçŽ°ä»¥ä¸‹é”™è¯¯ä¿¡æ¯ 123Failed to connect to the VM observatory service: java.io.IOException: Failed to connect: ws://127.0.0.1:65432/wsCaused by: de.roderick.weberknecht.WebSocketException: error while creating socket to ws://127.0.0.1:65432/wsCaused by: java.net.ConnectException: Connection refused (Connection refused) åŽŸå›  ï¼š http://127.0.0.1:65432/ZbWg3veM6kY=/ åŽé¢å¤šäº†ä¸ªZbWg3veM6kYï¼Œè¿™æ˜¯ä¸€ç§è®¤è¯ç ï¼Œæ˜¯ä¸ºäº†å®‰å…¨åŽŸå› ï¼Œé˜²æ­¢åº”ç”¨è¢«è¿œç¨‹è°ƒè¯•ã€‚å¯ä»¥é€šè¿‡å‚æ•°â€“disable-service-auth-codesè¿›è¡Œå…³é—­ã€‚ export FLUTTER_TOOL_ARGS=&quot;--pause_isolates_on_start --enable-vm-service:65432 --disable-service-auth-codes&quot;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutterå…±äº«engine]]></title>
    <url>%2F2020%2F03%2F10%2Fflutter%E5%85%B1%E4%BA%ABengine%2F</url>
    <content type="text"><![CDATA[flutter å…±äº«å¼•æ“Ž é—®é¢˜è®°å½•å…±äº«å¼•æ“Žï¼Œå°±æ˜¯åªæœ‰ä¸€ä¸ª flutter engineï¼Œæ¯ä¸ªé¡µé¢ä¸€ä¸ª flutterviewcontrollerã€‚flutteré¡µé¢ åˆ‡æ¢ï¼Œå¼•æ“Žä¼šç›¸åº”çš„ detach atach æœ€è¿‘ å‡çº§ flutter åˆ° v1.12.13 ç‰ˆæœ¬åŽï¼Œè´¡çŒ®å¼•æ“Žé‡åˆ°çš„å‡ ä¸ªé—®é¢˜ è®°å½•ä¸‹ present flutter é¡µé¢è¿™ä¸ªå…¶å®žä¸æ˜¯v1.12.13å‡ºçŽ°çš„é—®é¢˜ flutterPageA present flutterPageB ä¼š å‡ºçŽ° pageAçš„ viewDidDisappear æ¯” pageBçš„ viewDidAppear åŽæ‰§è¡Œ 12345678910- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; //å¤„ç†ä¸‹present é¡µé¢å¡æ­»çš„æƒ…å†µ if ([WD_FLUTTER_ENGINE flutterViewController] != self) &#123; [WD_FLUTTER_ENGINE resume]; [(WDFlutterViewContainer *)[WD_FLUTTER_ENGINE flutterViewController] surfaceUpdated:YES]; &#125; else &#123; [WD_FLUTTER_ENGINE detach]; &#125;&#125; ä»Žflutter è¿”å›žåˆ° nativeé¡µé¢åœ¨ v.1.12.13ä¹‹å‰ flutter popto native æ— éœ€å¤„ç†v.1.12.13 å‡ºçŽ°crash 123456789101112131415161718192021222324[VERBOSE-2:FlutterObservatoryPublisher.mm(131)] Could not register as server for FlutterObservatoryPublisher. Check your network settings and relaunch the application.SCNetworkReachabilitySetDispatchQueue() failed: Invalid argumentSCNetworkReachabilitySetDispatchQueue() failed: Invalid argumentlocalConnectionInitializedStatus:2localConnectionInitializedStatus:2SCNetworkReachabilitySetDispatchQueue() failed: Invalid argument[Bugly] Fatal signal(11) raised.[Bugly] Trapped fatal signal &apos;SIGSEGV(11)&apos; ( &quot;0 Flutter 0x000000010516f92c _ZNK3fml8internal14CopyableLambdaIZN7flutter5Shell21OnPlatformViewCreatedENSt3__110unique_ptrINS2_7SurfaceENS4_14default_deleteIS6_EEEEE3$_8EclIJEEEDaDpOT_ + 236&quot;, &quot;1 Flutter 0x000000010516f928 _ZNK3fml8internal14CopyableLambdaIZN7flutter5Shell21OnPlatformViewCreatedENSt3__110unique_ptrINS2_7SurfaceENS4_14default_deleteIS6_EEEEE3$_8EclIJEEEDaDpOT_ + 232&quot;, &quot;2 Flutter 0x0000000105123cf4 _ZN3fml15MessageLoopImpl10FlushTasksENS_9FlushTypeE + 1700&quot;, &quot;3 Flutter 0x0000000105126000 _ZN3fml17MessageLoopDarwin11OnTimerFireEP16__CFRunLoopTimerPS0_ + 32&quot;, &quot;4 CoreFoundation 0x0000000184cd3aa8 0x0000000184be5000 + 977576&quot;, &quot;5 CoreFoundation 0x0000000184cd376c 0x0000000184be5000 + 976748&quot;, &quot;6 CoreFoundation 0x0000000184cd3010 0x0000000184be5000 + 974864&quot;, &quot;7 CoreFoundation 0x0000000184cd0b60 0x0000000184be5000 + 965472&quot;, &quot;8 CoreFoundation 0x0000000184bf0da8 CFRunLoopRunSpecific + 552&quot;, &quot;9 Flutter 0x0000000105125edc _ZN3fml17MessageLoopDarwin3RunEv + 88&quot;, &quot;10 Flutter 0x0000000105125684 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3fml6ThreadC1ERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEE3$_0EEEEEPvSJ_ + 200&quot;, &quot;11 libsystem_pthread.dylib 0x0000000184951220 0x000000018494f000 + 8736&quot;, &quot;12 libsystem_pthread.dylib 0x0000000184951110 0x000000018494f000 + 8464&quot;)Application finished. å¤„ç†åŠžæ³•ï¼š flutterVc dealloc æˆ–è€… disappear çš„æ—¶å€™ æ‰§è¡Œ flutterEngine detach]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter engine å®šåˆ¶]]></title>
    <url>%2F2020%2F03%2F05%2Fflutter-engine-%E5%AE%9A%E5%88%B6%2F</url>
    <content type="text"><![CDATA[â€¦ä½¿ç”¨Flutterå¼€å‘çš„æ—¶å€™æœ€ç›´æŽ¥æŽ¥è§¦çš„å¹¶ä¸æ˜¯ Flutter Engine è€Œæ˜¯ Flutter Framework(https://github.com/flutter/flutter)åœ¨flutter framework çš„ ç›®å½•é‡Œé¢ æœ‰ç¼–è¯‘å¥½çš„engine äº§ç‰© ç®€å•è¯´å°±æ˜¯ï¼Œ ç¼–è¯‘å¼•æ“Ž æ›¿æ¢ äº§ç‰©æ–‡ä»¶å°±å¥½äº† è·¯å¾„ flutter_path/bin/cache/artifacts/engine/ios å‚è€ƒFlutter Engineå®šåˆ¶æµç¨‹Flutter Engine ç¼–è¯‘æŒ‡åŒ—]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter eventChannel crash on ios]]></title>
    <url>%2F2019%2F10%2F21%2Fflutter-eventChannel-crash-on-ios%2F</url>
    <content type="text"><![CDATA[flutter issuecrash è®°å½•ä¸€æ¬¡å›°æ‰°äº†å¾ˆä¹…çš„ flutter event channel crash EventChannel dart1234567891011121314151617181920212223242526272829303132333435363738394041Stream&lt;dynamic&gt; receiveBroadcastStream([ dynamic arguments ]) &#123; final MethodChannel methodChannel = MethodChannel(name, codec); StreamController&lt;dynamic&gt; controller; controller = StreamController&lt;dynamic&gt;.broadcast(onListen: () async &#123; defaultBinaryMessenger.setMessageHandler(name, (ByteData reply) async &#123; if (reply == null) &#123; controller.close(); &#125; else &#123; try &#123; controller.add(codec.decodeEnvelope(reply)); &#125; on PlatformException catch (e) &#123; controller.addError(e); &#125; &#125; return null; &#125;); try &#123; await methodChannel.invokeMethod&lt;void&gt;('listen', arguments); &#125; catch (exception, stack) &#123; FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: stack, library: 'services library', context: ErrorDescription('while activating platform stream on channel $name'), )); &#125; &#125;, onCancel: () async &#123; defaultBinaryMessenger.setMessageHandler(name, null); try &#123; await methodChannel.invokeMethod&lt;void&gt;('cancel', arguments); &#125; catch (exception, stack) &#123; FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: stack, library: 'services library', context: ErrorDescription('while de-activating platform stream on channel $name'), )); &#125; &#125;); return controller.stream; &#125; FlutterChannel.mm1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static void SetStreamHandlerMessageHandlerOnChannel(NSObject&lt;FlutterStreamHandler&gt;* handler, NSString* name, NSObject&lt;FlutterBinaryMessenger&gt;* messenger, NSObject&lt;FlutterMethodCodec&gt;* codec) &#123; __block FlutterEventSink currentSink = nil; FlutterBinaryMessageHandler messageHandler = ^(NSData* message, FlutterBinaryReply callback) &#123; FlutterMethodCall* call = [codec decodeMethodCall:message]; if ([call.method isEqual:@"listen"]) &#123; if (currentSink) &#123; FlutterError* error = [handler onCancelWithArguments:nil]; if (error) NSLog(@"Failed to cancel existing stream: %@. %@ (%@)", error.code, error.message, error.details); &#125; currentSink = ^(id event) &#123; if (event == FlutterEndOfEventStream) [messenger sendOnChannel:name message:nil]; else if ([event isKindOfClass:[FlutterError class]]) [messenger sendOnChannel:name message:[codec encodeErrorEnvelope:(FlutterError*)event]]; else [messenger sendOnChannel:name message:[codec encodeSuccessEnvelope:event]]; &#125;; FlutterError* error = [handler onListenWithArguments:call.arguments eventSink:currentSink]; if (error) callback([codec encodeErrorEnvelope:error]); else callback([codec encodeSuccessEnvelope:nil]); &#125; else if ([call.method isEqual:@"cancel"]) &#123; if (!currentSink) &#123; callback( [codec encodeErrorEnvelope:[FlutterError errorWithCode:@"error" message:@"No active stream to cancel" details:nil]]); return; &#125; currentSink = nil; FlutterError* error = [handler onCancelWithArguments:call.arguments]; if (error) callback([codec encodeErrorEnvelope:error]); else callback([codec encodeSuccessEnvelope:nil]); &#125; else &#123; callback(nil); &#125; &#125;; [messenger setMessageHandlerOnChannel:name binaryMessageHandler:messageHandler];&#125; EventSinkæ­£å¸¸ç»“æŸstreamæµ eventSink(FlutterEndOfEventStream) ï¼Œå¼‚å¸¸ç»“æŸstreamæµ eventSink(FlutterError) éƒ½ä¼šå›žè°ƒæ‰§è¡Œ onCancel å‚è€ƒFlutter ä¸Ž Native(iOS) é€šä¿¡åŽŸç†æ·±å…¥FlutteræŠ€æœ¯å†…å¹•:Platform Channelè®¾è®¡ä¸Žå®žçŽ°]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter ios 13 dark mode]]></title>
    <url>%2F2019%2F10%2F14%2Fflutter-ios-13-dark-mode%2F</url>
    <content type="text"><![CDATA[å‰è¨€ios 13 å¼€å¯ dark model,flutteré¡µé¢status baræ–‡å­—ä¸€ç›´æ˜¯ç™½è‰² flutter issues 1SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle.dark); è®¾ç½®dark style å¹¶æ²¡æœ‰ç”¨ SystemChrome12345678910111213141516171819202122232425static void setSystemUIOverlayStyle(SystemUiOverlayStyle style) &#123; assert(style != null); if (_pendingStyle != null) &#123; // The microtask has already been queued; just update the pending value. _pendingStyle = style; return; &#125; if (style == _latestStyle) &#123; // Trivial success: no microtask has been queued and the given style is // already in effect, so no need to queue a microtask. return; &#125; _pendingStyle = style; scheduleMicrotask(() &#123; assert(_pendingStyle != null); if (_pendingStyle != _latestStyle) &#123; SystemChannels.platform.invokeMethod&lt;void&gt;( 'SystemChrome.setSystemUIOverlayStyle', _pendingStyle._toMap(), ); _latestStyle = _pendingStyle; &#125; _pendingStyle = null; &#125;); &#125; FlutterPlatformPlugin1234567891011121314151617181920212223242526272829- (void)setSystemChromeSystemUIOverlayStyle:(NSDictionary*)message &#123; NSString* style = message[@"statusBarBrightness"]; if (style == (id)[NSNull null]) return; UIStatusBarStyle statusBarStyle; if ([style isEqualToString:@"Brightness.dark"]) statusBarStyle = UIStatusBarStyleLightContent; else if ([style isEqualToString:@"Brightness.light"]) statusBarStyle = UIStatusBarStyleDefault; else return; NSNumber* infoValue = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"UIViewControllerBasedStatusBarAppearance"]; Boolean delegateToViewController = (infoValue == nil || [infoValue boolValue]); if (delegateToViewController) &#123; // This notification is respected by the iOS embedder [[NSNotificationCenter defaultCenter] postNotificationName:@(kOverlayStyleUpdateNotificationName) object:nil userInfo:@&#123;@(kOverlayStyleUpdateNotificationKey) : @(statusBarStyle)&#125;]; &#125; else &#123; // Note: -[UIApplication setStatusBarStyle] is deprecated in iOS9 // in favor of delegating to the view controller [[UIApplication sharedApplication] setStatusBarStyle:statusBarStyle]; &#125;&#125; engine æºç ä¸­ å¯ä»¥çœ‹åˆ° æ²¡æœ‰ UIStatusBarStyleDarkContent å°è¯• åŽ»æŽ‰ info.plist ä¸­çš„ UIViewControllerBasedStatusBarAppearance ç„¶åŽ ç›‘å¬ é€šçŸ¥ 1234567[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appStatusBar:) name:@"io.flutter.plugin.platform.SystemChromeOverlayNotificationName" object:nil];- (void)appStatusBar:(id)notification &#123; if (@available(iOS 13.0, *)) &#123; [UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleDarkContent; &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustacheä¹‹dart]]></title>
    <url>%2F2019%2F05%2F31%2Fmustache%E4%B9%8Bdart%2F</url>
    <content type="text"><![CDATA[å‰è¨€Mustache æ˜¯ä¸€ä¸ª logic-less ï¼ˆè½»é€»è¾‘ï¼‰æ¨¡æ¿è§£æžå¼•æ“Žï¼Œå¯ä»¥åº”ç”¨åœ¨ jsã€PHPã€Pythonã€Perl ç­‰å¤šç§ç¼–ç¨‹è¯­è¨€ä¸­ã€‚è¿™é‡Œä¸»è¦æ˜¯çœ‹dartä¸­çš„åº”ç”¨ã€‚ æ¨¡æ¿è¯­æ³•å¾ˆç®€å• çœ‹è¿™é‡Œ1234567&#123;&#123;keyName&#125;&#125; &#123;&#123;#keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;&#123;&#123;^keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;&#123;&#123;.&#125;&#125;&#123;&#123;&gt;partials&#125;&#125;&#123;&#123;&#123;keyName&#125;&#125;&#125;&#123;&#123;!comments&#125;&#125; ä½¿ç”¨åœ¨flutteré¡¹ç›®ä¸­ï¼Œä½¿ç”¨annation routeræ³¨è§£çš„æ–¹å¼ç”Ÿæˆè·¯ç”±è¡¨ç®¡ç†ç±» RouterManager ï¼Œä»¥åŠä¸šåŠ¡ç›¸å…³çš„ç±»æ–‡ä»¶ï¼ˆios androidï¼‰åœ¨ä½¿ç”¨mustacheä¹‹å‰ï¼Œæ˜¯é€šè¿‡stringbuff çš„æ–¹å¼æ‹¼æŽ¥å­—ç¬¦ä¸²ï¼Œä¹Ÿå¯ä»¥å®Œæˆï¼Œä½†æ˜¯é˜…è¯»æ€§æ¯”è¾ƒå·®ã€‚ ä¹‹å‰123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// ç”Ÿæˆè·¯ç”±è¡¨ç±» StringBuffer sb = new StringBuffer(); sb..write(_createImport())..write(_createClazz(element.name)); return sb.toString();/// ç”Ÿæˆè·¯ç”±è¡¨ç±»çš„ import ä¿¡æ¯ String _createImport() &#123; StringBuffer sb = new StringBuffer(); sb ..writeln("import 'package:flutter/material.dart';") ..writeln("import 'package:hybrid_router/hybrid_router.dart';"); /// import page collector.importClazzList.forEach((clazz) &#123; sb.writeln("import '$clazz';"); &#125;); return sb.toString(); &#125; /// ç”Ÿæˆè·¯ç”±è¡¨ç±»çš„ clazz ä¿¡æ¯ String _createClazz(String className) &#123; StringBuffer sb = new StringBuffer(); /// start class sb.writeln("class \$$className &#123;"); /// generateRoute function sb ..writeln(" Map&lt;String, HybridWidgetBuilder&gt; generateRoutes()&#123;") ..writeln(" return &#123;"); collector.routeMap.forEach((key, value) &#123; String flutterPath = value.flutterPath; sb ..writeln(" '$flutterPath': (BuildContext context, Object args) &#123;") ..writeln(" $&#123;_createInstance(value)&#125;") ..writeln(" &#125;,"); &#125;); sb..writeln(" &#125;;")..writeln(" &#125;"); /// generateSpm function sb ..writeln(" Map&lt;String, String&gt; generateSpm() &#123;") ..writeln(" return &#123;"); collector.routeMap.forEach((key, value) &#123; String flutterSpm = value.flutterSpm; String flutterPath = value.flutterPath; if (flutterSpm?.isNotEmpty == true) &#123; sb.writeln(" '$flutterPath': '$flutterSpm',"); &#125; &#125;); sb..writeln(" &#125;;")..writeln(" &#125;"); /// end class sb.writeln("&#125;"); return sb.toString(); &#125; ä¹‹åŽ1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/// ç”Ÿæˆè·¯ç”±è¡¨ç±» _createRouteManager(element.name); String _createRouteManager(String className) &#123; return VDTemplate.routerManagerTemplate().renderString(&#123; 'classname':className, 'classes':collector.importClazzList, 'routes':collector.routeMap.values, 'createInstance':(LambdaContext ctx) &#123; CollectorItem item = ctx.lookup('.'); return _createInstance(item); &#125; &#125;); &#125; static Template routerManagerTemplate() &#123; var source = '''&#123;&#123;&gt; import&#125;&#125;&#123;&#123;&gt; clazz&#125;&#125; '''; Map&lt;String,Template&gt; map = &#123; "import":VDTemplate.importTemplate(), "clazz":VDTemplate.claszzTemplate() &#125;; return new Template(source,partialResolver: (String name) =&gt; map[name]); &#125; static Template importTemplate() &#123; var source = '''import 'package:flutter/material.dart';import 'package:hybrid_router/hybrid_router.dart';&#123;&#123;# classes &#125;&#125;import '&#123;&#123;&#123;.&#125;&#125;&#125;';&#123;&#123;/ classes &#125;&#125; '''; return new Template(source); &#125; static Template claszzTemplate() &#123; var source = '''class \$&#123;&#123;classname&#125;&#125; &#123; Map&lt;String, HybridWidgetBuilder&gt; generateRoutes()&#123; return &#123; &#123;&#123;#routes&#125;&#125; '&#123;&#123;flutterPath&#125;&#125;': (BuildContext context, Object args) &#123; &#123;&#123;createInstance&#125;&#125; &#125;, &#123;&#123;/routes&#125;&#125; &#125;; &#125; Map&lt;String, String&gt; generateSpm() &#123; return &#123; &#123;&#123;#routes&#125;&#125; &#123;&#123;# flutterSpm&#125;&#125; '&#123;&#123;flutterPath&#125;&#125;': '&#123;&#123;flutterSpm&#125;&#125;', &#123;&#123;/ flutterSpm&#125;&#125; &#123;&#123;/routes&#125;&#125; &#125;; &#125; &#125; '''; return new Template(source); &#125; å¯¹æ¯”çœ‹ä¸‹ï¼Œä½¿ç”¨mustacheä¹‹åŽï¼Œå¯è¯»æ€§å¥½å¾ˆå¤šï¼ŒåŸºæœ¬ä¿æŒäº†ä»£ç ç»“æž„ æ€»ç»“ å­—ç¬¦ä¸²æ•°ç»„ï¼Œå¯ä»¥ä½¿ç”¨{{.}} å¯¹è±¡æ•°æ®ï¼Œå¯ä»¥è·Ÿæ™®é€šçš„hashä¸€æ ·ï¼Œç›´æŽ¥ç”¨{{å¯¹è±¡çš„å±žæ€§}}ï¼Œmustacheå†…éƒ¨é€šè¿‡dartåå°„æ‹¿åˆ°å±žæ€§å€¼ ä½¿ç”¨partials æ‹†åˆ†template å¢žåŠ å¯è¯»æ€§ é€šè¿‡lambdaå‡½æ•°æ‰§è¡Œdartæ–¹æ³•ï¼Œä¹Ÿå¯ä»¥åšåˆ°æ‹†åˆ†çš„ä½œç”¨ lambdaContext.loopup(&quot;.&quot;) å¯ä»¥èŽ·å–å¯¹è±¡å®žä¾‹ï¼Œè¿›è€Œå¯ä»¥å‚æ•°ä¼ é€’ mustacheå†…éƒ¨renderstringä¹Ÿæ˜¯é€šè¿‡stringbuffçš„æ–¹å¼å®žçŽ° å‚è€ƒé“¾æŽ¥mustache 1.1.1Flutterè·¯ç”±ç®¡ç†]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>mustache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvmè°ƒä¼˜]]></title>
    <url>%2F2019%2F05%2F23%2Fjvm%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[jpsè¾“å‡ºJVMä¸­è¿è¡Œçš„è¿›ç¨‹çŠ¶æ€ä¿¡æ¯ 1234-q ä¸è¾“å‡ºç±»åã€Jaråå’Œä¼ å…¥mainæ–¹æ³•çš„å‚æ•°-m è¾“å‡ºä¼ å…¥mainæ–¹æ³•çš„å‚æ•°-l è¾“å‡ºmainç±»æˆ–Jarçš„å…¨é™å-v è¾“å‡ºä¼ å…¥JVMçš„å‚æ•° jps -mlvæ‰¾åˆ°javaåº”ç”¨çš„pid jstackæ ¹æ®javaåº”ç”¨pid ,æŸ¥çœ‹è¿›ç¨‹ä¸­çº¿ç¨‹å †æ ˆä¿¡æ¯ jstack pid topæ‰¾å‡ºè¯¥è¿›ç¨‹å†…æœ€è€—è´¹CPUçš„çº¿ç¨‹ top -Hp pid è½¬ä¸ºåå…­è¿›åˆ¶printf &quot;%x\n&quot; çº¿ç¨‹id è¾“å‡ºè¿›ç¨‹çš„å †æ ˆä¿¡æ¯ï¼Œç„¶åŽæ ¹æ®çº¿ç¨‹IDçš„åå…­è¿›åˆ¶å€¼grepjstack pid | grep åå…­è¿›åˆ¶çº¿ç¨‹id jmapæŸ¥çœ‹å †å†…å­˜ä½¿ç”¨çŠ¶å†µjmap -heap pid è¿›ç¨‹å†…å­˜ä½¿ç”¨æƒ…å†µdumpåˆ°æ–‡ä»¶ä¸­ ç»“åˆMATå·¥å…·åˆ†æžjmap -dump:format=b,file=dumpFileName pid jhatjhat -port 9998 /tmp/dump.datlocalhost:9998 æŸ¥çœ‹å†…å­˜å¯¹è±¡æƒ…å†µ ï¼ˆä¸å¦‚MATç›´è§‚ï¼‰]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vmstatu]]></title>
    <url>%2F2019%2F05%2F22%2Fvmstatus%2F</url>
    <content type="text"><![CDATA[vmstatuvmstatå‘½ä»¤æ˜¯æœ€å¸¸è§çš„Linux/Unixç›‘æŽ§å·¥å…·ï¼Œå¯ä»¥å±•çŽ°ç»™å®šæ—¶é—´é—´éš”çš„æœåŠ¡å™¨çš„çŠ¶æ€å€¼,åŒ…æ‹¬æœåŠ¡å™¨çš„CPUä½¿ç”¨çŽ‡ï¼Œå†…å­˜ä½¿ç”¨ï¼Œè™šæ‹Ÿå†…å­˜äº¤æ¢æƒ…å†µ,IOè¯»å†™æƒ…å†µã€‚ç›¸æ¯”topï¼Œå¯ä»¥çœ‹åˆ°æ•´ä¸ªæœºå™¨çš„CPU,å†…å­˜,IOçš„ä½¿ç”¨æƒ…å†µï¼Œè€Œä¸æ˜¯å•å•çœ‹åˆ°å„ä¸ªè¿›ç¨‹çš„CPUä½¿ç”¨çŽ‡å’Œå†…å­˜ä½¿ç”¨çŽ‡(ä½¿ç”¨åœºæ™¯ä¸ä¸€æ ·)ã€‚ 1234$vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 215220 0 771404 0 0 2 15 0 1 0 0 100 0 0 ä¸€èˆ¬vmstatå·¥å…·çš„ä½¿ç”¨æ˜¯é€šè¿‡ä¸¤ä¸ªæ•°å­—å‚æ•°æ¥å®Œæˆçš„ï¼Œç¬¬ä¸€ä¸ªå‚æ•°æ˜¯é‡‡æ ·çš„æ—¶é—´é—´éš”æ•°ï¼Œå•ä½æ˜¯ç§’ï¼Œç¬¬äºŒä¸ªå‚æ•°æ˜¯é‡‡æ ·çš„æ¬¡æ•° 12345$vmstat 2 2procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 202924 0 785780 0 0 2 15 0 1 0 0 100 0 0 0 0 0 203032 0 785812 0 0 0 155 748 1382 0 0 100 0 0 ç¬¬äºŒä¸ªå‚æ•°å¦‚æžœæ²¡æœ‰ï¼Œå°±ä¼šä¸€ç›´é‡‡é›†ï¼ˆctrl+c ç»“æŸï¼‰ 12345678$vmstat 2procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 194712 0 794728 0 0 2 15 0 1 0 0 100 0 0 0 0 0 194696 0 794768 0 0 0 50 782 1368 0 0 100 0 0 0 0 0 193828 0 794776 0 0 0 108 752 1156 0 0 100 0 0 0 0 0 193952 0 794804 0 0 0 4 601 997 0 0 100 0 0^C å­—æ®µprocs r ç­‰å¾…è¿è¡Œçš„è¿›ç¨‹æ•° b å¤„åœ¨éžä¸­æ–­ç¡çœ çŠ¶æ€çš„è¿›ç¨‹æ•° memory ï¼ˆKBï¼‰ swpd è™šæ‹Ÿå†…å­˜ä½¿ç”¨å¤§å° æ³¨æ„ï¼šå¦‚æžœswpdçš„å€¼ä¸ä¸º0ï¼Œä½†æ˜¯SIï¼ŒSOçš„å€¼é•¿æœŸä¸º0ï¼Œè¿™ç§æƒ…å†µä¸ä¼šå½±å“ç³»ç»Ÿæ€§èƒ½ã€‚ free ç©ºé—²çš„å†…å­˜ buff ç”¨ä½œç¼“å†²çš„å†…å­˜å¤§å° cache ç”¨ä½œç¼“å­˜çš„å†…å­˜å¤§å° æ³¨æ„ï¼šå¦‚æžœcacheçš„å€¼å¤§çš„æ—¶å€™ï¼Œè¯´æ˜Žcacheå¤„çš„æ–‡ä»¶æ•°å¤šï¼Œå¦‚æžœé¢‘ç¹è®¿é—®åˆ°çš„æ–‡ä»¶éƒ½èƒ½è¢«cacheå¤„ï¼Œé‚£ä¹ˆç£ç›˜çš„è¯»IO biä¼šéžå¸¸å°ã€‚ swap si ä»Žäº¤æ¢åŒºå†™åˆ°å†…å­˜çš„å¤§å° so æ¯ç§’å†™å…¥äº¤æ¢åŒºçš„å†…å­˜å¤§å° å†…å­˜å¤Ÿç”¨çš„æ—¶å€™ï¼Œè¿™2ä¸ªå€¼éƒ½æ˜¯0ï¼Œå¦‚æžœè¿™2ä¸ªå€¼é•¿æœŸå¤§äºŽ0æ—¶ï¼Œç³»ç»Ÿæ€§èƒ½ä¼šå—åˆ°å½±å“ï¼Œç£ç›˜IOå’ŒCPUèµ„æºéƒ½ä¼šè¢«æ¶ˆè€—ã€‚æœ‰äº›æœ‹å‹çœ‹åˆ°ç©ºé—²å†…å­˜ï¼ˆfreeï¼‰å¾ˆå°‘çš„æˆ–æŽ¥è¿‘äºŽ0æ—¶ï¼Œå°±è®¤ä¸ºå†…å­˜ä¸å¤Ÿç”¨äº†ï¼Œä¸èƒ½å…‰çœ‹è¿™ä¸€ç‚¹ï¼Œè¿˜è¦ç»“åˆsiå’Œsoï¼Œå¦‚æžœfreeå¾ˆå°‘ï¼Œä½†æ˜¯siå’Œsoä¹Ÿå¾ˆå°‘ï¼ˆå¤§å¤šæ—¶å€™æ˜¯0ï¼‰ï¼Œé‚£ä¹ˆä¸ç”¨æ‹…å¿ƒï¼Œç³»ç»Ÿæ€§èƒ½è¿™æ—¶ä¸ä¼šå—åˆ°å½±å“çš„ã€‚ io bi æ¯ç§’è¯»å–çš„å—æ•° bo æ¯ç§’å†™å…¥çš„å—æ•° æ³¨æ„ï¼šéšæœºç£ç›˜è¯»å†™çš„æ—¶å€™ï¼Œè¿™2ä¸ªå€¼è¶Šå¤§ï¼ˆå¦‚è¶…å‡º1024k)ï¼Œèƒ½çœ‹åˆ°CPUåœ¨IOç­‰å¾…çš„å€¼ä¹Ÿä¼šè¶Šå¤§ã€‚ system in æ¯ç§’ä¸­æ–­æ•°ï¼ŒåŒ…æ‹¬æ—¶é’Ÿä¸­æ–­ã€‚ cs æ¯ç§’ä¸Šä¸‹æ–‡åˆ‡æ¢æ•°ã€‚ æ³¨æ„ï¼šä¸Šé¢2ä¸ªå€¼è¶Šå¤§ï¼Œä¼šçœ‹åˆ°ç”±å†…æ ¸æ¶ˆè€—çš„CPUæ—¶é—´ä¼šè¶Šå¤§ã€‚ cpu us ç”¨æˆ·è¿›ç¨‹æ‰§è¡Œæ—¶é—´(user time) æ³¨æ„ï¼š usçš„å€¼æ¯”è¾ƒé«˜æ—¶ï¼Œè¯´æ˜Žç”¨æˆ·è¿›ç¨‹æ¶ˆè€—çš„CPUæ—¶é—´å¤šï¼Œä½†æ˜¯å¦‚æžœé•¿æœŸè¶…50%çš„ä½¿ç”¨ï¼Œé‚£ä¹ˆæˆ‘ä»¬å°±è¯¥è€ƒè™‘ä¼˜åŒ–ç¨‹åºç®—æ³•æˆ–è€…è¿›è¡ŒåŠ é€Ÿã€‚ sy ç³»ç»Ÿè¿›ç¨‹æ‰§è¡Œæ—¶é—´(system time) æ³¨æ„ï¼šsyçš„å€¼é«˜æ—¶ï¼Œè¯´æ˜Žç³»ç»Ÿå†…æ ¸æ¶ˆè€—çš„CPUèµ„æºå¤šï¼Œè¿™å¹¶ä¸æ˜¯è‰¯æ€§è¡¨çŽ°ï¼Œæˆ‘ä»¬åº”è¯¥æ£€æŸ¥åŽŸå› ã€‚ id ç©ºé—²æ—¶é—´(åŒ…æ‹¬IOç­‰å¾…æ—¶é—´),ä¸­å¤®å¤„ç†å™¨çš„ç©ºé—²æ—¶é—´ ã€‚ä»¥ç™¾åˆ†æ¯”è¡¨ç¤ºã€‚ wa ç­‰å¾…IOæ—¶é—´ç™¾åˆ†æ¯” æ³¨æ„ï¼šwaçš„å€¼é«˜æ—¶ï¼Œè¯´æ˜ŽIOç­‰å¾…æ¯”è¾ƒä¸¥é‡ï¼Œè¿™å¯èƒ½ç”±äºŽç£ç›˜å¤§é‡ä½œéšæœºè®¿é—®é€ æˆï¼Œä¹Ÿæœ‰å¯èƒ½ç£ç›˜å‡ºçŽ°ç“¶é¢ˆï¼ˆå—æ“ä½œï¼‰ã€‚ 1234567891011121314151617181920212223242526Procsr: The number of processes waiting for run time.b: The number of processes in uninterruptible sleep.Memoryswpd: the amount of virtual memory used.free: the amount of idle memory.buff: the amount of memory used as buffers.cache: the amount of memory used as cache.inact: the amount of inactive memory. (-a option)active: the amount of active memory. (-a option)Swapsi: Amount of memory swapped in from disk (/s).so: Amount of memory swapped to disk (/s).IObi: Blocks received from a block device (blocks/s).bo: Blocks sent to a block device (blocks/s).Systemin: The number of interrupts per second, including the clock.cs: The number of context switches per second.CPUThese are percentages of total CPU time.us: Time spent running non-kernel code. (user time, including nice time)sy: Time spent running kernel code. (system time)id: Time spent idle. Prior to Linux 2.5.41, this includes IO-wait time.wa: Time spent waiting for IO. Prior to Linux 2.5.41, included in idle.st: Time stolen from a virtual machine. Prior to Linux 2.6.11, unknown.]]></content>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter plugin registry]]></title>
    <url>%2F2019%2F05%2F17%2Fflutter-plugin-registry%2F</url>
    <content type="text"><![CDATA[å‰è¨€é¦–å…ˆè¿™é‡Œæœ‰ä¸‰ä¸ªå½¢ä¼¼å¾—è‹±æ–‡å•è¯registry, registrar and registrantåˆ†åˆ«å¯¹åº”æ³¨å†Œå±€ï¼Œæ³¨å†Œå•†å’Œæ³¨å†Œäººã€‚æŠŠå®ƒä»¬ç¿»è¯‘åˆ°çŽ°å®žçš„ç”Ÿæ´»åœºæ™¯ä¸­çš„è§’è‰²å…¶å®žæ˜¯ä¸€ä¸ªâ€œæ³¨å†Œäººé€šè¿‡æ³¨å†Œå•†ï¼Œæ›´æ–°æ³¨å†Œä¿¡æ¯åŽï¼Œæ³¨å†Œå•†æŠŠä¿¡æ¯ä¼ é€’ç»™æ³¨å†Œå±€è¿›è¡Œä¿å­˜â€çš„è¿‡ç¨‹ã€‚ æ³¨å†Œäººï¼šGeneratedPluginRegistrantæ³¨å†Œå±€ï¼š[(FlutterViewController*)rootViewController pluginRegistry] == flutterEngineæ³¨å†Œå•†ï¼šFlutterEngineRegistrar Flutter Applicationflutter create -t plugin my_plugin xcode æ‰“å¼€ my_plugin/example/iosè·¯å¾„ä¸‹çš„ Runnerå·¥ç¨‹ AppDelegate12345678910@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [GeneratedPluginRegistrant registerWithRegistry:self]; // Override point for customization after application launch. return [super application:application didFinishLaunchingWithOptions:launchOptions];&#125;@end GeneratedPluginRegistrant1234567@implementation GeneratedPluginRegistrant+ (void)registerWithRegistry:(NSObject&lt;FlutterPluginRegistry&gt;*)registry &#123; [MyPlugin registerWithRegistrar:[registry registrarForPlugin:@"MyPlugin"]];&#125;@end AppDelegateç»§æ‰¿FlutterAppDelegate FlutterAppDelegate123456789#pragma mark - FlutterPluginRegistry methods. All delegating to the rootViewController- (NSObject&lt;FlutterPluginRegistrar&gt;*)registrarForPlugin:(NSString*)pluginKey &#123; UIViewController* rootViewController = _window.rootViewController; if ([rootViewController isKindOfClass:[FlutterViewController class]]) &#123; return [[(FlutterViewController*)rootViewController pluginRegistry] registrarForPlugin:pluginKey]; &#125; return nil;&#125; FlutterViewController123- (id&lt;FlutterPluginRegistry&gt;)pluginRegistry &#123; return _engine;&#125; FlutterEngineRegistrar1234567891011121314151617181920212223@implementation FlutterEngineRegistrar &#123; NSString* _pluginKey; FlutterEngine* _flutterEngine;&#125;- (instancetype)initWithPlugin:(NSString*)pluginKey flutterEngine:(FlutterEngine*)flutterEngine &#123; self = [super init]; NSAssert(self, @"Super init cannot be nil"); _pluginKey = [pluginKey retain]; _flutterEngine = [flutterEngine retain]; return self;&#125;- (void)addMethodCallDelegate:(NSObject&lt;FlutterPlugin&gt;*)delegate channel:(FlutterMethodChannel*)channel &#123; [channel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) &#123; [delegate handleMethodCall:call result:result]; &#125;];&#125;- (NSObject&lt;FlutterBinaryMessenger&gt;*)messenger &#123; return _flutterEngine;&#125; MyPlugin123456789101112131415161718@implementation MyPlugin+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar &#123; FlutterMethodChannel* channel = [FlutterMethodChannel methodChannelWithName:@"my_plugin" binaryMessenger:[registrar messenger]]; MyPlugin* instance = [[MyPlugin alloc] init]; [registrar addMethodCallDelegate:instance channel:channel];&#125;- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result &#123; if ([@"getPlatformVersion" isEqualToString:call.method]) &#123; result([@"iOS " stringByAppendingString:[[UIDevice currentDevice] systemVersion]]); &#125; else &#123; result(FlutterMethodNotImplemented); &#125;&#125;@end FlutterMethodChannel1234567891011121314151617181920212223242526272829- (instancetype)initWithName:(NSString*)name binaryMessenger:(NSObject&lt;FlutterBinaryMessenger&gt;*)messenger codec:(NSObject&lt;FlutterMethodCodec&gt;*)codec &#123; self = [super init]; NSAssert(self, @"Super init cannot be nil"); _name = [name retain]; _messenger = [messenger retain]; //flutterEngine _codec = [codec retain]; return self;&#125;- (void)setMethodCallHandler:(FlutterMethodCallHandler)handler &#123; if (!handler) &#123; [_messenger setMessageHandlerOnChannel:_name binaryMessageHandler:nil]; return; &#125; FlutterBinaryMessageHandler messageHandler = ^(NSData* message, FlutterBinaryReply callback) &#123; FlutterMethodCall* call = [_codec decodeMethodCall:message]; handler(call, ^(id result) &#123; if (result == FlutterMethodNotImplemented) callback(nil); else if ([result isKindOfClass:[FlutterError class]]) callback([_codec encodeErrorEnvelope:(FlutterError*)result]); else callback([_codec encodeSuccessEnvelope:result]); &#125;); &#125;; [_messenger setMessageHandlerOnChannel:_name binaryMessageHandler:messageHandler];&#125; FlutterEngine123456789101112131415#pragma mark - FlutterPluginRegistry- (NSObject&lt;FlutterPluginRegistrar&gt;*)registrarForPlugin:(NSString*)pluginKey &#123; NSAssert(self.pluginPublications[pluginKey] == nil, @"Duplicate plugin key: %@", pluginKey); self.pluginPublications[pluginKey] = [NSNull null]; return [[FlutterEngineRegistrar alloc] initWithPlugin:pluginKey flutterEngine:self];&#125;- (void)setMessageHandlerOnChannel:(NSString*)channel binaryMessageHandler:(FlutterBinaryMessageHandler)handler &#123; NSAssert(channel, @"The channel must not be null"); FML_DCHECK(_shell &amp;&amp; _shell-&gt;IsSetup()); self.iosPlatformView-&gt;GetPlatformMessageRouter().SetMessageHandler(channel.UTF8String, handler);&#125; FlutterBinaryMessage123456789101112131415161718/** * A message reply callback. * * Used for submitting a binary reply back to a Flutter message sender. Also used * in for handling a binary message reply received from Flutter. * * @param reply The reply. */typedef void (^FlutterBinaryReply)(NSData* _Nullable reply);/** * A strategy for handling incoming binary messages from Flutter and to send * asynchronous replies back to Flutter. * * @param message The message. * @param reply A callback for submitting an asynchronous reply to the sender. */typedef void (^FlutterBinaryMessageHandler)(NSData* _Nullable message, FlutterBinaryReply reply);]]></content>
  </entry>
  <entry>
    <title><![CDATA[sublime text 3]]></title>
    <url>%2F2019%2F05%2F14%2Fsublime-text-3%2F</url>
    <content type="text"><![CDATA[sublime text3 install package controlTools -&gt; Install package control æŠ¥é”™ä¿¡æ¯å·¥å…·æ View ç‚¹å‡»show console æˆ–è€…å¿«æ·é”® ctrl+` æ‰“å¼€æŽ§åˆ¶å°çœ‹ä¸‹å¦‚ä¸‹æŠ¥é”™ä¿¡æ¯ 1234Visit https://packagecontrol.io/installation for manual instructionsError installing Package Control: HTTPS error encountered, falling back to HTTP - &lt;urlopen error [Errno 60] Operation timed out&gt;Error installing Package Control: HTTP error encountered, giving up - &lt;urlopen error [Errno 60] Operation timed out&gt;error: An error occurred installing Package Control å¤„ç†åŠžæ³•ç»‘å®šåŸŸå 1250.116.34.243 sublime.wbond.net50.116.34.243 packagecontrol.io install packageæŠ¥é”™ä¿¡æ¯There are no packages available for installation å¤„ç†åŠžæ³•ä¸‹è½½ channel_v3.json æ–‡ä»¶ ï¼ˆgoogleä¸€ä¸‹ï¼‰ ä¿®æ”¹package control.sublime-settings 123&quot;channels&quot;: [ &quot;/path/to/channel_v3.json&quot;]]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim shortcuts]]></title>
    <url>%2F2019%2F05%2F14%2Fvim-shortcuts%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutterä¹‹Dartç¼–è¯‘]]></title>
    <url>%2F2019%2F05%2F10%2FFlutter%E4%B9%8BDart%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[å‰è¨€Appä¸­ä½¿ç”¨flutterå·²ç»æœ‰æ®µæ—¶é—´äº†ï¼Œæœ€è¿‘é‡åˆ°ä¸€ä¸ªbugè®°å½•ä¸€ä¸‹ã€‚æ›´æ–°flutter moduleå·¥ç¨‹pubspec pluginä¾èµ–ï¼ŒAppå·¥ç¨‹ä¸­pod updateä¹‹åŽï¼Œä»ŽåŠŸèƒ½è¡¨çŽ°ä¸Šçœ‹ä¾ç„¶æ˜¯è€ä»£ç ã€‚ç¬¬ä¸€æ„Ÿè§‰æ˜¯ç¼“å­˜å¯¼è‡´çš„ï¼Œxcode clean ä»¥åŠåˆ é™¤DerivedDataç›®å½•é‡æ–°buildä¾ç„¶ä¸è¡Œï¼Œflutter moduleå·¥ç¨‹ä¸­æ‰§è¡Œflutter cleanç„¶åŽxcode buildæ˜¯æ­£å¸¸çš„ï¼Œæ‰€ä»¥åº”è¯¥æ˜¯dartç¼–è¯‘äº§ç‰©æœ‰ç¼“å­˜å¯¼è‡´çš„ã€‚æŽ¥ä¸‹æ¥çœ‹ä¸‹dartç¼–è¯‘è¿‡ç¨‹ã€‚ ç¼–è¯‘12cd path/to/flutter moduleflutter build ios --debug --simulator è¿›å…¥åˆ°flutter moduleå·¥ç¨‹ç›®å½• æ‰§è¡Œflutter build ioså‘½ä»¤ 12345Running Xcode build... â”œâ”€Assembling Flutter resources... 3.6s â””â”€Compiling, linking and signing... 25.4sXcode build done. 43.9s å¯ä»¥çœ‹åˆ°ä¼šè¿›è¡Œxcode buildï¼Œè¿›åˆ°.iosç›®å½•é€šè¿‡xcodeæ‰“å¼€Runnerå·¥ç¨‹ å¯ä»¥çœ‹åˆ°build phasesä¸­è¿™æ ·ä¸€æ®µè„šæœ¬ï¼Œè¿™é‡Œå°±æ˜¯æ‰§è¡Œdartä»£ç ç¼–è¯‘çš„å…¥å£ã€‚ xcode_backend.shè¿›å…¥åˆ°è„šæœ¬æ‰€åœ¨ç›®å½•ï¼Œçœ‹ä¸‹buildå¯¹åº”çš„æ–¹æ³• BuildApp 12345678910111213if [[ $# == 0 ]]; then # Backwards-compatibility: if no args are provided, build. BuildAppelse case $1 in "build") BuildApp ;; "thin") ThinAppFrameworks ;; "embed") EmbedFlutterFrameworks ;; esacfi 123456789101112131415161718192021222324252627282930BuildApp() &#123; ... StreamOutput " â”œâ”€Assembling Flutter resources..." RunCommand "$&#123;FLUTTER_ROOT&#125;/bin/flutter" --suppress-analytics \ $&#123;verbose_flag&#125; \ build bundle \ --target-platform=ios \ --target="$&#123;target_path&#125;" \ --$&#123;build_mode&#125; \ --depfile="$&#123;build_dir&#125;/snapshot_blob.bin.d" \ --asset-dir="$&#123;derived_dir&#125;/App.framework/$&#123;assets_path&#125;" \ $&#123;precompilation_flag&#125; \ $&#123;flutter_engine_flag&#125; \ $&#123;local_engine_flag&#125; \ $&#123;track_widget_creation_flag&#125; if [[ $? -ne 0 ]]; then EchoError "Failed to package $&#123;project_path&#125;." exit -1 fi StreamOutput "done" StreamOutput " â””â”€Compiling, linking and signing..." RunCommand popd &gt; /dev/null echo "Project $&#123;project_path&#125; built and packaged successfully." return 0&#125; å¯ä»¥çœ‹åˆ° â”œâ”€Assembling Flutter resourcesâ€¦ åœ¨build ios æ‰§è¡Œè¿‡ç¨‹ä¸­å‡ºçŽ°è¿‡ï¼Œflutter build bundle å°±ä¼šå¼€å§‹çœŸæ­£çš„dartç¼–è¯‘â€“depfile æŒ‡å®šå‚ä¸Žç¼–è¯‘çš„dartæ–‡ä»¶è·¯å¾„é›†åˆâ€“asset-dir æŒ‡å®šèµ„æºäº§ç‰©çš„ç›®å½• flutterå‘½ä»¤è·¯å¾„ $FLUTTER_ROOT/bin/flutter 123456789101112...FLUTTER_TOOLS_DIR="$FLUTTER_ROOT/packages/flutter_tools"SNAPSHOT_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.snapshot"STAMP_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.stamp"SCRIPT_PATH="$FLUTTER_TOOLS_DIR/bin/flutter_tools.dart"DART_SDK_PATH="$FLUTTER_ROOT/bin/cache/dart-sdk"DART="$DART_SDK_PATH/bin/dart"PUB="$DART_SDK_PATH/bin/pub""$DART" $FLUTTER_TOOL_ARGS "$SNAPSHOT_PATH" "$@" flutter_toools.snapshotå®žé™…ä¸Šå°±æ˜¯$FLUTTER_ROOT/packages/flutter_toolsè¿™ä¸ªé¡¹ç›®ç¼–è¯‘ç”Ÿæˆçš„snapshotæ–‡ä»¶ æ‰€ä»¥flutter build bundle å°±æ˜¯ä½¿ç”¨dartæ¥æ‰§è¡Œflutter_toolsé¡¹ç›®çš„mainæ–¹æ³• flutter_toolsè·¯å¾„ $FLUTTER_ROOT/packages/flutter_tools mainæ–¹æ³•å®šä¹‰ $FLUTTER_ROOT/packages/flutter_tools/bin/flutter_tools.dart 123void main(List&lt;String&gt; args) &#123; executable.main(args);&#125; å†çœ‹çœ‹ lib/executable.dart ,åœ¨è¿™é‡Œä¼šé¢„å…ˆåˆ›å»ºå¥½æ¯ä¸€ç§å‘½ä»¤å¯¹åº”çš„å¯¹è±¡commandï¼Œé€šè¿‡è§£æžargså‚æ•°æ‰¾åˆ°å¯¹åº”çš„commandã€‚åœ¨BuildCommandç±»ä¸­ 123456789BuildCommand(&#123;bool verboseHelp = false&#125;) &#123; addSubcommand(BuildApkCommand(verboseHelp: verboseHelp)); addSubcommand(BuildAppBundleCommand(verboseHelp: verboseHelp)); addSubcommand(BuildAotCommand()); addSubcommand(BuildIOSCommand()); addSubcommand(BuildFlxCommand()); addSubcommand(BuildBundleCommand(verboseHelp: verboseHelp)); addSubcommand(BuildWebCommand()); &#125; çœ‹åˆ°BuildIOSCommand ä»¥åŠ BuildBundleCommandçš„åˆ›å»ºã€‚BuildIOSCommand å°±æ˜¯å‰é¢æåˆ°çš„flutter build ios ä¼šæ‰§è¡Œåˆ°çš„ï¼Œè¿™é‡Œæˆ‘ä»¬é‡ç‚¹çœ‹ä¸‹BuildBundleCommandæ˜¯å¦‚ä½•ç¼–è¯‘dartä»£ç çš„ï¼Ÿç¼–è¯‘åŽç”Ÿæˆäº†å“ªäº›èµ„æºï¼Ÿè¿™äº›èµ„æºéƒ½æ˜¯äº›ä»€ä¹ˆï¼Ÿ BuildBundleCommand app.dill : è¿™å°±æ˜¯dartä»£ç ç¼–è¯‘åŽçš„äºŒçº§åˆ¶æ–‡ä»¶ Frontend_server.d : è¿™é‡Œé¢æ”¾çš„æ˜¯frontend_server.dart.snapshotçš„ç»å¯¹è·¯å¾„ï¼Œä½¿ç”¨è¯¥snapshotæ¥ç¼–è¯‘dartä»£ç ç”Ÿæˆä¸Šé¢çš„app.dill snapshot_blob.bin.d : è¿™é‡Œé¢æ”¾çš„æ˜¯æ‰€æœ‰å‚ä¸Žç¼–è¯‘çš„dartæ–‡ä»¶çš„ç»å¯¹è·¯å¾„çš„é›†åˆï¼ŒåŒ…æ‹¬é¡¹ç›®çš„ä»£ç å’ŒflutterSdkçš„ä»£ç ä»¥åŠpubåº“ä¸­çš„ä¸‰æ–¹ä»£ç ã€‚ snapshot_blob.bin.d.fingerprint : è¿™é‡Œé¢æ”¾çš„æ˜¯snapshot_blob.bin.dä¸­çš„æ‰€æœ‰æ–‡ä»¶çš„ç»å¯¹è·¯å¾„ä»¥åŠæ¯ä¸ªæ–‡ä»¶æ‰€å¯¹åº”çš„md5å€¼ã€‚ä½¿ç”¨è¿™ä¸ªmd5æ¥åˆ¤æ–­è¯¥æ–‡ä»¶æ˜¯å¦æœ‰ä¿®æ”¹ã€‚åœ¨æ¯æ¬¡ç¼–è¯‘çš„æ—¶å€™ä¼šåˆ¤æ–­ï¼Œå¦‚æžœæ²¡æœ‰æ–‡ä»¶ä¿®æ”¹ï¼Œåˆ™ç›´æŽ¥è·³è¿‡ç¼–è¯‘ã€‚ ç¼–è¯‘Dartèµ„æº123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127Future&lt;void&gt; build(&#123; TargetPlatform platform, BuildMode buildMode, String mainPath = defaultMainPath, String manifestPath = defaultManifestPath, String applicationKernelFilePath, String depfilePath, String privateKeyPath = defaultPrivateKeyPath, String assetDirPath, String packagesPath, bool precompiledSnapshot = false, bool reportLicensedPackages = false, bool trackWidgetCreation = false, String compilationTraceFilePath, bool createPatch = false, String buildNumber, String baselineDir, List&lt;String&gt; extraFrontEndOptions = const &lt;String&gt;[], List&lt;String&gt; extraGenSnapshotOptions = const &lt;String&gt;[], List&lt;String&gt; fileSystemRoots, String fileSystemScheme,&#125;) async &#123; // xcode_backend.shä¸­é€šè¿‡--depfileä¼ å…¥è¿›æ¥çš„ // é»˜è®¤æ˜¯build/snapshot_blob.bin.dæ–‡ä»¶ depfilePath ??= defaultDepfilePath; // é€šè¿‡--asset-dirä¼ å…¥ // è¯¥ç›®å½•ä¸­æ–‡ä»¶å°±æ˜¯flutterçš„äº§ç‰©ï¼Œæœ€ç»ˆåˆå¹¶åˆ°app.frameworkä¸­çš„flutter_assetsç›®å½• assetDirPath ??= getAssetBuildDirectory(); packagesPath ??= fs.path.absolute(PackageMap.globalPackagesPath); // app.dill dartä»£ç ç¼–è¯‘åŽçš„äºŒçº§åˆ¶æ–‡ä»¶ applicationKernelFilePath ??= getDefaultApplicationKernelPath(trackWidgetCreation: trackWidgetCreation); final FlutterProject flutterProject = await FlutterProject.current(); if (compilationTraceFilePath != null) &#123; if (buildMode != BuildMode.dynamicProfile &amp;&amp; buildMode != BuildMode.dynamicRelease) &#123; compilationTraceFilePath = null; &#125; else if (compilationTraceFilePath.isEmpty) &#123; // Disable JIT snapshotting if flag is empty. printStatus('Code snapshot will be disabled for this build.'); compilationTraceFilePath = null; &#125; else if (!fs.file(compilationTraceFilePath).existsSync()) &#123; // Be forgiving if compilation trace file is missing. printStatus('No compilation trace available. To optimize performance, consider using --train.'); final File tmp = fs.systemTempDirectory.childFile('flutterEmptyCompilationTrace.txt'); compilationTraceFilePath = (tmp..createSync(recursive: true)).path; &#125; else &#123; printStatus('Code snapshot will use compilation training file $compilationTraceFilePath.'); &#125; &#125; DevFSContent kernelContent; if (!precompiledSnapshot) &#123; if ((extraFrontEndOptions != null) &amp;&amp; extraFrontEndOptions.isNotEmpty) printTrace('Extra front-end options: $extraFrontEndOptions'); ensureDirectoryExists(applicationKernelFilePath); final KernelCompiler kernelCompiler = await kernelCompilerFactory.create(flutterProject); // ç¼–è¯‘dartä»£ç ï¼Œç”Ÿæˆapp.dill å’Œ snapshot_blob.bin.d ä»¥åŠ snapshot_blob.bin.d.fingerprint final CompilerOutput compilerOutput = await kernelCompiler.compile( sdkRoot: artifacts.getArtifactPath(Artifact.flutterPatchedSdkPath), incrementalCompilerByteStorePath: compilationTraceFilePath != null ? null : fs.path.absolute(getIncrementalCompilerByteStoreDirectory()), mainPath: fs.file(mainPath).absolute.path, outputFilePath: applicationKernelFilePath, depFilePath: depfilePath, trackWidgetCreation: trackWidgetCreation, extraFrontEndOptions: extraFrontEndOptions, fileSystemRoots: fileSystemRoots, fileSystemScheme: fileSystemScheme, packagesPath: packagesPath, linkPlatformKernelIn: compilationTraceFilePath != null, ); if (compilerOutput?.outputFilename == null) &#123; throwToolExit('Compiler failed on $mainPath'); &#125; kernelContent = DevFSFileContent(fs.file(compilerOutput.outputFilename)); // ç”Ÿæˆ frontend_server.dæ–‡ä»¶ï¼Œå‘æ–‡ä»¶ä¸­å†™å…¥frontendServerSnapshotForEngineDartSdkçš„è·¯å¾„ await fs.directory(getBuildDirectory()).childFile('frontend_server.d') .writeAsString('frontend_server.d: $&#123;artifacts.getArtifactPath(Artifact.frontendServerSnapshotForEngineDartSdk)&#125;\n'); if (compilationTraceFilePath != null) &#123; final JITSnapshotter snapshotter = JITSnapshotter(); final int snapshotExitCode = await snapshotter.build( platform: platform, buildMode: buildMode, mainPath: applicationKernelFilePath, outputPath: getBuildDirectory(), packagesPath: packagesPath, compilationTraceFilePath: compilationTraceFilePath, extraGenSnapshotOptions: extraGenSnapshotOptions, createPatch: createPatch, buildNumber: buildNumber, baselineDir: baselineDir, ); if (snapshotExitCode != 0) &#123; throwToolExit('Snapshotting exited with non-zero exit code: $snapshotExitCode'); &#125; &#125; &#125; // ç”Ÿæˆ flutter_assets final AssetBundle assets = await buildAssets( manifestPath: manifestPath, assetDirPath: assetDirPath, packagesPath: packagesPath, reportLicensedPackages: reportLicensedPackages, ); if (assets == null) throwToolExit('Error building assets', exitCode: 1); await assemble( buildMode: buildMode, assetBundle: assets, kernelContent: kernelContent, privateKeyPath: privateKeyPath, assetDirPath: assetDirPath, compilationTraceFilePath: compilationTraceFilePath, );&#125; ç¼–è¯‘Dartä»£ç 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class KernelCompiler &#123; const KernelCompiler(); Future&lt;CompilerOutput&gt; compile(&#123; String sdkRoot, String mainPath, String outputFilePath, String depFilePath, TargetModel targetModel = TargetModel.flutter, bool linkPlatformKernelIn = false, bool aot = false, @required bool trackWidgetCreation, List&lt;String&gt; extraFrontEndOptions, String incrementalCompilerByteStorePath, String packagesPath, List&lt;String&gt; fileSystemRoots, String fileSystemScheme, bool targetProductVm = false, String initializeFromDill, &#125;) async &#123; final String frontendServer = artifacts.getArtifactPath( Artifact.frontendServerSnapshotForEngineDartSdk ); FlutterProject flutterProject; if (fs.file('pubspec.yaml').existsSync()) &#123; flutterProject = await FlutterProject.current(); &#125; // TODO(cbracken): eliminate pathFilter. // Currently the compiler emits buildbot paths for the core libs in the // depfile. None of these are available on the local host. Fingerprinter fingerprinter; // å¦‚æžœsnapshot_blob.bin.dæ–‡ä»¶ä¸ä¸ºç©ºï¼Œåˆ™è¯´æ˜Žæœ‰ç¼–è¯‘ç¼“å­˜ if (depFilePath != null) &#123; // åˆ¤æ–­ä¸Žä¸Šæ¬¡ç¼–è¯‘å¯¹æ¯”ï¼Œæ˜¯å¦æœ‰æ–‡ä»¶çš„md5æ”¹å˜ fingerprinter = Fingerprinter( // snapshot_blob.bin.d.fingerprintæ–‡ä»¶ fingerprintPath: '$depFilePath.fingerprint', paths: &lt;String&gt;[mainPath], properties: &lt;String, String&gt;&#123; 'entryPoint': mainPath, 'trackWidgetCreation': trackWidgetCreation.toString(), 'linkPlatformKernelIn': linkPlatformKernelIn.toString(), 'engineHash': Cache.instance.engineRevision, 'buildersUsed': '$&#123;flutterProject != null ? flutterProject.hasBuilders : false&#125;', &#125;, depfilePaths: &lt;String&gt;[depFilePath], pathFilter: (String path) =&gt; !path.startsWith('/b/build/slave/'), ); // åˆ¤æ–­æ˜¯å¦æœ‰æ–‡ä»¶æ”¹åŠ¨ï¼Œå¦‚æžœæ²¡æœ‰ï¼Œåˆ™ç›´æŽ¥è¿”å›žã€‚ if (await fingerprinter.doesFingerprintMatch()) &#123; printTrace('Skipping kernel compilation. Fingerprint match.'); return CompilerOutput(outputFilePath, 0, /* sources */ null); &#125; &#125; ... // å¦‚æžœæ²¡æœ‰ä¸Šæ¬¡ç¼–è¯‘ç¼“å­˜ï¼Œæˆ–è€…æ–‡ä»¶æœ‰æ”¹å˜ï¼ŒFingerprinterä¸åŒ¹é…ï¼Œåˆ™ä½¿ç”¨darté‡æ–°ç¼–è¯‘ final List&lt;String&gt; command = &lt;String&gt;[ engineDartPath, frontendServer, '--sdk-root', sdkRoot, '--strong', '--target=$targetModel', ]; ... //å‚æ•°æ‹¼æŽ¥ final Process server = await processManager .start(command) .catchError((dynamic error, StackTrace stack) &#123; printError('Failed to start frontend server $error, $stack'); &#125;); final StdoutHandler _stdoutHandler = StdoutHandler(); server.stderr .transform&lt;String&gt;(utf8.decoder) .listen(printError); server.stdout .transform&lt;String&gt;(utf8.decoder) .transform&lt;String&gt;(const LineSplitter()) .listen(_stdoutHandler.handler); final int exitCode = await server.exitCode; if (exitCode == 0) &#123; if (fingerprinter != null) &#123; await fingerprinter.writeFingerprint(); &#125; return _stdoutHandler.compilerOutput.future; &#125; return null; &#125;&#125; Fingerprintå¯¹æ¯”1234567891011121314151617181920212223242526Future&lt;bool&gt; doesFingerprintMatch() async &#123; try &#123; // èŽ·å–åˆ°å½“å‰çš„ snapshot_blob.bin.d.fingerprintæ–‡ä»¶ final File fingerprintFile = fs.file(fingerprintPath); if (!fingerprintFile.existsSync()) return false; if (!_depfilePaths.every(fs.isFileSync)) return false; final List&lt;String&gt; paths = await _getPaths(); if (!paths.every(fs.isFileSync)) return false; // è¯»å–ç¼“å­˜çš„çš„snapshot_blob.bin.d.fingerprintæ–‡ä»¶ï¼Œæž„å»ºä¸€ä¸ªè€çš„Fingerprintå¯¹è±¡ final Fingerprint oldFingerprint = Fingerprint.fromJson(await fingerprintFile.readAsString()); // æž„å»ºä¸€ä¸ªæ–°çš„Fingerprintå¯¹è±¡ final Fingerprint newFingerprint = await buildFingerprint(); // å¯¹æ¯”ä¸¤æ¬¡çš„æ–‡ä»¶é›†åˆä¸­çš„æ¯ä¸ªæ–‡ä»¶çš„md5æ˜¯å¦ä¸€æ · return oldFingerprint == newFingerprint; &#125; catch (e) &#123; // Log exception and continue, fingerprinting is only a performance improvement. printTrace('Fingerprint check error: $e'); &#125; return false; &#125; é‡ç‚¹ çœ‹çœ‹ newFingerprint 12345678910111213Future&lt;Fingerprint&gt; buildFingerprint() async &#123; final List&lt;String&gt; paths = await _getPaths(); return Fingerprint.fromBuildInputs(_properties, paths);&#125;Future&lt;List&lt;String&gt;&gt; _getPaths() async &#123; final Set&lt;String&gt; paths = _paths.toSet(); // ä½¿ç”¨ç¼“å­˜çš„snapshot_blob.bin.dæ–‡ä»¶ä¸­çš„æ–‡ä»¶é›†åˆ for (String depfilePath in _depfilePaths) paths.addAll(await readDepfile(depfilePath)); final FingerprintPathFilter filter = _pathFilter ?? (String path) =&gt; true; return paths.where(filter).toList()..sort();&#125; å¯ä»¥çœ‹åˆ°newFingerprint è·¯å¾„ä¾æ—§æ˜¯ä½¿ç”¨ç¼“å­˜çš„è·¯å¾„ï¼Œä¾æ¬¡è®¡ç®—è·¯å¾„å¯¹åº”æ–‡ä»¶çš„md5ï¼Œæ‰€ä»¥é—®é¢˜å°±åœ¨è¿™é‡Œäº† æ‰§è¡Œflutter packages upgradeæ›´æ–°pubä¾èµ–çš„æ—¶å€™ï¼Œbuildç›®å½•ä¸‹çš„ç¼“å­˜äº§ç‰©å¹¶ä¸ä¼šæœ‰ä»»ä½•å˜åŠ¨ï¼Œè·¯å¾„ä¾ç„¶æ˜¯è€çš„è·¯å¾„ã€‚æœ‰ä¸€ç§æƒ…å†µå°±æ˜¯moduleå·¥ç¨‹ lib ç›®å½•ä¸‹çš„datæ–‡ä»¶æœ‰æ”¹åŠ¨ï¼ŒnewFingerprintå°±ä¼šè·Ÿoldä¸ä¸€æ ·ï¼Œè¿™ä¼šé‡æ–°ç¼–è¯‘dartï¼Œè¿™é‡Œåˆæœ‰ä¸€ä¸ªé—®é¢˜ï¼Œå°±æ˜¯å¦‚æžœlibç›®å½•ä¸‹æ˜¯æ–°å¢ždartæ–‡ä»¶ åˆ™ä¸ä¼šè¢«ç¼–è¯‘è¿›åŽ»ã€‚ æœ€åŽç»¼ä¸Šï¼Œæ‰§è¡Œflutter cleanå‘½ä»¤ï¼Œæ¸…ç©ºbuildç›®å½•ç¼“å­˜æ–‡ä»¶ï¼Œbuild ios å°±ä¼šé‡æ–°ç¼–è¯‘æ•´ä¸ªdartæ–‡ä»¶ï¼ŒåŒ…æ‹¬pubä¾èµ–ä¸­çš„ã€‚ å‚è€ƒé“¾æŽ¥Flutteræ·±å…¥ä¹‹flutter-build-bundleå‘½ä»¤å¦‚ä½•ç¼–è¯‘Dart?]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
</search>
