<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[coreimage with metal 笔记]]></title>
    <url>%2F2022%2F08%2F08%2Fcoreimage-with-metal-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[xcode近期有自定义CoreImage的CIFilter的需求，前期通过CIKL 定义 CIKernel完成了任务，后面了解到CoreImage新特性支持metal的方式直接自定义 CIKernel，提高效率。 CIKL的方式，存在两个问题： 编写 kernel 的时候，没有报错提示，哪怕是参数名错误都无法检查处理。效率极低。 翻译转换，编译，都是发生到运行时，导致第一次使用滤镜的时候，耗时较久。 Metal: 在build阶段 就可以编译 链接 .metal文件 参考苹果的官方文档 Metal Shading Language for CoreImage Kernels ,在xcode integration 部分提到在build setting 设置 Other Metal Compiler Flags, 文档已经很老了（2018年的），新版的xcode已经没有这个选项了，如果不做处理，会有报错 &quot;/air-lld:1:1: symbol(s) not found for target &#39;air64-apple-ios12.0.0&#39;&quot; and &quot;air-lld command failed with exit code 1 (use -v to see invocation)&quot; build rules新版xcode中可以通过配置build rules解决上面的报错 *.metal 1xcrun metal -c $MTL_HEADER_SEARCH_PATHS -fcikernel &quot;$&#123;INPUT_FILE_PATH&#125;&quot; -o &quot;$&#123;SCRIPT_OUTPUT_FILE_0&#125;&quot; output files : $(METAL_LIBRARY_OUTPUT_DIR)/$(INPUT_FILE_BASE).metallib *.air 1xcrun metallib -cikernel &quot;$&#123;INPUT_FILE_PATH&#125;&quot; -o &quot;$&#123;SCRIPT_OUTPUT_FILE_0&#125;&quot; output files : $(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).air 如图： cocoapodsbuild rules 的方式存在一个问题，如果metal shader文件在pod库中，在主工程从配置build rules无法针对pod中的resouce 生效，虽然可以手动针对pod target 配置build rules解决问题，但是这样配置是一次性的，无法提交保存，下一次pod update就清空了，所以到了这里就很自然的能想到通过pod 的post hook 来解决问题，接下来就是怎么用ruby 来写 pod hook 脚本了 通过之前在主工程配置build rules, 可以看到project.pbxproj文件的变更情况 123456789101112131415161718192021222324252627282930/* Begin PBXBuildRule section */ BF25E98B28A0A91A00188AE3 /* PBXBuildRule */ = &#123; isa = PBXBuildRule; compilerSpec = com.apple.compilers.proxy.script; filePatterns = &quot;*.metal&quot;; fileType = pattern.proxy; inputFiles = ( ); isEditable = 1; outputFiles = ( &quot;$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).air&quot;, ); runOncePerArchitecture = 0; script = &quot;# Type a script or drag a script file from your workspace to insert its path.\nxcrun metal -c $MTL_HEADER_SEARCH_PATHS -fcikernel \&quot;$&#123;INPUT_FILE_PATH&#125;\&quot; -o \&quot;$&#123;SCRIPT_OUTPUT_FILE_0&#125;\&quot;\n&quot;; &#125;; BF25E98C28A0A92200188AE3 /* PBXBuildRule */ = &#123; isa = PBXBuildRule; compilerSpec = com.apple.compilers.proxy.script; filePatterns = &quot;*.air&quot;; fileType = pattern.proxy; inputFiles = ( ); isEditable = 1; outputFiles = ( &quot;$(METAL_LIBRARY_OUTPUT_DIR)/$(INPUT_FILE_BASE).metallib&quot;, ); runOncePerArchitecture = 0; script = &quot;# Type a script or drag a script file from your workspace to insert its path.\nxcrun metallib -cikernel \&quot;$&#123;INPUT_FILE_PATH&#125;\&quot; -o \&quot;$&#123;SCRIPT_OUTPUT_FILE_0&#125;\&quot;\n&quot;; &#125;;/* End PBXBuildRule section */ 哈哈 ，这正是我们需要的build rule的字段 最终的 MetalBuildRule.rb 文件如下 ： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#!/usr/bin/ruby# -*- coding: UTF-8 -*-def add_build_rule(target_name, project) project.targets.each do |target| if target.name == target_name# puts "#&#123;target.name&#125; has #&#123;target.build_rules.count&#125; build rule." if target.build_rules.count &gt;= 2 puts "#&#123;target.name&#125; already has 2 build rule." return end puts "Updating #&#123;target.name&#125; build rules" metal_rule = project.new(Xcodeproj::Project::Object::PBXBuildRule) metal_rule.name = 'Metal Build Rule' metal_rule.compiler_spec = 'com.apple.compilers.proxy.script' metal_rule.file_patterns = '*.metal' metal_rule.file_type = 'pattern.proxy' metal_rule.is_editable = '1' metal_rule.run_once_per_architecture = '0' metal_rule.output_files = ["$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).air"] metal_rule.input_files = [] metal_rule.output_files_compiler_flags = [] metal_rule.script = "xcrun metal -c $MTL_HEADER_SEARCH_PATHS -fcikernel \"$&#123;INPUT_FILE_PATH&#125;\" -o \"$&#123;SCRIPT_OUTPUT_FILE_0&#125;\"" target.build_rules.append(metal_rule) air_rule = project.new(Xcodeproj::Project::Object::PBXBuildRule) air_rule.name = 'Air Build Rule' air_rule.compiler_spec = 'com.apple.compilers.proxy.script' air_rule.file_patterns = '*.air' air_rule.file_type = 'pattern.proxy' air_rule.is_editable = '1' air_rule.run_once_per_architecture = '0' air_rule.output_files = ["$(METAL_LIBRARY_OUTPUT_DIR)/$(INPUT_FILE_BASE).metallib"] air_rule.input_files = [] air_rule.output_files_compiler_flags = [] air_rule.script = "xcrun metallib -cikernel \"$&#123;INPUT_FILE_PATH&#125;\" -o \"$&#123;SCRIPT_OUTPUT_FILE_0&#125;\"" target.build_rules.append(air_rule) project.objects_by_uuid[metal_rule.uuid] = metal_rule project.objects_by_uuid[air_rule.uuid] = air_rule project.save() end endend podfile 文件里加载 MetalBuildRule.rb, 配置hook 123post_install do |installer| add_build_rule("your-target-name", installer.pods_project)end framework如果pod库是通过cocoapods-packager插件 打.a 或者 .framework的方式提供给主工程使用的话，发现还是会遇到上文提到的错误 &quot;/air-lld:1:1: symbol(s) not found for target &#39;air64-apple-ios12.0.0&#39;&quot; and &quot;air-lld command failed with exit code 1 (use -v to see invocation)&quot; 这里需要简单了解下 cocoapods-packager 的原理，浅析 Cocoapods-Packager 实现.因为 cocoapods-packager 会重新生成一个podfile 来构造一个打包用的工程，所以这个错误的出现跟文章最开始提到的情况是一模一样的，解法是不是也可以通过配置build rule来解呢，不过打包工程我们看起来好像无法干预，怎么解呢？ 还是要回到cocoapods-packager插件来解决问题。 1https://github.com/CocoaPods/cocoapods-packager git 代码拉下来 通过ide(vscode/rubymine) 打开插件工程 配置好工程ruby环境 DEBUG 代码，找到干预点 设置build rule 生成packager gem，安装 这里涉及到ruby gem bundle等ruby环境的基本命令/用法，可以自行google一下。 通过刚刚提到的插件原理，很容易找到干预点 1234pod_utils.rbdef install_pod(platform_name, sandbox)...end 修改： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172def install_pod(platform_name, sandbox) # 判断resource_bundle 是否有.metal文件 metal = false if @spec.attributes_hash["resource_bundle"] metal = @spec.attributes_hash["resource_bundle"][@spec.name].include?("metal") end if @spec.attributes_hash["resource_bundles"] if @spec.attributes_hash["resource_bundles"][@spec.name] @spec.attributes_hash["resource_bundles"][@spec.name].each &#123; |res| metal ||= res.include?("metal") &#125; end end ... unless static_installer.nil? static_installer.pods_project.targets.each do |target| # 如果有.metal文件 &amp;&amp; target匹配 -&gt; 设置 build rule if metal &amp;&amp; target.name.start_with?(@spec.name) UI.puts "#&#123;target.name&#125; has #&#123;target.build_rules.count&#125; build rule." if target.build_rules.count &gt;= 2 UI.puts "#&#123;target.name&#125; already has 2 build rule." return end metal_rule = static_installer.pods_project.new(Xcodeproj::Project::Object::PBXBuildRule) UI.puts "Updating #&#123;target.name&#125; rules" metal_rule.name = 'Metal Build Rule' metal_rule.compiler_spec = 'com.apple.compilers.proxy.script' metal_rule.file_patterns = '*.metal' metal_rule.file_type = 'pattern.proxy' metal_rule.is_editable = '1' metal_rule.run_once_per_architecture = '0' metal_rule.output_files = ["$(DERIVED_FILE_DIR)/$(INPUT_FILE_BASE).air"] metal_rule.input_files = [] metal_rule.output_files_compiler_flags = [] metal_rule.script = "xcrun metal -c $MTL_HEADER_SEARCH_PATHS -fcikernel \"$&#123;INPUT_FILE_PATH&#125;\" -o \"$&#123;SCRIPT_OUTPUT_FILE_0&#125;\"" target.build_rules.append(metal_rule) air_rule = static_installer.pods_project.new(Xcodeproj::Project::Object::PBXBuildRule) UI.puts "Updating #&#123;target.name&#125; rules" air_rule.name = 'Air Build Rule' air_rule.compiler_spec = 'com.apple.compilers.proxy.script' air_rule.file_patterns = '*.air' air_rule.file_type = 'pattern.proxy' air_rule.is_editable = '1' air_rule.run_once_per_architecture = '0' air_rule.output_files = ["$(METAL_LIBRARY_OUTPUT_DIR)/$(INPUT_FILE_BASE).metallib"] air_rule.input_files = [] air_rule.output_files_compiler_flags = [] air_rule.script = "xcrun metallib -cikernel \"$&#123;INPUT_FILE_PATH&#125;\" -o \"$&#123;SCRIPT_OUTPUT_FILE_0&#125;\"" target.build_rules.append(air_rule) static_installer.pods_project.objects_by_uuid[metal_rule.uuid] = metal_rule static_installer.pods_project.objects_by_uuid[air_rule.uuid] = air_rule static_installer.pods_project.save end ... end ... end ... end 最后重新生成、安装gem 12345#!/bin/bashgem uninstall cocoapods-packagergem build cocoapods-packager.gemspecgem install cocoapods-packager podfile使用自定义的cocoapods-packager打出来的二方库 Framework包，包内容里面已经替换成xxx.metallib文件了,所以主工程的podfile pod post hook 要根据二方库的接入方式做下处理。 我这边主工程是用过cocoapod-binary插件管理二方库的加入，源码&amp;静态Framework，一般Release模式提升编译速度，都是以framework方式，Debug模式有时候需要在主工程Debug二方库，可以选择是源码方式接入。 最终的逻辑如下： 1234567891011121314151617post_install do |installer| installer.pods_project.targets.each do |target| ... target.build_configurations.each do |config| ... #Release model, no need execute if config.name != 'Release' &amp;&amp; target.name == 'your target name' puts "===================&gt; #&#123;config.name&#125;" eval(File.open('MetalBuildRule.rb').read) if File.exist? 'MetalBuildRule.rb' # metal shader build rule add_build_rule(target, installer.pods_project) end end endend DONE referencesMetalCIKLReferenceAdd custom build rule with Podfile post_install hookxcodeprojxcode工程文件解析CocoaPods源码与插件断点调试]]></content>
      <categories>
        <category>metal</category>
      </categories>
      <tags>
        <tag>metal</tag>
        <tag>coreimage</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter 1.17共享engine]]></title>
    <url>%2F2020%2F06%2F03%2Fflutter-1-17%E5%85%B1%E4%BA%ABengine%2F</url>
    <content type="text"><![CDATA[前言flutter 升级到 1.17之后，app ios 线上遇到一个crash ,通过官方的 符号表文件 flutter.dsym 还原出堆栈如下 1234560 auto fml::internal::CopyableLambda&lt;flutter::Shell::OnPlatformViewCreated(std::__1::unique_ptr&lt;flutter::Surface, std::__1::default_delete&lt;flutter::Surface&gt; &gt;)::$_8&gt;::operator()&lt;&gt;() const (in Flutter) (make_copyable.h:24)1 auto fml::internal::CopyableLambda&lt;flutter::Shell::OnPlatformViewCreated(std::__1::unique_ptr&lt;flutter::Surface, std::__1::default_delete&lt;flutter::Surface&gt; &gt;)::$_8&gt;::operator()&lt;&gt;() const (in Flutter) (make_copyable.h:24)2 fml::MessageLoopImpl::FlushTasks(fml::FlushType) (in Flutter) (message_loop_impl.cc:129)3 fml::MessageLoopDarwin::OnTimerFire(__CFRunLoopTimer*, fml::MessageLoopDarwin*) (in Flutter) (message_loop_darwin.mm:76)9 fml::MessageLoopDarwin::Run() (in Flutter) (message_loop_darwin.mm:47)10 void* std::__1::__thread_proxy&lt;std::__1::tuple&lt;std::__1::unique_ptr&lt;std::__1::__thread_struct, std::__1::default_delete&lt;std::__1::__thread_struct&gt; &gt;, fml::Thread::Thread(std::__1::basic_string&lt;char, std::__1::char_traits&lt;char&gt;, std::__1::allocator&lt;char&gt; &gt; const&amp;)::$_0&gt; &gt;(void*) (in Flutter) (thread:352) 这里还只能看到crash在engine的c++代码中，具体原因未知 定位我们根据crash 用户的 埋点日志 分析crash前的 使用路径，基本都是打开push 落地到一个flutter页面app 的 第一个tab 也是个 flutter 页面，所以是push 唤起app，连续打开两个flutter页面。手动打开app，点击进到flutter页面是不会crash的（这么简单的路径，如果crash，那就该死了）很快我们就可以通过这个 路径 复现 crash ，能复现就好说。 debug engine源码，可以定位到更具体的地方 surface_ 为 null ，EXC_BAD_ACCESS 野指针 分析定位到了具体的代码位置，接下来分析下野指针的原因xcode中 crash 的时候，看到主线程的 堆栈记录 是从 application 的 didbecomeactive 的 notification发起的由于是 push 唤起app ，有这个通知是对的，crash 是在 共享engine 的 raster 线程。 看代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#pragma mark - Application lifecycle notifications// app 的 首页 flutter 页面会 执行 surfaceUpdated 方法- (void)applicationBecameActive:(NSNotification*)notification &#123; TRACE_EVENT0("flutter", "applicationBecameActive"); if (_viewportMetrics.physical_width) [self surfaceUpdated:YES]; [self goToApplicationLifecycle:@"AppLifecycleState.resumed"];&#125;#pragma mark - Surface creation and teardown updates- (void)surfaceUpdated:(BOOL)appeared &#123; // NotifyCreated/NotifyDestroyed are synchronous and require hops between the UI and raster // thread. if (appeared) &#123; [self installFirstFrameCallback]; [_engine.get() platformViewsController] -&gt; SetFlutterView(_flutterView.get()); [_engine.get() platformViewsController] -&gt; SetFlutterViewController(self); // 这里 [_engine.get() platformView] -&gt; NotifyCreated(); &#125; else &#123; self.displayingFlutterUI = NO; [_engine.get() platformView] -&gt; NotifyDestroyed(); [_engine.get() platformViewsController] -&gt; SetFlutterView(nullptr); [_engine.get() platformViewsController] -&gt; SetFlutterViewController(nullptr); &#125;&#125;void PlatformView::NotifyCreated() &#123; std::unique_ptr&lt;Surface&gt; surface; // Threading: We want to use the platform view on the non-platform thread. // Using the weak pointer is illegal. But, we are going to introduce a latch // so that the platform view is not collected till the surface is obtained. auto* platform_view = this; fml::ManualResetWaitableEvent latch; fml::TaskRunner::RunNowOrPostTask( task_runners_.GetRasterTaskRunner(), [platform_view, &amp;surface, &amp;latch]() &#123; surface = platform_view-&gt;CreateRenderingSurface(); latch.Signal(); &#125;); latch.Wait(); //这里 delegate_.OnPlatformViewCreated(std::move(surface));&#125;// |PlatformView::Delegate|void Shell::OnPlatformViewCreated(std::unique_ptr&lt;Surface&gt; surface) &#123; TRACE_EVENT0("flutter", "Shell::OnPlatformViewCreated"); FML_DCHECK(is_setup_); FML_DCHECK(task_runners_.GetPlatformTaskRunner()-&gt;RunsTasksOnCurrentThread()); // Note: // This is a synchronous operation because certain platforms depend on // setup/suspension of all activities that may be interacting with the GPU in // a synchronous fashion. fml::AutoResetWaitableEvent latch; auto raster_task = fml::MakeCopyable([&amp; waiting_for_first_frame = waiting_for_first_frame_, rasterizer = rasterizer_-&gt;GetWeakPtr(), // surface = std::move(surface), // &amp;latch]() mutable &#123; if (rasterizer) &#123; //这里 rasterizer-&gt;Setup(std::move(surface)); &#125; waiting_for_first_frame.store(true); // Step 3: All done. Signal the latch that the platform thread is // waiting on. latch.Signal(); &#125;); ... &#125;void Rasterizer::Setup(std::unique_ptr&lt;Surface&gt; surface) &#123; surface_ = std::move(surface); if (max_cache_bytes_.has_value()) &#123; SetResourceCacheMaxBytes(max_cache_bytes_.value(), user_override_resource_cache_bytes_); &#125; compositor_context_-&gt;OnGrContextCreated(); // surface_ null，BAD_ACCESS if (surface_-&gt;GetExternalViewEmbedder()) &#123; const auto platform_id = task_runners_.GetPlatformTaskRunner()-&gt;GetTaskQueueId(); const auto gpu_id = task_runners_.GetRasterTaskRunner()-&gt;GetTaskQueueId(); raster_thread_merger_ = fml::MakeRefCounted&lt;fml::RasterThreadMerger&gt;(platform_id, gpu_id); &#125;&#125; 这么一路看下来，surface_怎么会变成null呢？一般情况是，执行 [self surfaceUpdated:NO] 的时候会销毁surface，断点根本都没进去。继续看代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107// push 落地页 flutter 页面 init 的时候，会重新attach 到 engine，会执行setViewController方法- (void)setViewController:(FlutterViewController*)viewController &#123; FML_DCHECK(self.iosPlatformView); _viewController = viewController ? [viewController getWeakPtr] : fml::WeakPtr&lt;FlutterViewController&gt;(); //这里 self.iosPlatformView-&gt;SetOwnerViewController(_viewController); [self maybeSetupPlatformViewChannels]; if (viewController) &#123; __block FlutterEngine* blockSelf = self; self.flutterViewControllerWillDeallocObserver = [[NSNotificationCenter defaultCenter] addObserverForName:FlutterViewControllerWillDealloc object:viewController queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification* note) &#123; [blockSelf notifyViewControllerDeallocated]; &#125;]; &#125; else &#123; self.flutterViewControllerWillDeallocObserver = nil; &#125;&#125;void PlatformViewIOS::SetOwnerViewController(fml::WeakPtr&lt;FlutterViewController&gt; owner_controller) &#123; FML_DCHECK(task_runners_.GetPlatformTaskRunner()-&gt;RunsTasksOnCurrentThread()); std::lock_guard&lt;std::mutex&gt; guard(ios_surface_mutex_); // 重点是这里 if (ios_surface_ || !owner_controller) &#123; // 这里会销毁 NotifyDestroyed(); ios_surface_.reset(); accessibility_bridge_.reset(); &#125; owner_controller_ = owner_controller; // Add an observer that will clear out the owner_controller_ ivar and // the accessibility_bridge_ in case the view controller is deleted. dealloc_view_controller_observer_.reset( [[[NSNotificationCenter defaultCenter] addObserverForName:FlutterViewControllerWillDealloc object:owner_controller_.get() queue:[NSOperationQueue mainQueue] usingBlock:^(NSNotification* note) &#123; // Implicit copy of 'this' is fine. accessibility_bridge_.reset(); owner_controller_.reset(); &#125;] retain]); if (owner_controller_ &amp;&amp; [owner_controller_.get() isViewLoaded]) &#123; this-&gt;attachView(); &#125; // Do not call `NotifyCreated()` here - let FlutterViewController take care // of that when its Viewport is sized. If `NotifyCreated()` is called here, // it can occasionally get invoked before the viewport is sized resulting in // a framebuffer that will not be able to completely attach.&#125;void PlatformView::NotifyDestroyed() &#123; delegate_.OnPlatformViewDestroyed();&#125;// |PlatformView::Delegate|void Shell::OnPlatformViewDestroyed() &#123; TRACE_EVENT0("flutter", "Shell::OnPlatformViewDestroyed"); FML_DCHECK(is_setup_); FML_DCHECK(task_runners_.GetPlatformTaskRunner()-&gt;RunsTasksOnCurrentThread()); // Note: // This is a synchronous operation because certain platforms depend on // setup/suspension of all activities that may be interacting with the GPU in // a synchronous fashion. fml::AutoResetWaitableEvent latch; auto io_task = [io_manager = io_manager_.get(), &amp;latch]() &#123; // Execute any pending Skia object deletions while GPU access is still // allowed. io_manager-&gt;GetIsGpuDisabledSyncSwitch()-&gt;Execute( fml::SyncSwitch::Handlers().SetIfFalse( [&amp;] &#123; io_manager-&gt;GetSkiaUnrefQueue()-&gt;Drain(); &#125;)); // Step 3: All done. Signal the latch that the platform thread is waiting // on. latch.Signal(); &#125;; auto raster_task = [rasterizer = rasterizer_-&gt;GetWeakPtr(), io_task_runner = task_runners_.GetIOTaskRunner(), io_task]() &#123; if (rasterizer) &#123; // 这里 rasterizer-&gt;Teardown(); &#125; // Step 2: Next, tell the IO thread to complete its remaining work. fml::TaskRunner::RunNowOrPostTask(io_task_runner, io_task); &#125;; ...void Rasterizer::Teardown() &#123; compositor_context_-&gt;OnGrContextDestroyed(); // 这里 reset surface_.reset(); last_layer_tree_.reset();&#125; 所以原因 就是 落地页 init 的时候 重新attach 引擎，NotifyDestroyed 方法 最终会销毁 surface，这时候正好raster线程使用 surface_做方法调用。 修复定位到原因，修复就简单了，做下空判断就好了,如果为空 就直接return 123456789101112131415161718192021void Rasterizer::Setup(std::unique_ptr&lt;Surface&gt; surface) &#123; surface_ = std::move(surface); if (!surface_) &#123; FML_DLOG(INFO) &lt;&lt; "Rasterizer::Setup called with no surface."; return; &#125; if (max_cache_bytes_.has_value()) &#123; SetResourceCacheMaxBytes(max_cache_bytes_.value(), user_override_resource_cache_bytes_); &#125; compositor_context_-&gt;OnGrContextCreated(); if (surface_-&gt;GetExternalViewEmbedder()) &#123; const auto platform_id = task_runners_.GetPlatformTaskRunner()-&gt;GetTaskQueueId(); const auto gpu_id = task_runners_.GetRasterTaskRunner()-&gt;GetTaskQueueId(); raster_thread_merger_ = fml::MakeRefCounted&lt;fml::RasterThreadMerger&gt;(platform_id, gpu_id); &#125;&#125; 这里是直接修改了引擎的代码，所以需要重新编译engine 产物，替换掉就搞定了 其他1.17之前的版本 1.12.13 的时候，不确定engine存不存在这个问题，有空再看看。后面github提issue、PR，看看官方怎么看待这个问题，修复应该还有其他办法。]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter 1.17升级]]></title>
    <url>%2F2020%2F05%2F21%2Fflutter-1-17%E5%8D%87%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[升级最近官方发布了flutter 稳定版本1.17.0 ，记录下升级1.17 ios上碰到的的问题 App产物在 1.12.13 的时候，为了支持模拟器运行，会进行 debug 产物 跟 release 产物的merge （lipo create …）debug 产物 x86 、release 产物 arm64 arm7 升级到1.17.0 之后 ，merge报错 lipo 查看下 发现针对模拟器的debug产物 含有arm64 Debug Flutter tool源码， build 里面进行了两次createStubAppFramework（iphone &amp;&amp; simulator）然后做了merge，实际上environment参数里面 iosArchs只有 arch x86，所以问题出在这里 DebugUniveralFramework1234567891011121314151617181920212223242526272829303132333435363738394041@overrideFuture&lt;void&gt; build(Environment environment) async &#123; // Generate a trivial App.framework. final Set&lt;DarwinArch&gt; iosArchs = environment.defines[kIosArchs] ?.split(' ') ?.map(getIOSArchForName) ?.toSet() ?? &lt;DarwinArch&gt;&#123;DarwinArch.arm64&#125;; final File iphoneFile = environment.buildDir.childFile('iphone_framework'); final File simulatorFile = environment.buildDir.childFile('simulator_framework'); final File lipoOutputFile = environment.buildDir.childFile('App'); final RunResult iphoneResult = await createStubAppFramework( iphoneFile, SdkType.iPhone, // Only include 32bit if it is contained in the active architectures. include32Bit: iosArchs.contains(DarwinArch.armv7) ); final RunResult simulatorResult = await createStubAppFramework( simulatorFile, SdkType.iPhoneSimulator, ); if (iphoneResult.exitCode != 0 || simulatorResult.exitCode != 0) &#123; throw Exception('Failed to create App.framework.'); &#125; final List&lt;String&gt; lipoCommand = &lt;String&gt;[ 'xcrun', 'lipo', '-create', iphoneFile.path, simulatorFile.path, '-output', lipoOutputFile.path ]; final RunResult lipoResult = await processUtils.run( lipoCommand, ); if (lipoResult.exitCode != 0) &#123; throw Exception('Failed to create App.framework.'); &#125;&#125; 解决办法 可以通过archs 判断下具体执行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@override Future&lt;void&gt; build(Environment environment) async &#123; // Generate a trivial App.framework. final Set&lt;DarwinArch&gt; iosArchs = environment.defines[kIosArchs] ?.split(' ') ?.map(getIOSArchForName) ?.toSet() ?? &lt;DarwinArch&gt;&#123;DarwinArch.arm64&#125;; final File iphoneFile = environment.buildDir.childFile('iphone_framework'); final File simulatorFile = environment.buildDir.childFile('simulator_framework'); final File lipoOutputFile = environment.buildDir.childFile('App'); RunResult iphoneResult; if(iosArchs.contains(DarwinArch.arm64) || iosArchs.contains(DarwinArch.armv7)) &#123; iphoneResult = await createStubAppFramework( iphoneFile, SdkType.iPhone, // Only include 32bit if it is contained in the active architectures. include32Bit: iosArchs.contains(DarwinArch.armv7) ); if (iphoneResult.exitCode != 0) &#123; throw Exception('(iphoneResult)Failed to create App.framework.'); &#125; &#125; RunResult simulatorResult; if(iosArchs.contains(DarwinArch.x86_64)) &#123; simulatorResult = await createStubAppFramework( simulatorFile, SdkType.iPhoneSimulator, ); if (simulatorResult.exitCode != 0) &#123; throw Exception('(simulatorResult)Failed to create App.framework.'); &#125; &#125; if(simulatorResult == null) &#123; iphoneFile.copySync(lipoOutputFile.path); return; &#125; if(iphoneResult == null) &#123; simulatorFile.copySync(lipoOutputFile.path); return; &#125; final List&lt;String&gt; lipoCommand = &lt;String&gt;[ 'xcrun', 'lipo', '-create', iphoneFile.path, simulatorFile.path, '-output', lipoOutputFile.path ]; final RunResult lipoResult = await processUtils.run( lipoCommand, ); if (lipoResult.exitCode != 0) &#123; throw Exception('Failed to create App.framework.'); &#125; &#125; 突然想到 既然1.17 对debug 产物做了arm64的支持，那我们收集产物是不是可以不用自己做merge，发现是不可以的因为除了App.framework,还有plugin native代码生成的pod静态库 libxxx.a。静态库 是哪里生成的呢？ 这里 build_ios.dart -&gt; buildXcodeProject 123456789101112131415161718...final List&lt;String&gt; buildCommands = &lt;String&gt;[ &apos;/usr/bin/env&apos;, &apos;xcrun&apos;, &apos;xcodebuild&apos;, &apos;-configuration&apos;, configuration,]; ...if (buildForDevice) &#123; buildCommands.addAll(&lt;String&gt;[&apos;-sdk&apos;, &apos;iphoneos&apos;]);&#125; else &#123; buildCommands.addAll(&lt;String&gt;[&apos;-sdk&apos;, &apos;iphonesimulator&apos;, &apos;-arch&apos;, &apos;x86_64&apos;]);&#125;... 这里只针对x86做了xcode build，所以还是要自己merge的…]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter tool debug]]></title>
    <url>%2F2020%2F03%2F13%2Fflutter-tool-debug%2F</url>
    <content type="text"><![CDATA[Flutterflutter 开发过程中，少不了会运行一些 flutter 命令 ，比如 flutter build xxx 、 flutter run 等等看下 bin/flutter 脚本，背后都是 flutter_tool 在执行各种操作。 12345678FLUTTER_TOOLS_DIR="$FLUTTER_ROOT/packages/flutter_tools"SNAPSHOT_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.snapshot"STAMP_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.stamp"SCRIPT_PATH="$FLUTTER_TOOLS_DIR/bin/flutter_tools.dart"DART_SDK_PATH="$FLUTTER_ROOT/bin/cache/dart-sdk""$DART" --packages="$FLUTTER_TOOLS_DIR/.packages" $FLUTTER_TOOL_ARGS "$SNAPSHOT_PATH" "$@" 关于 debug flutter_tool,就不说的了，自行google一下。。 这里记录下 debug 过程中遇到的问题 Exception指定端口导出FLUTTER_TOOL_ARGS 环境变量 export FLUTTER_TOOL_ARGS=&quot;--pause_isolates_on_start --enable-vm-service:65432&quot; run 起来 会停在这里… Observatory listening on http://127.0.0.1:65432/ZbWg3veM6kY=/ IDE 中打开flutter tool 项目，配置 dart remote debug attach 出现以下错误信息 123Failed to connect to the VM observatory service: java.io.IOException: Failed to connect: ws://127.0.0.1:65432/wsCaused by: de.roderick.weberknecht.WebSocketException: error while creating socket to ws://127.0.0.1:65432/wsCaused by: java.net.ConnectException: Connection refused (Connection refused) 原因 ： http://127.0.0.1:65432/ZbWg3veM6kY=/ 后面多了个ZbWg3veM6kY，这是一种认证码，是为了安全原因，防止应用被远程调试。可以通过参数–disable-service-auth-codes进行关闭。 export FLUTTER_TOOL_ARGS=&quot;--pause_isolates_on_start --enable-vm-service:65432 --disable-service-auth-codes&quot;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter共享engine]]></title>
    <url>%2F2020%2F03%2F10%2Fflutter%E5%85%B1%E4%BA%ABengine%2F</url>
    <content type="text"><![CDATA[flutter 共享引擎 问题记录共享引擎，就是只有一个 flutter engine，每个页面一个 flutterviewcontroller。flutter页面 切换，引擎会相应的 detach atach 最近 升级 flutter 到 v1.12.13 版本后，贡献引擎遇到的几个问题 记录下 present flutter 页面这个其实不是v1.12.13出现的问题 flutterPageA present flutterPageB 会 出现 pageA的 viewDidDisappear 比 pageB的 viewDidAppear 后执行 12345678910- (void)viewDidDisappear:(BOOL)animated &#123; [super viewDidDisappear:animated]; //处理下present 页面卡死的情况 if ([WD_FLUTTER_ENGINE flutterViewController] != self) &#123; [WD_FLUTTER_ENGINE resume]; [(WDFlutterViewContainer *)[WD_FLUTTER_ENGINE flutterViewController] surfaceUpdated:YES]; &#125; else &#123; [WD_FLUTTER_ENGINE detach]; &#125;&#125; 从flutter 返回到 native页面在 v.1.12.13之前 flutter popto native 无需处理v.1.12.13 出现crash 123456789101112131415161718192021222324[VERBOSE-2:FlutterObservatoryPublisher.mm(131)] Could not register as server for FlutterObservatoryPublisher. Check your network settings and relaunch the application.SCNetworkReachabilitySetDispatchQueue() failed: Invalid argumentSCNetworkReachabilitySetDispatchQueue() failed: Invalid argumentlocalConnectionInitializedStatus:2localConnectionInitializedStatus:2SCNetworkReachabilitySetDispatchQueue() failed: Invalid argument[Bugly] Fatal signal(11) raised.[Bugly] Trapped fatal signal &apos;SIGSEGV(11)&apos; ( &quot;0 Flutter 0x000000010516f92c _ZNK3fml8internal14CopyableLambdaIZN7flutter5Shell21OnPlatformViewCreatedENSt3__110unique_ptrINS2_7SurfaceENS4_14default_deleteIS6_EEEEE3$_8EclIJEEEDaDpOT_ + 236&quot;, &quot;1 Flutter 0x000000010516f928 _ZNK3fml8internal14CopyableLambdaIZN7flutter5Shell21OnPlatformViewCreatedENSt3__110unique_ptrINS2_7SurfaceENS4_14default_deleteIS6_EEEEE3$_8EclIJEEEDaDpOT_ + 232&quot;, &quot;2 Flutter 0x0000000105123cf4 _ZN3fml15MessageLoopImpl10FlushTasksENS_9FlushTypeE + 1700&quot;, &quot;3 Flutter 0x0000000105126000 _ZN3fml17MessageLoopDarwin11OnTimerFireEP16__CFRunLoopTimerPS0_ + 32&quot;, &quot;4 CoreFoundation 0x0000000184cd3aa8 0x0000000184be5000 + 977576&quot;, &quot;5 CoreFoundation 0x0000000184cd376c 0x0000000184be5000 + 976748&quot;, &quot;6 CoreFoundation 0x0000000184cd3010 0x0000000184be5000 + 974864&quot;, &quot;7 CoreFoundation 0x0000000184cd0b60 0x0000000184be5000 + 965472&quot;, &quot;8 CoreFoundation 0x0000000184bf0da8 CFRunLoopRunSpecific + 552&quot;, &quot;9 Flutter 0x0000000105125edc _ZN3fml17MessageLoopDarwin3RunEv + 88&quot;, &quot;10 Flutter 0x0000000105125684 _ZNSt3__114__thread_proxyINS_5tupleIJNS_10unique_ptrINS_15__thread_structENS_14default_deleteIS3_EEEEZN3fml6ThreadC1ERKNS_12basic_stringIcNS_11char_traitsIcEENS_9allocatorIcEEEEE3$_0EEEEEPvSJ_ + 200&quot;, &quot;11 libsystem_pthread.dylib 0x0000000184951220 0x000000018494f000 + 8736&quot;, &quot;12 libsystem_pthread.dylib 0x0000000184951110 0x000000018494f000 + 8464&quot;)Application finished. 处理办法： flutterVc dealloc 或者 disappear 的时候 执行 flutterEngine detach]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter engine 定制]]></title>
    <url>%2F2020%2F03%2F05%2Fflutter-engine-%E5%AE%9A%E5%88%B6%2F</url>
    <content type="text"><![CDATA[…使用Flutter开发的时候最直接接触的并不是 Flutter Engine 而是 Flutter Framework(https://github.com/flutter/flutter)在flutter framework 的 目录里面 有编译好的engine 产物 简单说就是， 编译引擎 替换 产物文件就好了 路径 flutter_path/bin/cache/artifacts/engine/ios 参考Flutter Engine定制流程Flutter Engine 编译指北]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter eventChannel crash on ios]]></title>
    <url>%2F2019%2F10%2F21%2Fflutter-eventChannel-crash-on-ios%2F</url>
    <content type="text"><![CDATA[flutter issuecrash 记录一次困扰了很久的 flutter event channel crash EventChannel dart1234567891011121314151617181920212223242526272829303132333435363738394041Stream&lt;dynamic&gt; receiveBroadcastStream([ dynamic arguments ]) &#123; final MethodChannel methodChannel = MethodChannel(name, codec); StreamController&lt;dynamic&gt; controller; controller = StreamController&lt;dynamic&gt;.broadcast(onListen: () async &#123; defaultBinaryMessenger.setMessageHandler(name, (ByteData reply) async &#123; if (reply == null) &#123; controller.close(); &#125; else &#123; try &#123; controller.add(codec.decodeEnvelope(reply)); &#125; on PlatformException catch (e) &#123; controller.addError(e); &#125; &#125; return null; &#125;); try &#123; await methodChannel.invokeMethod&lt;void&gt;('listen', arguments); &#125; catch (exception, stack) &#123; FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: stack, library: 'services library', context: ErrorDescription('while activating platform stream on channel $name'), )); &#125; &#125;, onCancel: () async &#123; defaultBinaryMessenger.setMessageHandler(name, null); try &#123; await methodChannel.invokeMethod&lt;void&gt;('cancel', arguments); &#125; catch (exception, stack) &#123; FlutterError.reportError(FlutterErrorDetails( exception: exception, stack: stack, library: 'services library', context: ErrorDescription('while de-activating platform stream on channel $name'), )); &#125; &#125;); return controller.stream; &#125; FlutterChannel.mm1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static void SetStreamHandlerMessageHandlerOnChannel(NSObject&lt;FlutterStreamHandler&gt;* handler, NSString* name, NSObject&lt;FlutterBinaryMessenger&gt;* messenger, NSObject&lt;FlutterMethodCodec&gt;* codec) &#123; __block FlutterEventSink currentSink = nil; FlutterBinaryMessageHandler messageHandler = ^(NSData* message, FlutterBinaryReply callback) &#123; FlutterMethodCall* call = [codec decodeMethodCall:message]; if ([call.method isEqual:@"listen"]) &#123; if (currentSink) &#123; FlutterError* error = [handler onCancelWithArguments:nil]; if (error) NSLog(@"Failed to cancel existing stream: %@. %@ (%@)", error.code, error.message, error.details); &#125; currentSink = ^(id event) &#123; if (event == FlutterEndOfEventStream) [messenger sendOnChannel:name message:nil]; else if ([event isKindOfClass:[FlutterError class]]) [messenger sendOnChannel:name message:[codec encodeErrorEnvelope:(FlutterError*)event]]; else [messenger sendOnChannel:name message:[codec encodeSuccessEnvelope:event]]; &#125;; FlutterError* error = [handler onListenWithArguments:call.arguments eventSink:currentSink]; if (error) callback([codec encodeErrorEnvelope:error]); else callback([codec encodeSuccessEnvelope:nil]); &#125; else if ([call.method isEqual:@"cancel"]) &#123; if (!currentSink) &#123; callback( [codec encodeErrorEnvelope:[FlutterError errorWithCode:@"error" message:@"No active stream to cancel" details:nil]]); return; &#125; currentSink = nil; FlutterError* error = [handler onCancelWithArguments:call.arguments]; if (error) callback([codec encodeErrorEnvelope:error]); else callback([codec encodeSuccessEnvelope:nil]); &#125; else &#123; callback(nil); &#125; &#125;; [messenger setMessageHandlerOnChannel:name binaryMessageHandler:messageHandler];&#125; EventSink正常结束stream流 eventSink(FlutterEndOfEventStream) ，异常结束stream流 eventSink(FlutterError) 都会回调执行 onCancel 参考Flutter 与 Native(iOS) 通信原理深入Flutter技术内幕:Platform Channel设计与实现]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter ios 13 dark mode]]></title>
    <url>%2F2019%2F10%2F14%2Fflutter-ios-13-dark-mode%2F</url>
    <content type="text"><![CDATA[前言ios 13 开启 dark model,flutter页面status bar文字一直是白色 flutter issues 1SystemChrome.setSystemUIOverlayStyle(SystemUiOverlayStyle.dark); 设置dark style 并没有用 SystemChrome12345678910111213141516171819202122232425static void setSystemUIOverlayStyle(SystemUiOverlayStyle style) &#123; assert(style != null); if (_pendingStyle != null) &#123; // The microtask has already been queued; just update the pending value. _pendingStyle = style; return; &#125; if (style == _latestStyle) &#123; // Trivial success: no microtask has been queued and the given style is // already in effect, so no need to queue a microtask. return; &#125; _pendingStyle = style; scheduleMicrotask(() &#123; assert(_pendingStyle != null); if (_pendingStyle != _latestStyle) &#123; SystemChannels.platform.invokeMethod&lt;void&gt;( 'SystemChrome.setSystemUIOverlayStyle', _pendingStyle._toMap(), ); _latestStyle = _pendingStyle; &#125; _pendingStyle = null; &#125;); &#125; FlutterPlatformPlugin1234567891011121314151617181920212223242526272829- (void)setSystemChromeSystemUIOverlayStyle:(NSDictionary*)message &#123; NSString* style = message[@"statusBarBrightness"]; if (style == (id)[NSNull null]) return; UIStatusBarStyle statusBarStyle; if ([style isEqualToString:@"Brightness.dark"]) statusBarStyle = UIStatusBarStyleLightContent; else if ([style isEqualToString:@"Brightness.light"]) statusBarStyle = UIStatusBarStyleDefault; else return; NSNumber* infoValue = [[NSBundle mainBundle] objectForInfoDictionaryKey:@"UIViewControllerBasedStatusBarAppearance"]; Boolean delegateToViewController = (infoValue == nil || [infoValue boolValue]); if (delegateToViewController) &#123; // This notification is respected by the iOS embedder [[NSNotificationCenter defaultCenter] postNotificationName:@(kOverlayStyleUpdateNotificationName) object:nil userInfo:@&#123;@(kOverlayStyleUpdateNotificationKey) : @(statusBarStyle)&#125;]; &#125; else &#123; // Note: -[UIApplication setStatusBarStyle] is deprecated in iOS9 // in favor of delegating to the view controller [[UIApplication sharedApplication] setStatusBarStyle:statusBarStyle]; &#125;&#125; engine 源码中 可以看到 没有 UIStatusBarStyleDarkContent 尝试 去掉 info.plist 中的 UIViewControllerBasedStatusBarAppearance 然后 监听 通知 1234567[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(appStatusBar:) name:@"io.flutter.plugin.platform.SystemChromeOverlayNotificationName" object:nil];- (void)appStatusBar:(id)notification &#123; if (@available(iOS 13.0, *)) &#123; [UIApplication sharedApplication].statusBarStyle = UIStatusBarStyleDarkContent; &#125;&#125;]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>ios</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mustache之dart]]></title>
    <url>%2F2019%2F05%2F31%2Fmustache%E4%B9%8Bdart%2F</url>
    <content type="text"><![CDATA[前言Mustache 是一个 logic-less （轻逻辑）模板解析引擎，可以应用在 js、PHP、Python、Perl 等多种编程语言中。这里主要是看dart中的应用。 模板语法很简单 看这里1234567&#123;&#123;keyName&#125;&#125; &#123;&#123;#keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;&#123;&#123;^keyName&#125;&#125; &#123;&#123;/keyName&#125;&#125;&#123;&#123;.&#125;&#125;&#123;&#123;&gt;partials&#125;&#125;&#123;&#123;&#123;keyName&#125;&#125;&#125;&#123;&#123;!comments&#125;&#125; 使用在flutter项目中，使用annation router注解的方式生成路由表管理类 RouterManager ，以及业务相关的类文件（ios android）在使用mustache之前，是通过stringbuff 的方式拼接字符串，也可以完成，但是阅读性比较差。 之前123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/// 生成路由表类 StringBuffer sb = new StringBuffer(); sb..write(_createImport())..write(_createClazz(element.name)); return sb.toString();/// 生成路由表类的 import 信息 String _createImport() &#123; StringBuffer sb = new StringBuffer(); sb ..writeln("import 'package:flutter/material.dart';") ..writeln("import 'package:hybrid_router/hybrid_router.dart';"); /// import page collector.importClazzList.forEach((clazz) &#123; sb.writeln("import '$clazz';"); &#125;); return sb.toString(); &#125; /// 生成路由表类的 clazz 信息 String _createClazz(String className) &#123; StringBuffer sb = new StringBuffer(); /// start class sb.writeln("class \$$className &#123;"); /// generateRoute function sb ..writeln(" Map&lt;String, HybridWidgetBuilder&gt; generateRoutes()&#123;") ..writeln(" return &#123;"); collector.routeMap.forEach((key, value) &#123; String flutterPath = value.flutterPath; sb ..writeln(" '$flutterPath': (BuildContext context, Object args) &#123;") ..writeln(" $&#123;_createInstance(value)&#125;") ..writeln(" &#125;,"); &#125;); sb..writeln(" &#125;;")..writeln(" &#125;"); /// generateSpm function sb ..writeln(" Map&lt;String, String&gt; generateSpm() &#123;") ..writeln(" return &#123;"); collector.routeMap.forEach((key, value) &#123; String flutterSpm = value.flutterSpm; String flutterPath = value.flutterPath; if (flutterSpm?.isNotEmpty == true) &#123; sb.writeln(" '$flutterPath': '$flutterSpm',"); &#125; &#125;); sb..writeln(" &#125;;")..writeln(" &#125;"); /// end class sb.writeln("&#125;"); return sb.toString(); &#125; 之后1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/// 生成路由表类 _createRouteManager(element.name); String _createRouteManager(String className) &#123; return VDTemplate.routerManagerTemplate().renderString(&#123; 'classname':className, 'classes':collector.importClazzList, 'routes':collector.routeMap.values, 'createInstance':(LambdaContext ctx) &#123; CollectorItem item = ctx.lookup('.'); return _createInstance(item); &#125; &#125;); &#125; static Template routerManagerTemplate() &#123; var source = '''&#123;&#123;&gt; import&#125;&#125;&#123;&#123;&gt; clazz&#125;&#125; '''; Map&lt;String,Template&gt; map = &#123; "import":VDTemplate.importTemplate(), "clazz":VDTemplate.claszzTemplate() &#125;; return new Template(source,partialResolver: (String name) =&gt; map[name]); &#125; static Template importTemplate() &#123; var source = '''import 'package:flutter/material.dart';import 'package:hybrid_router/hybrid_router.dart';&#123;&#123;# classes &#125;&#125;import '&#123;&#123;&#123;.&#125;&#125;&#125;';&#123;&#123;/ classes &#125;&#125; '''; return new Template(source); &#125; static Template claszzTemplate() &#123; var source = '''class \$&#123;&#123;classname&#125;&#125; &#123; Map&lt;String, HybridWidgetBuilder&gt; generateRoutes()&#123; return &#123; &#123;&#123;#routes&#125;&#125; '&#123;&#123;flutterPath&#125;&#125;': (BuildContext context, Object args) &#123; &#123;&#123;createInstance&#125;&#125; &#125;, &#123;&#123;/routes&#125;&#125; &#125;; &#125; Map&lt;String, String&gt; generateSpm() &#123; return &#123; &#123;&#123;#routes&#125;&#125; &#123;&#123;# flutterSpm&#125;&#125; '&#123;&#123;flutterPath&#125;&#125;': '&#123;&#123;flutterSpm&#125;&#125;', &#123;&#123;/ flutterSpm&#125;&#125; &#123;&#123;/routes&#125;&#125; &#125;; &#125; &#125; '''; return new Template(source); &#125; 对比看下，使用mustache之后，可读性好很多，基本保持了代码结构 总结 字符串数组，可以使用{{.}} 对象数据，可以跟普通的hash一样，直接用{{对象的属性}}，mustache内部通过dart反射拿到属性值 使用partials 拆分template 增加可读性 通过lambda函数执行dart方法，也可以做到拆分的作用 lambdaContext.loopup(&quot;.&quot;) 可以获取对象实例，进而可以参数传递 mustache内部renderstring也是通过stringbuff的方式实现 参考链接mustache 1.1.1Flutter路由管理]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
        <tag>mustache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jvm调优]]></title>
    <url>%2F2019%2F05%2F23%2Fjvm%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[jps输出JVM中运行的进程状态信息 1234-q 不输出类名、Jar名和传入main方法的参数-m 输出传入main方法的参数-l 输出main类或Jar的全限名-v 输出传入JVM的参数 jps -mlv找到java应用的pid jstack根据java应用pid ,查看进程中线程堆栈信息 jstack pid top找出该进程内最耗费CPU的线程 top -Hp pid 转为十六进制printf &quot;%x\n&quot; 线程id 输出进程的堆栈信息，然后根据线程ID的十六进制值grepjstack pid | grep 十六进制线程id jmap查看堆内存使用状况jmap -heap pid 进程内存使用情况dump到文件中 结合MAT工具分析jmap -dump:format=b,file=dumpFileName pid jhatjhat -port 9998 /tmp/dump.datlocalhost:9998 查看内存对象情况 （不如MAT直观）]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vmstatu]]></title>
    <url>%2F2019%2F05%2F22%2Fvmstatus%2F</url>
    <content type="text"><![CDATA[vmstatuvmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。相比top，可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。 1234$vmstatprocs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 215220 0 771404 0 0 2 15 0 1 0 0 100 0 0 一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数 12345$vmstat 2 2procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 0 0 0 202924 0 785780 0 0 2 15 0 1 0 0 100 0 0 0 0 0 203032 0 785812 0 0 0 155 748 1382 0 0 100 0 0 第二个参数如果没有，就会一直采集（ctrl+c 结束） 12345678$vmstat 2procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu----- r b swpd free buff cache si so bi bo in cs us sy id wa st 1 0 0 194712 0 794728 0 0 2 15 0 1 0 0 100 0 0 0 0 0 194696 0 794768 0 0 0 50 782 1368 0 0 100 0 0 0 0 0 193828 0 794776 0 0 0 108 752 1156 0 0 100 0 0 0 0 0 193952 0 794804 0 0 0 4 601 997 0 0 100 0 0^C 字段procs r 等待运行的进程数 b 处在非中断睡眠状态的进程数 memory （KB） swpd 虚拟内存使用大小 注意：如果swpd的值不为0，但是SI，SO的值长期为0，这种情况不会影响系统性能。 free 空闲的内存 buff 用作缓冲的内存大小 cache 用作缓存的内存大小 注意：如果cache的值大的时候，说明cache处的文件数多，如果频繁访问到的文件都能被cache处，那么磁盘的读IO bi会非常小。 swap si 从交换区写到内存的大小 so 每秒写入交换区的内存大小 内存够用的时候，这2个值都是0，如果这2个值长期大于0时，系统性能会受到影响，磁盘IO和CPU资源都会被消耗。有些朋友看到空闲内存（free）很少的或接近于0时，就认为内存不够用了，不能光看这一点，还要结合si和so，如果free很少，但是si和so也很少（大多时候是0），那么不用担心，系统性能这时不会受到影响的。 io bi 每秒读取的块数 bo 每秒写入的块数 注意：随机磁盘读写的时候，这2个值越大（如超出1024k)，能看到CPU在IO等待的值也会越大。 system in 每秒中断数，包括时钟中断。 cs 每秒上下文切换数。 注意：上面2个值越大，会看到由内核消耗的CPU时间会越大。 cpu us 用户进程执行时间(user time) 注意： us的值比较高时，说明用户进程消耗的CPU时间多，但是如果长期超50%的使用，那么我们就该考虑优化程序算法或者进行加速。 sy 系统进程执行时间(system time) 注意：sy的值高时，说明系统内核消耗的CPU资源多，这并不是良性表现，我们应该检查原因。 id 空闲时间(包括IO等待时间),中央处理器的空闲时间 。以百分比表示。 wa 等待IO时间百分比 注意：wa的值高时，说明IO等待比较严重，这可能由于磁盘大量作随机访问造成，也有可能磁盘出现瓶颈（块操作）。 1234567891011121314151617181920212223242526Procsr: The number of processes waiting for run time.b: The number of processes in uninterruptible sleep.Memoryswpd: the amount of virtual memory used.free: the amount of idle memory.buff: the amount of memory used as buffers.cache: the amount of memory used as cache.inact: the amount of inactive memory. (-a option)active: the amount of active memory. (-a option)Swapsi: Amount of memory swapped in from disk (/s).so: Amount of memory swapped to disk (/s).IObi: Blocks received from a block device (blocks/s).bo: Blocks sent to a block device (blocks/s).Systemin: The number of interrupts per second, including the clock.cs: The number of context switches per second.CPUThese are percentages of total CPU time.us: Time spent running non-kernel code. (user time, including nice time)sy: Time spent running kernel code. (system time)id: Time spent idle. Prior to Linux 2.5.41, this includes IO-wait time.wa: Time spent waiting for IO. Prior to Linux 2.5.41, included in idle.st: Time stolen from a virtual machine. Prior to Linux 2.6.11, unknown.]]></content>
      <tags>
        <tag>java</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter plugin registry]]></title>
    <url>%2F2019%2F05%2F17%2Fflutter-plugin-registry%2F</url>
    <content type="text"><![CDATA[前言首先这里有三个形似得英文单词registry, registrar and registrant分别对应注册局，注册商和注册人。把它们翻译到现实的生活场景中的角色其实是一个“注册人通过注册商，更新注册信息后，注册商把信息传递给注册局进行保存”的过程。 注册人：GeneratedPluginRegistrant注册局：[(FlutterViewController*)rootViewController pluginRegistry] == flutterEngine注册商：FlutterEngineRegistrar Flutter Applicationflutter create -t plugin my_plugin xcode 打开 my_plugin/example/ios路径下的 Runner工程 AppDelegate12345678910@implementation AppDelegate- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123; [GeneratedPluginRegistrant registerWithRegistry:self]; // Override point for customization after application launch. return [super application:application didFinishLaunchingWithOptions:launchOptions];&#125;@end GeneratedPluginRegistrant1234567@implementation GeneratedPluginRegistrant+ (void)registerWithRegistry:(NSObject&lt;FlutterPluginRegistry&gt;*)registry &#123; [MyPlugin registerWithRegistrar:[registry registrarForPlugin:@"MyPlugin"]];&#125;@end AppDelegate继承FlutterAppDelegate FlutterAppDelegate123456789#pragma mark - FlutterPluginRegistry methods. All delegating to the rootViewController- (NSObject&lt;FlutterPluginRegistrar&gt;*)registrarForPlugin:(NSString*)pluginKey &#123; UIViewController* rootViewController = _window.rootViewController; if ([rootViewController isKindOfClass:[FlutterViewController class]]) &#123; return [[(FlutterViewController*)rootViewController pluginRegistry] registrarForPlugin:pluginKey]; &#125; return nil;&#125; FlutterViewController123- (id&lt;FlutterPluginRegistry&gt;)pluginRegistry &#123; return _engine;&#125; FlutterEngineRegistrar1234567891011121314151617181920212223@implementation FlutterEngineRegistrar &#123; NSString* _pluginKey; FlutterEngine* _flutterEngine;&#125;- (instancetype)initWithPlugin:(NSString*)pluginKey flutterEngine:(FlutterEngine*)flutterEngine &#123; self = [super init]; NSAssert(self, @"Super init cannot be nil"); _pluginKey = [pluginKey retain]; _flutterEngine = [flutterEngine retain]; return self;&#125;- (void)addMethodCallDelegate:(NSObject&lt;FlutterPlugin&gt;*)delegate channel:(FlutterMethodChannel*)channel &#123; [channel setMethodCallHandler:^(FlutterMethodCall* call, FlutterResult result) &#123; [delegate handleMethodCall:call result:result]; &#125;];&#125;- (NSObject&lt;FlutterBinaryMessenger&gt;*)messenger &#123; return _flutterEngine;&#125; MyPlugin123456789101112131415161718@implementation MyPlugin+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar &#123; FlutterMethodChannel* channel = [FlutterMethodChannel methodChannelWithName:@"my_plugin" binaryMessenger:[registrar messenger]]; MyPlugin* instance = [[MyPlugin alloc] init]; [registrar addMethodCallDelegate:instance channel:channel];&#125;- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result &#123; if ([@"getPlatformVersion" isEqualToString:call.method]) &#123; result([@"iOS " stringByAppendingString:[[UIDevice currentDevice] systemVersion]]); &#125; else &#123; result(FlutterMethodNotImplemented); &#125;&#125;@end FlutterMethodChannel1234567891011121314151617181920212223242526272829- (instancetype)initWithName:(NSString*)name binaryMessenger:(NSObject&lt;FlutterBinaryMessenger&gt;*)messenger codec:(NSObject&lt;FlutterMethodCodec&gt;*)codec &#123; self = [super init]; NSAssert(self, @"Super init cannot be nil"); _name = [name retain]; _messenger = [messenger retain]; //flutterEngine _codec = [codec retain]; return self;&#125;- (void)setMethodCallHandler:(FlutterMethodCallHandler)handler &#123; if (!handler) &#123; [_messenger setMessageHandlerOnChannel:_name binaryMessageHandler:nil]; return; &#125; FlutterBinaryMessageHandler messageHandler = ^(NSData* message, FlutterBinaryReply callback) &#123; FlutterMethodCall* call = [_codec decodeMethodCall:message]; handler(call, ^(id result) &#123; if (result == FlutterMethodNotImplemented) callback(nil); else if ([result isKindOfClass:[FlutterError class]]) callback([_codec encodeErrorEnvelope:(FlutterError*)result]); else callback([_codec encodeSuccessEnvelope:result]); &#125;); &#125;; [_messenger setMessageHandlerOnChannel:_name binaryMessageHandler:messageHandler];&#125; FlutterEngine123456789101112131415#pragma mark - FlutterPluginRegistry- (NSObject&lt;FlutterPluginRegistrar&gt;*)registrarForPlugin:(NSString*)pluginKey &#123; NSAssert(self.pluginPublications[pluginKey] == nil, @"Duplicate plugin key: %@", pluginKey); self.pluginPublications[pluginKey] = [NSNull null]; return [[FlutterEngineRegistrar alloc] initWithPlugin:pluginKey flutterEngine:self];&#125;- (void)setMessageHandlerOnChannel:(NSString*)channel binaryMessageHandler:(FlutterBinaryMessageHandler)handler &#123; NSAssert(channel, @"The channel must not be null"); FML_DCHECK(_shell &amp;&amp; _shell-&gt;IsSetup()); self.iosPlatformView-&gt;GetPlatformMessageRouter().SetMessageHandler(channel.UTF8String, handler);&#125; FlutterBinaryMessage123456789101112131415161718/** * A message reply callback. * * Used for submitting a binary reply back to a Flutter message sender. Also used * in for handling a binary message reply received from Flutter. * * @param reply The reply. */typedef void (^FlutterBinaryReply)(NSData* _Nullable reply);/** * A strategy for handling incoming binary messages from Flutter and to send * asynchronous replies back to Flutter. * * @param message The message. * @param reply A callback for submitting an asynchronous reply to the sender. */typedef void (^FlutterBinaryMessageHandler)(NSData* _Nullable message, FlutterBinaryReply reply);]]></content>
  </entry>
  <entry>
    <title><![CDATA[sublime text 3]]></title>
    <url>%2F2019%2F05%2F14%2Fsublime-text-3%2F</url>
    <content type="text"><![CDATA[sublime text3 install package controlTools -&gt; Install package control 报错信息工具栏View 点击show console 或者快捷键 ctrl+` 打开控制台看下如下报错信息 1234Visit https://packagecontrol.io/installation for manual instructionsError installing Package Control: HTTPS error encountered, falling back to HTTP - &lt;urlopen error [Errno 60] Operation timed out&gt;Error installing Package Control: HTTP error encountered, giving up - &lt;urlopen error [Errno 60] Operation timed out&gt;error: An error occurred installing Package Control 处理办法绑定域名 1250.116.34.243 sublime.wbond.net50.116.34.243 packagecontrol.io install package报错信息There are no packages available for installation 处理办法下载 channel_v3.json 文件 （google一下） 修改package control.sublime-settings 123&quot;channels&quot;: [ &quot;/path/to/channel_v3.json&quot;]]]></content>
  </entry>
  <entry>
    <title><![CDATA[vim shortcuts]]></title>
    <url>%2F2019%2F05%2F14%2Fvim-shortcuts%2F</url>
    <content type="text"><![CDATA[]]></content>
  </entry>
  <entry>
    <title><![CDATA[Flutter之Dart编译]]></title>
    <url>%2F2019%2F05%2F10%2FFlutter%E4%B9%8BDart%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[前言App中使用flutter已经有段时间了，最近遇到一个bug记录一下。更新flutter module工程pubspec plugin依赖，App工程中pod update之后，从功能表现上看依然是老代码。第一感觉是缓存导致的，xcode clean 以及删除DerivedData目录重新build依然不行，flutter module工程中执行flutter clean然后xcode build是正常的，所以应该是dart编译产物有缓存导致的。接下来看下dart编译过程。 编译12cd path/to/flutter moduleflutter build ios --debug --simulator 进入到flutter module工程目录 执行flutter build ios命令 12345Running Xcode build... ├─Assembling Flutter resources... 3.6s └─Compiling, linking and signing... 25.4sXcode build done. 43.9s 可以看到会进行xcode build，进到.ios目录通过xcode打开Runner工程 可以看到build phases中这样一段脚本，这里就是执行dart代码编译的入口。 xcode_backend.sh进入到脚本所在目录，看下build对应的方法 BuildApp 12345678910111213if [[ $# == 0 ]]; then # Backwards-compatibility: if no args are provided, build. BuildAppelse case $1 in "build") BuildApp ;; "thin") ThinAppFrameworks ;; "embed") EmbedFlutterFrameworks ;; esacfi 123456789101112131415161718192021222324252627282930BuildApp() &#123; ... StreamOutput " ├─Assembling Flutter resources..." RunCommand "$&#123;FLUTTER_ROOT&#125;/bin/flutter" --suppress-analytics \ $&#123;verbose_flag&#125; \ build bundle \ --target-platform=ios \ --target="$&#123;target_path&#125;" \ --$&#123;build_mode&#125; \ --depfile="$&#123;build_dir&#125;/snapshot_blob.bin.d" \ --asset-dir="$&#123;derived_dir&#125;/App.framework/$&#123;assets_path&#125;" \ $&#123;precompilation_flag&#125; \ $&#123;flutter_engine_flag&#125; \ $&#123;local_engine_flag&#125; \ $&#123;track_widget_creation_flag&#125; if [[ $? -ne 0 ]]; then EchoError "Failed to package $&#123;project_path&#125;." exit -1 fi StreamOutput "done" StreamOutput " └─Compiling, linking and signing..." RunCommand popd &gt; /dev/null echo "Project $&#123;project_path&#125; built and packaged successfully." return 0&#125; 可以看到 ├─Assembling Flutter resources… 在build ios 执行过程中出现过，flutter build bundle 就会开始真正的dart编译–depfile 指定参与编译的dart文件路径集合–asset-dir 指定资源产物的目录 flutter命令路径 $FLUTTER_ROOT/bin/flutter 123456789101112...FLUTTER_TOOLS_DIR="$FLUTTER_ROOT/packages/flutter_tools"SNAPSHOT_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.snapshot"STAMP_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.stamp"SCRIPT_PATH="$FLUTTER_TOOLS_DIR/bin/flutter_tools.dart"DART_SDK_PATH="$FLUTTER_ROOT/bin/cache/dart-sdk"DART="$DART_SDK_PATH/bin/dart"PUB="$DART_SDK_PATH/bin/pub""$DART" $FLUTTER_TOOL_ARGS "$SNAPSHOT_PATH" "$@" flutter_toools.snapshot实际上就是$FLUTTER_ROOT/packages/flutter_tools这个项目编译生成的snapshot文件 所以flutter build bundle 就是使用dart来执行flutter_tools项目的main方法 flutter_tools路径 $FLUTTER_ROOT/packages/flutter_tools main方法定义 $FLUTTER_ROOT/packages/flutter_tools/bin/flutter_tools.dart 123void main(List&lt;String&gt; args) &#123; executable.main(args);&#125; 再看看 lib/executable.dart ,在这里会预先创建好每一种命令对应的对象command，通过解析args参数找到对应的command。在BuildCommand类中 123456789BuildCommand(&#123;bool verboseHelp = false&#125;) &#123; addSubcommand(BuildApkCommand(verboseHelp: verboseHelp)); addSubcommand(BuildAppBundleCommand(verboseHelp: verboseHelp)); addSubcommand(BuildAotCommand()); addSubcommand(BuildIOSCommand()); addSubcommand(BuildFlxCommand()); addSubcommand(BuildBundleCommand(verboseHelp: verboseHelp)); addSubcommand(BuildWebCommand()); &#125; 看到BuildIOSCommand 以及 BuildBundleCommand的创建。BuildIOSCommand 就是前面提到的flutter build ios 会执行到的，这里我们重点看下BuildBundleCommand是如何编译dart代码的？编译后生成了哪些资源？这些资源都是些什么？ BuildBundleCommand app.dill : 这就是dart代码编译后的二级制文件 Frontend_server.d : 这里面放的是frontend_server.dart.snapshot的绝对路径，使用该snapshot来编译dart代码生成上面的app.dill snapshot_blob.bin.d : 这里面放的是所有参与编译的dart文件的绝对路径的集合，包括项目的代码和flutterSdk的代码以及pub库中的三方代码。 snapshot_blob.bin.d.fingerprint : 这里面放的是snapshot_blob.bin.d中的所有文件的绝对路径以及每个文件所对应的md5值。使用这个md5来判断该文件是否有修改。在每次编译的时候会判断，如果没有文件修改，则直接跳过编译。 编译Dart资源123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127Future&lt;void&gt; build(&#123; TargetPlatform platform, BuildMode buildMode, String mainPath = defaultMainPath, String manifestPath = defaultManifestPath, String applicationKernelFilePath, String depfilePath, String privateKeyPath = defaultPrivateKeyPath, String assetDirPath, String packagesPath, bool precompiledSnapshot = false, bool reportLicensedPackages = false, bool trackWidgetCreation = false, String compilationTraceFilePath, bool createPatch = false, String buildNumber, String baselineDir, List&lt;String&gt; extraFrontEndOptions = const &lt;String&gt;[], List&lt;String&gt; extraGenSnapshotOptions = const &lt;String&gt;[], List&lt;String&gt; fileSystemRoots, String fileSystemScheme,&#125;) async &#123; // xcode_backend.sh中通过--depfile传入进来的 // 默认是build/snapshot_blob.bin.d文件 depfilePath ??= defaultDepfilePath; // 通过--asset-dir传入 // 该目录中文件就是flutter的产物，最终合并到app.framework中的flutter_assets目录 assetDirPath ??= getAssetBuildDirectory(); packagesPath ??= fs.path.absolute(PackageMap.globalPackagesPath); // app.dill dart代码编译后的二级制文件 applicationKernelFilePath ??= getDefaultApplicationKernelPath(trackWidgetCreation: trackWidgetCreation); final FlutterProject flutterProject = await FlutterProject.current(); if (compilationTraceFilePath != null) &#123; if (buildMode != BuildMode.dynamicProfile &amp;&amp; buildMode != BuildMode.dynamicRelease) &#123; compilationTraceFilePath = null; &#125; else if (compilationTraceFilePath.isEmpty) &#123; // Disable JIT snapshotting if flag is empty. printStatus('Code snapshot will be disabled for this build.'); compilationTraceFilePath = null; &#125; else if (!fs.file(compilationTraceFilePath).existsSync()) &#123; // Be forgiving if compilation trace file is missing. printStatus('No compilation trace available. To optimize performance, consider using --train.'); final File tmp = fs.systemTempDirectory.childFile('flutterEmptyCompilationTrace.txt'); compilationTraceFilePath = (tmp..createSync(recursive: true)).path; &#125; else &#123; printStatus('Code snapshot will use compilation training file $compilationTraceFilePath.'); &#125; &#125; DevFSContent kernelContent; if (!precompiledSnapshot) &#123; if ((extraFrontEndOptions != null) &amp;&amp; extraFrontEndOptions.isNotEmpty) printTrace('Extra front-end options: $extraFrontEndOptions'); ensureDirectoryExists(applicationKernelFilePath); final KernelCompiler kernelCompiler = await kernelCompilerFactory.create(flutterProject); // 编译dart代码，生成app.dill 和 snapshot_blob.bin.d 以及 snapshot_blob.bin.d.fingerprint final CompilerOutput compilerOutput = await kernelCompiler.compile( sdkRoot: artifacts.getArtifactPath(Artifact.flutterPatchedSdkPath), incrementalCompilerByteStorePath: compilationTraceFilePath != null ? null : fs.path.absolute(getIncrementalCompilerByteStoreDirectory()), mainPath: fs.file(mainPath).absolute.path, outputFilePath: applicationKernelFilePath, depFilePath: depfilePath, trackWidgetCreation: trackWidgetCreation, extraFrontEndOptions: extraFrontEndOptions, fileSystemRoots: fileSystemRoots, fileSystemScheme: fileSystemScheme, packagesPath: packagesPath, linkPlatformKernelIn: compilationTraceFilePath != null, ); if (compilerOutput?.outputFilename == null) &#123; throwToolExit('Compiler failed on $mainPath'); &#125; kernelContent = DevFSFileContent(fs.file(compilerOutput.outputFilename)); // 生成 frontend_server.d文件，向文件中写入frontendServerSnapshotForEngineDartSdk的路径 await fs.directory(getBuildDirectory()).childFile('frontend_server.d') .writeAsString('frontend_server.d: $&#123;artifacts.getArtifactPath(Artifact.frontendServerSnapshotForEngineDartSdk)&#125;\n'); if (compilationTraceFilePath != null) &#123; final JITSnapshotter snapshotter = JITSnapshotter(); final int snapshotExitCode = await snapshotter.build( platform: platform, buildMode: buildMode, mainPath: applicationKernelFilePath, outputPath: getBuildDirectory(), packagesPath: packagesPath, compilationTraceFilePath: compilationTraceFilePath, extraGenSnapshotOptions: extraGenSnapshotOptions, createPatch: createPatch, buildNumber: buildNumber, baselineDir: baselineDir, ); if (snapshotExitCode != 0) &#123; throwToolExit('Snapshotting exited with non-zero exit code: $snapshotExitCode'); &#125; &#125; &#125; // 生成 flutter_assets final AssetBundle assets = await buildAssets( manifestPath: manifestPath, assetDirPath: assetDirPath, packagesPath: packagesPath, reportLicensedPackages: reportLicensedPackages, ); if (assets == null) throwToolExit('Error building assets', exitCode: 1); await assemble( buildMode: buildMode, assetBundle: assets, kernelContent: kernelContent, privateKeyPath: privateKeyPath, assetDirPath: assetDirPath, compilationTraceFilePath: compilationTraceFilePath, );&#125; 编译Dart代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596class KernelCompiler &#123; const KernelCompiler(); Future&lt;CompilerOutput&gt; compile(&#123; String sdkRoot, String mainPath, String outputFilePath, String depFilePath, TargetModel targetModel = TargetModel.flutter, bool linkPlatformKernelIn = false, bool aot = false, @required bool trackWidgetCreation, List&lt;String&gt; extraFrontEndOptions, String incrementalCompilerByteStorePath, String packagesPath, List&lt;String&gt; fileSystemRoots, String fileSystemScheme, bool targetProductVm = false, String initializeFromDill, &#125;) async &#123; final String frontendServer = artifacts.getArtifactPath( Artifact.frontendServerSnapshotForEngineDartSdk ); FlutterProject flutterProject; if (fs.file('pubspec.yaml').existsSync()) &#123; flutterProject = await FlutterProject.current(); &#125; // TODO(cbracken): eliminate pathFilter. // Currently the compiler emits buildbot paths for the core libs in the // depfile. None of these are available on the local host. Fingerprinter fingerprinter; // 如果snapshot_blob.bin.d文件不为空，则说明有编译缓存 if (depFilePath != null) &#123; // 判断与上次编译对比，是否有文件的md5改变 fingerprinter = Fingerprinter( // snapshot_blob.bin.d.fingerprint文件 fingerprintPath: '$depFilePath.fingerprint', paths: &lt;String&gt;[mainPath], properties: &lt;String, String&gt;&#123; 'entryPoint': mainPath, 'trackWidgetCreation': trackWidgetCreation.toString(), 'linkPlatformKernelIn': linkPlatformKernelIn.toString(), 'engineHash': Cache.instance.engineRevision, 'buildersUsed': '$&#123;flutterProject != null ? flutterProject.hasBuilders : false&#125;', &#125;, depfilePaths: &lt;String&gt;[depFilePath], pathFilter: (String path) =&gt; !path.startsWith('/b/build/slave/'), ); // 判断是否有文件改动，如果没有，则直接返回。 if (await fingerprinter.doesFingerprintMatch()) &#123; printTrace('Skipping kernel compilation. Fingerprint match.'); return CompilerOutput(outputFilePath, 0, /* sources */ null); &#125; &#125; ... // 如果没有上次编译缓存，或者文件有改变，Fingerprinter不匹配，则使用dart重新编译 final List&lt;String&gt; command = &lt;String&gt;[ engineDartPath, frontendServer, '--sdk-root', sdkRoot, '--strong', '--target=$targetModel', ]; ... //参数拼接 final Process server = await processManager .start(command) .catchError((dynamic error, StackTrace stack) &#123; printError('Failed to start frontend server $error, $stack'); &#125;); final StdoutHandler _stdoutHandler = StdoutHandler(); server.stderr .transform&lt;String&gt;(utf8.decoder) .listen(printError); server.stdout .transform&lt;String&gt;(utf8.decoder) .transform&lt;String&gt;(const LineSplitter()) .listen(_stdoutHandler.handler); final int exitCode = await server.exitCode; if (exitCode == 0) &#123; if (fingerprinter != null) &#123; await fingerprinter.writeFingerprint(); &#125; return _stdoutHandler.compilerOutput.future; &#125; return null; &#125;&#125; Fingerprint对比1234567891011121314151617181920212223242526Future&lt;bool&gt; doesFingerprintMatch() async &#123; try &#123; // 获取到当前的 snapshot_blob.bin.d.fingerprint文件 final File fingerprintFile = fs.file(fingerprintPath); if (!fingerprintFile.existsSync()) return false; if (!_depfilePaths.every(fs.isFileSync)) return false; final List&lt;String&gt; paths = await _getPaths(); if (!paths.every(fs.isFileSync)) return false; // 读取缓存的的snapshot_blob.bin.d.fingerprint文件，构建一个老的Fingerprint对象 final Fingerprint oldFingerprint = Fingerprint.fromJson(await fingerprintFile.readAsString()); // 构建一个新的Fingerprint对象 final Fingerprint newFingerprint = await buildFingerprint(); // 对比两次的文件集合中的每个文件的md5是否一样 return oldFingerprint == newFingerprint; &#125; catch (e) &#123; // Log exception and continue, fingerprinting is only a performance improvement. printTrace('Fingerprint check error: $e'); &#125; return false; &#125; 重点 看看 newFingerprint 12345678910111213Future&lt;Fingerprint&gt; buildFingerprint() async &#123; final List&lt;String&gt; paths = await _getPaths(); return Fingerprint.fromBuildInputs(_properties, paths);&#125;Future&lt;List&lt;String&gt;&gt; _getPaths() async &#123; final Set&lt;String&gt; paths = _paths.toSet(); // 使用缓存的snapshot_blob.bin.d文件中的文件集合 for (String depfilePath in _depfilePaths) paths.addAll(await readDepfile(depfilePath)); final FingerprintPathFilter filter = _pathFilter ?? (String path) =&gt; true; return paths.where(filter).toList()..sort();&#125; 可以看到newFingerprint 路径依旧是使用缓存的路径，依次计算路径对应文件的md5，所以问题就在这里了 执行flutter packages upgrade更新pub依赖的时候，build目录下的缓存产物并不会有任何变动，路径依然是老的路径。有一种情况就是module工程 lib 目录下的dat文件有改动，newFingerprint就会跟old不一样，这会重新编译dart，这里又有一个问题，就是如果lib目录下是新增dart文件 则不会被编译进去。 最后综上，执行flutter clean命令，清空build目录缓存文件，build ios 就会重新编译整个dart文件，包括pub依赖中的。 参考链接Flutter深入之flutter-build-bundle命令如何编译Dart?]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
        <tag>dart</tag>
      </tags>
  </entry>
</search>
